/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// SavingsApiService SavingsApi service
type SavingsApiService service

type ApiSapiV1LendingCustomizedFixedPurchasePostRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	projectId *string
	lot *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) ProjectId(projectId string) ApiSapiV1LendingCustomizedFixedPurchasePostRequest {
	r.projectId = &projectId
	return r
}
func (r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) Lot(lot string) ApiSapiV1LendingCustomizedFixedPurchasePostRequest {
	r.lot = &lot
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) Timestamp(timestamp int64) ApiSapiV1LendingCustomizedFixedPurchasePostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) Signature(signature string) ApiSapiV1LendingCustomizedFixedPurchasePostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingCustomizedFixedPurchasePostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) Execute() (InlineResponse20080, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingCustomizedFixedPurchasePostExecute(r)
}

/*
SapiV1LendingCustomizedFixedPurchasePost Purchase Fixed/Activity Project (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingCustomizedFixedPurchasePostRequest
*/
func (a *SavingsApiService) SapiV1LendingCustomizedFixedPurchasePost(ctx _context.Context) ApiSapiV1LendingCustomizedFixedPurchasePostRequest {
	return ApiSapiV1LendingCustomizedFixedPurchasePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20080
func (a *SavingsApiService) SapiV1LendingCustomizedFixedPurchasePostExecute(r ApiSapiV1LendingCustomizedFixedPurchasePostRequest) (InlineResponse20080, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20080
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingCustomizedFixedPurchasePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/customizedFixed/purchase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.lot == nil {
		return localVarReturnValue, nil, reportError("lot is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	localVarQueryParams.Add("lot", parameterToString(*r.lot, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingDailyProductListGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	status *string
	timestamp *int64
	signature *string
	featured *string
	current *int32
	size *int32
	recvWindow *int64
}

// \&quot;ALL\&quot;, \&quot;SUBSCRIBABLE\&quot;, \&quot;UNSUBSCRIBABLE\&quot;; Default: &#39;ALL&#39;
func (r ApiSapiV1LendingDailyProductListGetRequest) Status(status string) ApiSapiV1LendingDailyProductListGetRequest {
	r.status = &status
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingDailyProductListGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingDailyProductListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingDailyProductListGetRequest) Signature(signature string) ApiSapiV1LendingDailyProductListGetRequest {
	r.signature = &signature
	return r
}
// \&quot;ALL\&quot;, \&quot;TRUE\&quot;; Default: \&quot;ALL\&quot;
func (r ApiSapiV1LendingDailyProductListGetRequest) Featured(featured string) ApiSapiV1LendingDailyProductListGetRequest {
	r.featured = &featured
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1LendingDailyProductListGetRequest) Current(current int32) ApiSapiV1LendingDailyProductListGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1LendingDailyProductListGetRequest) Size(size int32) ApiSapiV1LendingDailyProductListGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingDailyProductListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingDailyProductListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingDailyProductListGetRequest) Execute() ([]InlineResponse20074, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingDailyProductListGetExecute(r)
}

/*
SapiV1LendingDailyProductListGet Get Flexible Product List (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingDailyProductListGetRequest
*/
func (a *SavingsApiService) SapiV1LendingDailyProductListGet(ctx _context.Context) ApiSapiV1LendingDailyProductListGetRequest {
	return ApiSapiV1LendingDailyProductListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20074
func (a *SavingsApiService) SapiV1LendingDailyProductListGetExecute(r ApiSapiV1LendingDailyProductListGetRequest) ([]InlineResponse20074, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20074
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingDailyProductListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/product/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	if r.featured != nil {
		localVarQueryParams.Add("featured", parameterToString(*r.featured, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingDailyPurchasePostRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	productId *string
	amount *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingDailyPurchasePostRequest) ProductId(productId string) ApiSapiV1LendingDailyPurchasePostRequest {
	r.productId = &productId
	return r
}
func (r ApiSapiV1LendingDailyPurchasePostRequest) Amount(amount float64) ApiSapiV1LendingDailyPurchasePostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingDailyPurchasePostRequest) Timestamp(timestamp int64) ApiSapiV1LendingDailyPurchasePostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingDailyPurchasePostRequest) Signature(signature string) ApiSapiV1LendingDailyPurchasePostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingDailyPurchasePostRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingDailyPurchasePostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingDailyPurchasePostRequest) Execute() (InlineResponse20076, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingDailyPurchasePostExecute(r)
}

/*
SapiV1LendingDailyPurchasePost Purchase Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingDailyPurchasePostRequest
*/
func (a *SavingsApiService) SapiV1LendingDailyPurchasePost(ctx _context.Context) ApiSapiV1LendingDailyPurchasePostRequest {
	return ApiSapiV1LendingDailyPurchasePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20076
func (a *SavingsApiService) SapiV1LendingDailyPurchasePostExecute(r ApiSapiV1LendingDailyPurchasePostRequest) (InlineResponse20076, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20076
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingDailyPurchasePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/purchase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingDailyRedeemPostRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	productId *string
	amount *float64
	type_ *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingDailyRedeemPostRequest) ProductId(productId string) ApiSapiV1LendingDailyRedeemPostRequest {
	r.productId = &productId
	return r
}
func (r ApiSapiV1LendingDailyRedeemPostRequest) Amount(amount float64) ApiSapiV1LendingDailyRedeemPostRequest {
	r.amount = &amount
	return r
}
// \&quot;FAST\&quot;, \&quot;NORMAL\&quot;
func (r ApiSapiV1LendingDailyRedeemPostRequest) Type_(type_ string) ApiSapiV1LendingDailyRedeemPostRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingDailyRedeemPostRequest) Timestamp(timestamp int64) ApiSapiV1LendingDailyRedeemPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingDailyRedeemPostRequest) Signature(signature string) ApiSapiV1LendingDailyRedeemPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingDailyRedeemPostRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingDailyRedeemPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingDailyRedeemPostRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingDailyRedeemPostExecute(r)
}

/*
SapiV1LendingDailyRedeemPost Redeem Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingDailyRedeemPostRequest
*/
func (a *SavingsApiService) SapiV1LendingDailyRedeemPost(ctx _context.Context) ApiSapiV1LendingDailyRedeemPostRequest {
	return ApiSapiV1LendingDailyRedeemPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SavingsApiService) SapiV1LendingDailyRedeemPostExecute(r ApiSapiV1LendingDailyRedeemPostRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingDailyRedeemPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingDailyTokenPositionGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	asset *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingDailyTokenPositionGetRequest) Asset(asset string) ApiSapiV1LendingDailyTokenPositionGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingDailyTokenPositionGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingDailyTokenPositionGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingDailyTokenPositionGetRequest) Signature(signature string) ApiSapiV1LendingDailyTokenPositionGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingDailyTokenPositionGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingDailyTokenPositionGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingDailyTokenPositionGetRequest) Execute() ([]InlineResponse20078, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingDailyTokenPositionGetExecute(r)
}

/*
SapiV1LendingDailyTokenPositionGet Get Flexible Product Position (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingDailyTokenPositionGetRequest
*/
func (a *SavingsApiService) SapiV1LendingDailyTokenPositionGet(ctx _context.Context) ApiSapiV1LendingDailyTokenPositionGetRequest {
	return ApiSapiV1LendingDailyTokenPositionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20078
func (a *SavingsApiService) SapiV1LendingDailyTokenPositionGetExecute(r ApiSapiV1LendingDailyTokenPositionGetRequest) ([]InlineResponse20078, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20078
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingDailyTokenPositionGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/token/position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingDailyUserLeftQuotaGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	productId *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingDailyUserLeftQuotaGetRequest) ProductId(productId string) ApiSapiV1LendingDailyUserLeftQuotaGetRequest {
	r.productId = &productId
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingDailyUserLeftQuotaGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingDailyUserLeftQuotaGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingDailyUserLeftQuotaGetRequest) Signature(signature string) ApiSapiV1LendingDailyUserLeftQuotaGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingDailyUserLeftQuotaGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingDailyUserLeftQuotaGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingDailyUserLeftQuotaGetRequest) Execute() (InlineResponse20075, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingDailyUserLeftQuotaGetExecute(r)
}

/*
SapiV1LendingDailyUserLeftQuotaGet Get Left Daily Purchase Quota of Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingDailyUserLeftQuotaGetRequest
*/
func (a *SavingsApiService) SapiV1LendingDailyUserLeftQuotaGet(ctx _context.Context) ApiSapiV1LendingDailyUserLeftQuotaGetRequest {
	return ApiSapiV1LendingDailyUserLeftQuotaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20075
func (a *SavingsApiService) SapiV1LendingDailyUserLeftQuotaGetExecute(r ApiSapiV1LendingDailyUserLeftQuotaGetRequest) (InlineResponse20075, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20075
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingDailyUserLeftQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/userLeftQuota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	productId *string
	type_ *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) ProductId(productId string) ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest {
	r.productId = &productId
	return r
}
// \&quot;FAST\&quot;, \&quot;NORMAL\&quot;
func (r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) Type_(type_ string) ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) Signature(signature string) ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) Execute() (InlineResponse20077, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingDailyUserRedemptionQuotaGetExecute(r)
}

/*
SapiV1LendingDailyUserRedemptionQuotaGet Get Left Daily Redemption Quota of Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest
*/
func (a *SavingsApiService) SapiV1LendingDailyUserRedemptionQuotaGet(ctx _context.Context) ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest {
	return ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20077
func (a *SavingsApiService) SapiV1LendingDailyUserRedemptionQuotaGetExecute(r ApiSapiV1LendingDailyUserRedemptionQuotaGetRequest) (InlineResponse20077, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20077
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingDailyUserRedemptionQuotaGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/userRedemptionQuota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingPositionChangedPostRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	projectId *string
	lot *string
	timestamp *int64
	signature *string
	positionId *string
	recvWindow *int64
}

func (r ApiSapiV1LendingPositionChangedPostRequest) ProjectId(projectId string) ApiSapiV1LendingPositionChangedPostRequest {
	r.projectId = &projectId
	return r
}
func (r ApiSapiV1LendingPositionChangedPostRequest) Lot(lot string) ApiSapiV1LendingPositionChangedPostRequest {
	r.lot = &lot
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingPositionChangedPostRequest) Timestamp(timestamp int64) ApiSapiV1LendingPositionChangedPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingPositionChangedPostRequest) Signature(signature string) ApiSapiV1LendingPositionChangedPostRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1LendingPositionChangedPostRequest) PositionId(positionId string) ApiSapiV1LendingPositionChangedPostRequest {
	r.positionId = &positionId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingPositionChangedPostRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingPositionChangedPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingPositionChangedPostRequest) Execute() (InlineResponse20084, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingPositionChangedPostExecute(r)
}

/*
SapiV1LendingPositionChangedPost Change Fixed/Activity Position to Daily Position (USER_DATA)

- PositionId is mandatory parameter for fixed position.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingPositionChangedPostRequest
*/
func (a *SavingsApiService) SapiV1LendingPositionChangedPost(ctx _context.Context) ApiSapiV1LendingPositionChangedPostRequest {
	return ApiSapiV1LendingPositionChangedPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20084
func (a *SavingsApiService) SapiV1LendingPositionChangedPostExecute(r ApiSapiV1LendingPositionChangedPostRequest) (InlineResponse20084, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20084
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingPositionChangedPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/positionChanged"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.lot == nil {
		return localVarReturnValue, nil, reportError("lot is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	localVarQueryParams.Add("lot", parameterToString(*r.lot, ""))
	if r.positionId != nil {
		localVarQueryParams.Add("positionId", parameterToString(*r.positionId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingProjectListGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	type_ *string
	status *string
	isSortAsc *bool
	sortBy *string
	timestamp *int64
	signature *string
	asset *string
	current *int32
	size *int32
	recvWindow *int64
}

// \&quot;ACTIVITY\&quot;, \&quot;CUSTOMIZED_FIXED\&quot;
func (r ApiSapiV1LendingProjectListGetRequest) Type_(type_ string) ApiSapiV1LendingProjectListGetRequest {
	r.type_ = &type_
	return r
}
// \&quot;ALL\&quot;, \&quot;SUBSCRIBABLE\&quot;, \&quot;UNSUBSCRIBABLE\&quot;; Default: &#39;ALL&#39;
func (r ApiSapiV1LendingProjectListGetRequest) Status(status string) ApiSapiV1LendingProjectListGetRequest {
	r.status = &status
	return r
}
// default \&quot;true\&quot;
func (r ApiSapiV1LendingProjectListGetRequest) IsSortAsc(isSortAsc bool) ApiSapiV1LendingProjectListGetRequest {
	r.isSortAsc = &isSortAsc
	return r
}
// \&quot;START_TIME\&quot;, \&quot;LOT_SIZE\&quot;, \&quot;INTEREST_RATE\&quot;, \&quot;DURATION\&quot;; default \&quot;START_TIME
func (r ApiSapiV1LendingProjectListGetRequest) SortBy(sortBy string) ApiSapiV1LendingProjectListGetRequest {
	r.sortBy = &sortBy
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingProjectListGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingProjectListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingProjectListGetRequest) Signature(signature string) ApiSapiV1LendingProjectListGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1LendingProjectListGetRequest) Asset(asset string) ApiSapiV1LendingProjectListGetRequest {
	r.asset = &asset
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1LendingProjectListGetRequest) Current(current int32) ApiSapiV1LendingProjectListGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1LendingProjectListGetRequest) Size(size int32) ApiSapiV1LendingProjectListGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingProjectListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingProjectListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingProjectListGetRequest) Execute() ([]InlineResponse20079, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingProjectListGetExecute(r)
}

/*
SapiV1LendingProjectListGet Get Fixed/Activity Project List(USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingProjectListGetRequest
*/
func (a *SavingsApiService) SapiV1LendingProjectListGet(ctx _context.Context) ApiSapiV1LendingProjectListGetRequest {
	return ApiSapiV1LendingProjectListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20079
func (a *SavingsApiService) SapiV1LendingProjectListGetExecute(r ApiSapiV1LendingProjectListGetRequest) ([]InlineResponse20079, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20079
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingProjectListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/project/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.isSortAsc == nil {
		return localVarReturnValue, nil, reportError("isSortAsc is required and must be specified")
	}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	localVarQueryParams.Add("isSortAsc", parameterToString(*r.isSortAsc, ""))
	localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingProjectPositionListGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	asset *string
	projectId *string
	status *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1LendingProjectPositionListGetRequest) Asset(asset string) ApiSapiV1LendingProjectPositionListGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1LendingProjectPositionListGetRequest) ProjectId(projectId string) ApiSapiV1LendingProjectPositionListGetRequest {
	r.projectId = &projectId
	return r
}
// \&quot;ALL\&quot;, \&quot;SUBSCRIBABLE\&quot;, \&quot;UNSUBSCRIBABLE\&quot;; Default: &#39;ALL&#39;
func (r ApiSapiV1LendingProjectPositionListGetRequest) Status(status string) ApiSapiV1LendingProjectPositionListGetRequest {
	r.status = &status
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingProjectPositionListGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingProjectPositionListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingProjectPositionListGetRequest) Signature(signature string) ApiSapiV1LendingProjectPositionListGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingProjectPositionListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingProjectPositionListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingProjectPositionListGetRequest) Execute() ([]InlineResponse20081, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingProjectPositionListGetExecute(r)
}

/*
SapiV1LendingProjectPositionListGet Get Fixed/Activity Project Position (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingProjectPositionListGetRequest
*/
func (a *SavingsApiService) SapiV1LendingProjectPositionListGet(ctx _context.Context) ApiSapiV1LendingProjectPositionListGetRequest {
	return ApiSapiV1LendingProjectPositionListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20081
func (a *SavingsApiService) SapiV1LendingProjectPositionListGetExecute(r ApiSapiV1LendingProjectPositionListGetRequest) ([]InlineResponse20081, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20081
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingProjectPositionListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/project/position/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingUnionAccountGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1LendingUnionAccountGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingUnionAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingUnionAccountGetRequest) Signature(signature string) ApiSapiV1LendingUnionAccountGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingUnionAccountGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingUnionAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingUnionAccountGetRequest) Execute() (InlineResponse20082, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingUnionAccountGetExecute(r)
}

/*
SapiV1LendingUnionAccountGet Lending Account (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingUnionAccountGetRequest
*/
func (a *SavingsApiService) SapiV1LendingUnionAccountGet(ctx _context.Context) ApiSapiV1LendingUnionAccountGetRequest {
	return ApiSapiV1LendingUnionAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20082
func (a *SavingsApiService) SapiV1LendingUnionAccountGetExecute(r ApiSapiV1LendingUnionAccountGetRequest) (InlineResponse20082, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20082
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingUnionAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingUnionInterestHistoryGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	lendingType *string
	timestamp *int64
	signature *string
	asset *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	recvWindow *int64
}

// \&quot;DAILY\&quot; for flexible, \&quot;ACTIVITY\&quot; for activity, \&quot;CUSTOMIZED_FIXED\&quot; for fixed
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) LendingType(lendingType string) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.lendingType = &lendingType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) Signature(signature string) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) Asset(asset string) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) StartTime(startTime int64) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) EndTime(endTime int64) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) Current(current int32) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) Size(size int32) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingUnionInterestHistoryGetRequest) Execute() ([]InlineResponse20083, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingUnionInterestHistoryGetExecute(r)
}

/*
SapiV1LendingUnionInterestHistoryGet Get Interest History (USER_DATA)

- The time between startTime and endTime cannot be longer than 30 days.
- If startTime and endTime are both not sent, then the last 30 days' data will be returned.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingUnionInterestHistoryGetRequest
*/
func (a *SavingsApiService) SapiV1LendingUnionInterestHistoryGet(ctx _context.Context) ApiSapiV1LendingUnionInterestHistoryGetRequest {
	return ApiSapiV1LendingUnionInterestHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20083
func (a *SavingsApiService) SapiV1LendingUnionInterestHistoryGetExecute(r ApiSapiV1LendingUnionInterestHistoryGetRequest) ([]InlineResponse20083, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20083
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingUnionInterestHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/interestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lendingType == nil {
		return localVarReturnValue, nil, reportError("lendingType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("lendingType", parameterToString(*r.lendingType, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingUnionPurchaseRecordGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	lendingType *string
	timestamp *int64
	signature *string
	asset *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	recvWindow *int64
}

// \&quot;DAILY\&quot; for flexible, \&quot;ACTIVITY\&quot; for activity, \&quot;CUSTOMIZED_FIXED\&quot; for fixed
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) LendingType(lendingType string) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.lendingType = &lendingType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) Signature(signature string) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) Asset(asset string) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) StartTime(startTime int64) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) EndTime(endTime int64) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) Current(current int32) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) Size(size int32) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingUnionPurchaseRecordGetRequest) Execute() (OneOfarrayarray, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingUnionPurchaseRecordGetExecute(r)
}

/*
SapiV1LendingUnionPurchaseRecordGet Get Purchase Record (USER_DATA)

- The time between startTime and endTime cannot be longer than 30 days.
- If startTime and endTime are both not sent, then the last 30 days' data will be returned.

Weigh(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingUnionPurchaseRecordGetRequest
*/
func (a *SavingsApiService) SapiV1LendingUnionPurchaseRecordGet(ctx _context.Context) ApiSapiV1LendingUnionPurchaseRecordGetRequest {
	return ApiSapiV1LendingUnionPurchaseRecordGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfarrayarray
func (a *SavingsApiService) SapiV1LendingUnionPurchaseRecordGetExecute(r ApiSapiV1LendingUnionPurchaseRecordGetRequest) (OneOfarrayarray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfarrayarray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingUnionPurchaseRecordGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/purchaseRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lendingType == nil {
		return localVarReturnValue, nil, reportError("lendingType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("lendingType", parameterToString(*r.lendingType, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1LendingUnionRedemptionRecordGetRequest struct {
	ctx _context.Context
	ApiService *SavingsApiService
	lendingType *string
	timestamp *int64
	signature *string
	asset *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	recvWindow *int64
}

// \&quot;DAILY\&quot; for flexible, \&quot;ACTIVITY\&quot; for activity, \&quot;CUSTOMIZED_FIXED\&quot; for fixed
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) LendingType(lendingType string) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.lendingType = &lendingType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) Timestamp(timestamp int64) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) Signature(signature string) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) Asset(asset string) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) StartTime(startTime int64) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) EndTime(endTime int64) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) Current(current int32) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) Size(size int32) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) RecvWindow(recvWindow int64) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1LendingUnionRedemptionRecordGetRequest) Execute() (OneOfarrayarray, *_nethttp.Response, error) {
	return r.ApiService.SapiV1LendingUnionRedemptionRecordGetExecute(r)
}

/*
SapiV1LendingUnionRedemptionRecordGet Get Redemption Record (USER_DATA)

- The time between startTime and endTime cannot be longer than 30 days.
- If startTime and endTime are both not sent, then the last 30 days' data will be returned.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1LendingUnionRedemptionRecordGetRequest
*/
func (a *SavingsApiService) SapiV1LendingUnionRedemptionRecordGet(ctx _context.Context) ApiSapiV1LendingUnionRedemptionRecordGetRequest {
	return ApiSapiV1LendingUnionRedemptionRecordGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfarrayarray
func (a *SavingsApiService) SapiV1LendingUnionRedemptionRecordGetExecute(r ApiSapiV1LendingUnionRedemptionRecordGetRequest) (OneOfarrayarray, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfarrayarray
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.SapiV1LendingUnionRedemptionRecordGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/redemptionRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lendingType == nil {
		return localVarReturnValue, nil, reportError("lendingType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("lendingType", parameterToString(*r.lendingType, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
