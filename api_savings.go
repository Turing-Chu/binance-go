/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API generated with [binance/binance-api-swagger/blob/master/spot_api.yaml](https://github.com/binance/binance-api-swagger/blob/master/spot_api.yaml) with commit [v1.2.0 release](https://github.com/binance/binance-api-swagger/commit/60d14be031c031600c853d5cdab86db5ab73603e)  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
Contact: qishiwenjun@163.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// SavingsApiService SavingsApi service
type SavingsApiService service

type ApiLendingChangeFixedOrActivityToDailyPositionRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	projectId  *string
	lot        *string
	timestamp  *int64
	signature  *string
	positionId *string
	recvWindow *int64
}

func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) ProjectId(projectId string) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	r.projectId = &projectId
	return r
}
func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) Lot(lot string) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	r.lot = &lot
	return r
}

// UTC timestamp in ms
func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) Timestamp(timestamp int64) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) Signature(signature string) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	r.signature = &signature
	return r
}
func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) PositionId(positionId string) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	r.positionId = &positionId
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) RecvWindow(recvWindow int64) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingChangeFixedOrActivityToDailyPositionRequest) Execute() (InlineResponse20084, *_nethttp.Response, error) {
	return r.ApiService.LendingChangeFixedOrActivityToDailyPositionExecute(r)
}

/*
LendingChangeFixedOrActivityToDailyPosition Change Fixed/Activity Position to Daily Position (USER_DATA)

- PositionId is mandatory parameter for fixed position.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingChangeFixedOrActivityToDailyPositionRequest
*/
func (a *SavingsApiService) LendingChangeFixedOrActivityToDailyPosition(ctx _context.Context) ApiLendingChangeFixedOrActivityToDailyPositionRequest {
	return ApiLendingChangeFixedOrActivityToDailyPositionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20084
func (a *SavingsApiService) LendingChangeFixedOrActivityToDailyPositionExecute(r ApiLendingChangeFixedOrActivityToDailyPositionRequest) (InlineResponse20084, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20084
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingChangeFixedOrActivityToDailyPosition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/positionChanged"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.lot == nil {
		return localVarReturnValue, nil, reportError("lot is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	localVarQueryParams.Add("lot", parameterToString(*r.lot, ""))
	if r.positionId != nil {
		localVarQueryParams.Add("positionId", parameterToString(*r.positionId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetAccountRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiLendingGetAccountRequest) Timestamp(timestamp int64) ApiLendingGetAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetAccountRequest) Signature(signature string) ApiLendingGetAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetAccountRequest) RecvWindow(recvWindow int64) ApiLendingGetAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetAccountRequest) Execute() (InlineResponse20082, *_nethttp.Response, error) {
	return r.ApiService.LendingGetAccountExecute(r)
}

/*
LendingGetAccount Lending Account (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetAccountRequest
*/
func (a *SavingsApiService) LendingGetAccount(ctx _context.Context) ApiLendingGetAccountRequest {
	return ApiLendingGetAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20082
func (a *SavingsApiService) LendingGetAccountExecute(r ApiLendingGetAccountRequest) (InlineResponse20082, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20082
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetFixedOrActivityProjectPositionRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	asset      *string
	projectId  *string
	status     *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingGetFixedOrActivityProjectPositionRequest) Asset(asset string) ApiLendingGetFixedOrActivityProjectPositionRequest {
	r.asset = &asset
	return r
}
func (r ApiLendingGetFixedOrActivityProjectPositionRequest) ProjectId(projectId string) ApiLendingGetFixedOrActivityProjectPositionRequest {
	r.projectId = &projectId
	return r
}

// \&quot;ALL\&quot;, \&quot;SUBSCRIBABLE\&quot;, \&quot;UNSUBSCRIBABLE\&quot;; Default: &#39;ALL&#39;
func (r ApiLendingGetFixedOrActivityProjectPositionRequest) Status(status string) ApiLendingGetFixedOrActivityProjectPositionRequest {
	r.status = &status
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetFixedOrActivityProjectPositionRequest) Timestamp(timestamp int64) ApiLendingGetFixedOrActivityProjectPositionRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetFixedOrActivityProjectPositionRequest) Signature(signature string) ApiLendingGetFixedOrActivityProjectPositionRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetFixedOrActivityProjectPositionRequest) RecvWindow(recvWindow int64) ApiLendingGetFixedOrActivityProjectPositionRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetFixedOrActivityProjectPositionRequest) Execute() ([]InlineResponse20081, *_nethttp.Response, error) {
	return r.ApiService.LendingGetFixedOrActivityProjectPositionExecute(r)
}

/*
LendingGetFixedOrActivityProjectPosition Get Fixed/Activity Project Position (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetFixedOrActivityProjectPositionRequest
*/
func (a *SavingsApiService) LendingGetFixedOrActivityProjectPosition(ctx _context.Context) ApiLendingGetFixedOrActivityProjectPositionRequest {
	return ApiLendingGetFixedOrActivityProjectPositionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20081
func (a *SavingsApiService) LendingGetFixedOrActivityProjectPositionExecute(r ApiLendingGetFixedOrActivityProjectPositionRequest) ([]InlineResponse20081, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20081
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetFixedOrActivityProjectPosition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/project/position/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetFixedOrActivityProjectsRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	type_      *string
	status     *string
	isSortAsc  *bool
	sortBy     *string
	timestamp  *int64
	signature  *string
	asset      *string
	current    *int32
	size       *int32
	recvWindow *int64
}

// \&quot;ACTIVITY\&quot;, \&quot;CUSTOMIZED_FIXED\&quot;
func (r ApiLendingGetFixedOrActivityProjectsRequest) Type_(type_ string) ApiLendingGetFixedOrActivityProjectsRequest {
	r.type_ = &type_
	return r
}

// \&quot;ALL\&quot;, \&quot;SUBSCRIBABLE\&quot;, \&quot;UNSUBSCRIBABLE\&quot;; Default: &#39;ALL&#39;
func (r ApiLendingGetFixedOrActivityProjectsRequest) Status(status string) ApiLendingGetFixedOrActivityProjectsRequest {
	r.status = &status
	return r
}

// default \&quot;true\&quot;
func (r ApiLendingGetFixedOrActivityProjectsRequest) IsSortAsc(isSortAsc bool) ApiLendingGetFixedOrActivityProjectsRequest {
	r.isSortAsc = &isSortAsc
	return r
}

// \&quot;START_TIME\&quot;, \&quot;LOT_SIZE\&quot;, \&quot;INTEREST_RATE\&quot;, \&quot;DURATION\&quot;; default \&quot;START_TIME
func (r ApiLendingGetFixedOrActivityProjectsRequest) SortBy(sortBy string) ApiLendingGetFixedOrActivityProjectsRequest {
	r.sortBy = &sortBy
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetFixedOrActivityProjectsRequest) Timestamp(timestamp int64) ApiLendingGetFixedOrActivityProjectsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetFixedOrActivityProjectsRequest) Signature(signature string) ApiLendingGetFixedOrActivityProjectsRequest {
	r.signature = &signature
	return r
}
func (r ApiLendingGetFixedOrActivityProjectsRequest) Asset(asset string) ApiLendingGetFixedOrActivityProjectsRequest {
	r.asset = &asset
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiLendingGetFixedOrActivityProjectsRequest) Current(current int32) ApiLendingGetFixedOrActivityProjectsRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiLendingGetFixedOrActivityProjectsRequest) Size(size int32) ApiLendingGetFixedOrActivityProjectsRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetFixedOrActivityProjectsRequest) RecvWindow(recvWindow int64) ApiLendingGetFixedOrActivityProjectsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetFixedOrActivityProjectsRequest) Execute() ([]InlineResponse20079, *_nethttp.Response, error) {
	return r.ApiService.LendingGetFixedOrActivityProjectsExecute(r)
}

/*
LendingGetFixedOrActivityProjects Get Fixed/Activity Project List(USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetFixedOrActivityProjectsRequest
*/
func (a *SavingsApiService) LendingGetFixedOrActivityProjects(ctx _context.Context) ApiLendingGetFixedOrActivityProjectsRequest {
	return ApiLendingGetFixedOrActivityProjectsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20079
func (a *SavingsApiService) LendingGetFixedOrActivityProjectsExecute(r ApiLendingGetFixedOrActivityProjectsRequest) ([]InlineResponse20079, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20079
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetFixedOrActivityProjects")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/project/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.isSortAsc == nil {
		return localVarReturnValue, nil, reportError("isSortAsc is required and must be specified")
	}
	if r.sortBy == nil {
		return localVarReturnValue, nil, reportError("sortBy is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	localVarQueryParams.Add("isSortAsc", parameterToString(*r.isSortAsc, ""))
	localVarQueryParams.Add("sortBy", parameterToString(*r.sortBy, ""))
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetFlexibleProductPositionRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	asset      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingGetFlexibleProductPositionRequest) Asset(asset string) ApiLendingGetFlexibleProductPositionRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetFlexibleProductPositionRequest) Timestamp(timestamp int64) ApiLendingGetFlexibleProductPositionRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetFlexibleProductPositionRequest) Signature(signature string) ApiLendingGetFlexibleProductPositionRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetFlexibleProductPositionRequest) RecvWindow(recvWindow int64) ApiLendingGetFlexibleProductPositionRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetFlexibleProductPositionRequest) Execute() ([]InlineResponse20078, *_nethttp.Response, error) {
	return r.ApiService.LendingGetFlexibleProductPositionExecute(r)
}

/*
LendingGetFlexibleProductPosition Get Flexible Product Position (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetFlexibleProductPositionRequest
*/
func (a *SavingsApiService) LendingGetFlexibleProductPosition(ctx _context.Context) ApiLendingGetFlexibleProductPositionRequest {
	return ApiLendingGetFlexibleProductPositionRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20078
func (a *SavingsApiService) LendingGetFlexibleProductPositionExecute(r ApiLendingGetFlexibleProductPositionRequest) ([]InlineResponse20078, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20078
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetFlexibleProductPosition")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/token/position"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetInterestHistoryRequest struct {
	ctx         _context.Context
	ApiService  *SavingsApiService
	lendingType *string
	timestamp   *int64
	signature   *string
	asset       *string
	startTime   *int64
	endTime     *int64
	current     *int32
	size        *int32
	recvWindow  *int64
}

// \&quot;DAILY\&quot; for flexible, \&quot;ACTIVITY\&quot; for activity, \&quot;CUSTOMIZED_FIXED\&quot; for fixed
func (r ApiLendingGetInterestHistoryRequest) LendingType(lendingType string) ApiLendingGetInterestHistoryRequest {
	r.lendingType = &lendingType
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetInterestHistoryRequest) Timestamp(timestamp int64) ApiLendingGetInterestHistoryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetInterestHistoryRequest) Signature(signature string) ApiLendingGetInterestHistoryRequest {
	r.signature = &signature
	return r
}
func (r ApiLendingGetInterestHistoryRequest) Asset(asset string) ApiLendingGetInterestHistoryRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetInterestHistoryRequest) StartTime(startTime int64) ApiLendingGetInterestHistoryRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetInterestHistoryRequest) EndTime(endTime int64) ApiLendingGetInterestHistoryRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiLendingGetInterestHistoryRequest) Current(current int32) ApiLendingGetInterestHistoryRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiLendingGetInterestHistoryRequest) Size(size int32) ApiLendingGetInterestHistoryRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetInterestHistoryRequest) RecvWindow(recvWindow int64) ApiLendingGetInterestHistoryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetInterestHistoryRequest) Execute() ([]InlineResponse20083, *_nethttp.Response, error) {
	return r.ApiService.LendingGetInterestHistoryExecute(r)
}

/*
LendingGetInterestHistory Get Interest History (USER_DATA)

- The time between startTime and endTime cannot be longer than 30 days.
- If startTime and endTime are both not sent, then the last 30 days' data will be returned.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetInterestHistoryRequest
*/
func (a *SavingsApiService) LendingGetInterestHistory(ctx _context.Context) ApiLendingGetInterestHistoryRequest {
	return ApiLendingGetInterestHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20083
func (a *SavingsApiService) LendingGetInterestHistoryExecute(r ApiLendingGetInterestHistoryRequest) ([]InlineResponse20083, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20083
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetInterestHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/interestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lendingType == nil {
		return localVarReturnValue, nil, reportError("lendingType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("lendingType", parameterToString(*r.lendingType, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	productId  *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest) ProductId(productId string) ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest {
	r.productId = &productId
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest) Timestamp(timestamp int64) ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest) Signature(signature string) ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest) RecvWindow(recvWindow int64) ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest) Execute() (InlineResponse20075, *_nethttp.Response, error) {
	return r.ApiService.LendingGetLeftDailyPurchaseQuotaOfFlexibleProductExecute(r)
}

/*
LendingGetLeftDailyPurchaseQuotaOfFlexibleProduct Get Left Daily Purchase Quota of Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest
*/
func (a *SavingsApiService) LendingGetLeftDailyPurchaseQuotaOfFlexibleProduct(ctx _context.Context) ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest {
	return ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20075
func (a *SavingsApiService) LendingGetLeftDailyPurchaseQuotaOfFlexibleProductExecute(r ApiLendingGetLeftDailyPurchaseQuotaOfFlexibleProductRequest) (InlineResponse20075, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20075
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetLeftDailyPurchaseQuotaOfFlexibleProduct")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/userLeftQuota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	productId  *string
	type_      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) ProductId(productId string) ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest {
	r.productId = &productId
	return r
}

// \&quot;FAST\&quot;, \&quot;NORMAL\&quot;
func (r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) Type_(type_ string) ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) Timestamp(timestamp int64) ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) Signature(signature string) ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) RecvWindow(recvWindow int64) ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) Execute() (InlineResponse20077, *_nethttp.Response, error) {
	return r.ApiService.LendingGetLeftDailyRedemptionQuotaOfFlexibleProductExecute(r)
}

/*
LendingGetLeftDailyRedemptionQuotaOfFlexibleProduct Get Left Daily Redemption Quota of Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest
*/
func (a *SavingsApiService) LendingGetLeftDailyRedemptionQuotaOfFlexibleProduct(ctx _context.Context) ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest {
	return ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20077
func (a *SavingsApiService) LendingGetLeftDailyRedemptionQuotaOfFlexibleProductExecute(r ApiLendingGetLeftDailyRedemptionQuotaOfFlexibleProductRequest) (InlineResponse20077, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20077
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetLeftDailyRedemptionQuotaOfFlexibleProduct")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/userRedemptionQuota"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetPurchaseRecordRequest struct {
	ctx         _context.Context
	ApiService  *SavingsApiService
	lendingType *string
	timestamp   *int64
	signature   *string
	asset       *string
	startTime   *int64
	endTime     *int64
	current     *int32
	size        *int32
	recvWindow  *int64
}

// \&quot;DAILY\&quot; for flexible, \&quot;ACTIVITY\&quot; for activity, \&quot;CUSTOMIZED_FIXED\&quot; for fixed
func (r ApiLendingGetPurchaseRecordRequest) LendingType(lendingType string) ApiLendingGetPurchaseRecordRequest {
	r.lendingType = &lendingType
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetPurchaseRecordRequest) Timestamp(timestamp int64) ApiLendingGetPurchaseRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetPurchaseRecordRequest) Signature(signature string) ApiLendingGetPurchaseRecordRequest {
	r.signature = &signature
	return r
}
func (r ApiLendingGetPurchaseRecordRequest) Asset(asset string) ApiLendingGetPurchaseRecordRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetPurchaseRecordRequest) StartTime(startTime int64) ApiLendingGetPurchaseRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetPurchaseRecordRequest) EndTime(endTime int64) ApiLendingGetPurchaseRecordRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiLendingGetPurchaseRecordRequest) Current(current int32) ApiLendingGetPurchaseRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiLendingGetPurchaseRecordRequest) Size(size int32) ApiLendingGetPurchaseRecordRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetPurchaseRecordRequest) RecvWindow(recvWindow int64) ApiLendingGetPurchaseRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetPurchaseRecordRequest) Execute() (OneOfsavingsFlexiblePurchaseRecordsavingsFixedActivityPurchaseRecord, *_nethttp.Response, error) {
	return r.ApiService.LendingGetPurchaseRecordExecute(r)
}

/*
LendingGetPurchaseRecord Get Purchase Record (USER_DATA)

- The time between startTime and endTime cannot be longer than 30 days.
- If startTime and endTime are both not sent, then the last 30 days' data will be returned.

Weigh(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetPurchaseRecordRequest
*/
func (a *SavingsApiService) LendingGetPurchaseRecord(ctx _context.Context) ApiLendingGetPurchaseRecordRequest {
	return ApiLendingGetPurchaseRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfsavingsFlexiblePurchaseRecordsavingsFixedActivityPurchaseRecord
func (a *SavingsApiService) LendingGetPurchaseRecordExecute(r ApiLendingGetPurchaseRecordRequest) (OneOfsavingsFlexiblePurchaseRecordsavingsFixedActivityPurchaseRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfsavingsFlexiblePurchaseRecordsavingsFixedActivityPurchaseRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetPurchaseRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/purchaseRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lendingType == nil {
		return localVarReturnValue, nil, reportError("lendingType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("lendingType", parameterToString(*r.lendingType, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingGetRedemptionRecordRequest struct {
	ctx         _context.Context
	ApiService  *SavingsApiService
	lendingType *string
	timestamp   *int64
	signature   *string
	asset       *string
	startTime   *int64
	endTime     *int64
	current     *int32
	size        *int32
	recvWindow  *int64
}

// \&quot;DAILY\&quot; for flexible, \&quot;ACTIVITY\&quot; for activity, \&quot;CUSTOMIZED_FIXED\&quot; for fixed
func (r ApiLendingGetRedemptionRecordRequest) LendingType(lendingType string) ApiLendingGetRedemptionRecordRequest {
	r.lendingType = &lendingType
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetRedemptionRecordRequest) Timestamp(timestamp int64) ApiLendingGetRedemptionRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingGetRedemptionRecordRequest) Signature(signature string) ApiLendingGetRedemptionRecordRequest {
	r.signature = &signature
	return r
}
func (r ApiLendingGetRedemptionRecordRequest) Asset(asset string) ApiLendingGetRedemptionRecordRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetRedemptionRecordRequest) StartTime(startTime int64) ApiLendingGetRedemptionRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiLendingGetRedemptionRecordRequest) EndTime(endTime int64) ApiLendingGetRedemptionRecordRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiLendingGetRedemptionRecordRequest) Current(current int32) ApiLendingGetRedemptionRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiLendingGetRedemptionRecordRequest) Size(size int32) ApiLendingGetRedemptionRecordRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingGetRedemptionRecordRequest) RecvWindow(recvWindow int64) ApiLendingGetRedemptionRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingGetRedemptionRecordRequest) Execute() (OneOfsavingsFlexibleRedemptionRecordsavingsFixedActivityRedemptionRecord, *_nethttp.Response, error) {
	return r.ApiService.LendingGetRedemptionRecordExecute(r)
}

/*
LendingGetRedemptionRecord Get Redemption Record (USER_DATA)

- The time between startTime and endTime cannot be longer than 30 days.
- If startTime and endTime are both not sent, then the last 30 days' data will be returned.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingGetRedemptionRecordRequest
*/
func (a *SavingsApiService) LendingGetRedemptionRecord(ctx _context.Context) ApiLendingGetRedemptionRecordRequest {
	return ApiLendingGetRedemptionRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfsavingsFlexibleRedemptionRecordsavingsFixedActivityRedemptionRecord
func (a *SavingsApiService) LendingGetRedemptionRecordExecute(r ApiLendingGetRedemptionRecordRequest) (OneOfsavingsFlexibleRedemptionRecordsavingsFixedActivityRedemptionRecord, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfsavingsFlexibleRedemptionRecordsavingsFixedActivityRedemptionRecord
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingGetRedemptionRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/union/redemptionRecord"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.lendingType == nil {
		return localVarReturnValue, nil, reportError("lendingType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("lendingType", parameterToString(*r.lendingType, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingListFlexibleProductsRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	status     *string
	timestamp  *int64
	signature  *string
	featured   *string
	current    *int32
	size       *int32
	recvWindow *int64
}

// \&quot;ALL\&quot;, \&quot;SUBSCRIBABLE\&quot;, \&quot;UNSUBSCRIBABLE\&quot;; Default: &#39;ALL&#39;
func (r ApiLendingListFlexibleProductsRequest) Status(status string) ApiLendingListFlexibleProductsRequest {
	r.status = &status
	return r
}

// UTC timestamp in ms
func (r ApiLendingListFlexibleProductsRequest) Timestamp(timestamp int64) ApiLendingListFlexibleProductsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingListFlexibleProductsRequest) Signature(signature string) ApiLendingListFlexibleProductsRequest {
	r.signature = &signature
	return r
}

// \&quot;ALL\&quot;, \&quot;TRUE\&quot;; Default: \&quot;ALL\&quot;
func (r ApiLendingListFlexibleProductsRequest) Featured(featured string) ApiLendingListFlexibleProductsRequest {
	r.featured = &featured
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiLendingListFlexibleProductsRequest) Current(current int32) ApiLendingListFlexibleProductsRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiLendingListFlexibleProductsRequest) Size(size int32) ApiLendingListFlexibleProductsRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingListFlexibleProductsRequest) RecvWindow(recvWindow int64) ApiLendingListFlexibleProductsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingListFlexibleProductsRequest) Execute() ([]InlineResponse20074, *_nethttp.Response, error) {
	return r.ApiService.LendingListFlexibleProductsExecute(r)
}

/*
LendingListFlexibleProducts Get Flexible Product List (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingListFlexibleProductsRequest
*/
func (a *SavingsApiService) LendingListFlexibleProducts(ctx _context.Context) ApiLendingListFlexibleProductsRequest {
	return ApiLendingListFlexibleProductsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20074
func (a *SavingsApiService) LendingListFlexibleProductsExecute(r ApiLendingListFlexibleProductsRequest) ([]InlineResponse20074, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20074
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingListFlexibleProducts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/product/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.status == nil {
		return localVarReturnValue, nil, reportError("status is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	if r.featured != nil {
		localVarQueryParams.Add("featured", parameterToString(*r.featured, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingPurchaseFixedOrActivityProjectRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	projectId  *string
	lot        *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingPurchaseFixedOrActivityProjectRequest) ProjectId(projectId string) ApiLendingPurchaseFixedOrActivityProjectRequest {
	r.projectId = &projectId
	return r
}
func (r ApiLendingPurchaseFixedOrActivityProjectRequest) Lot(lot string) ApiLendingPurchaseFixedOrActivityProjectRequest {
	r.lot = &lot
	return r
}

// UTC timestamp in ms
func (r ApiLendingPurchaseFixedOrActivityProjectRequest) Timestamp(timestamp int64) ApiLendingPurchaseFixedOrActivityProjectRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingPurchaseFixedOrActivityProjectRequest) Signature(signature string) ApiLendingPurchaseFixedOrActivityProjectRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingPurchaseFixedOrActivityProjectRequest) RecvWindow(recvWindow int64) ApiLendingPurchaseFixedOrActivityProjectRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingPurchaseFixedOrActivityProjectRequest) Execute() (InlineResponse20080, *_nethttp.Response, error) {
	return r.ApiService.LendingPurchaseFixedOrActivityProjectExecute(r)
}

/*
LendingPurchaseFixedOrActivityProject Purchase Fixed/Activity Project (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingPurchaseFixedOrActivityProjectRequest
*/
func (a *SavingsApiService) LendingPurchaseFixedOrActivityProject(ctx _context.Context) ApiLendingPurchaseFixedOrActivityProjectRequest {
	return ApiLendingPurchaseFixedOrActivityProjectRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20080
func (a *SavingsApiService) LendingPurchaseFixedOrActivityProjectExecute(r ApiLendingPurchaseFixedOrActivityProjectRequest) (InlineResponse20080, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20080
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingPurchaseFixedOrActivityProject")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/customizedFixed/purchase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.projectId == nil {
		return localVarReturnValue, nil, reportError("projectId is required and must be specified")
	}
	if r.lot == nil {
		return localVarReturnValue, nil, reportError("lot is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("projectId", parameterToString(*r.projectId, ""))
	localVarQueryParams.Add("lot", parameterToString(*r.lot, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingPurchaseFlexibleProductRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	productId  *string
	amount     *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingPurchaseFlexibleProductRequest) ProductId(productId string) ApiLendingPurchaseFlexibleProductRequest {
	r.productId = &productId
	return r
}
func (r ApiLendingPurchaseFlexibleProductRequest) Amount(amount float64) ApiLendingPurchaseFlexibleProductRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiLendingPurchaseFlexibleProductRequest) Timestamp(timestamp int64) ApiLendingPurchaseFlexibleProductRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingPurchaseFlexibleProductRequest) Signature(signature string) ApiLendingPurchaseFlexibleProductRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingPurchaseFlexibleProductRequest) RecvWindow(recvWindow int64) ApiLendingPurchaseFlexibleProductRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingPurchaseFlexibleProductRequest) Execute() (InlineResponse20076, *_nethttp.Response, error) {
	return r.ApiService.LendingPurchaseFlexibleProductExecute(r)
}

/*
LendingPurchaseFlexibleProduct Purchase Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingPurchaseFlexibleProductRequest
*/
func (a *SavingsApiService) LendingPurchaseFlexibleProduct(ctx _context.Context) ApiLendingPurchaseFlexibleProductRequest {
	return ApiLendingPurchaseFlexibleProductRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20076
func (a *SavingsApiService) LendingPurchaseFlexibleProductExecute(r ApiLendingPurchaseFlexibleProductRequest) (InlineResponse20076, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20076
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingPurchaseFlexibleProduct")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/purchase"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLendingRedeemFlexibleProductRequest struct {
	ctx        _context.Context
	ApiService *SavingsApiService
	productId  *string
	amount     *float64
	type_      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiLendingRedeemFlexibleProductRequest) ProductId(productId string) ApiLendingRedeemFlexibleProductRequest {
	r.productId = &productId
	return r
}
func (r ApiLendingRedeemFlexibleProductRequest) Amount(amount float64) ApiLendingRedeemFlexibleProductRequest {
	r.amount = &amount
	return r
}

// \&quot;FAST\&quot;, \&quot;NORMAL\&quot;
func (r ApiLendingRedeemFlexibleProductRequest) Type_(type_ string) ApiLendingRedeemFlexibleProductRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiLendingRedeemFlexibleProductRequest) Timestamp(timestamp int64) ApiLendingRedeemFlexibleProductRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiLendingRedeemFlexibleProductRequest) Signature(signature string) ApiLendingRedeemFlexibleProductRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiLendingRedeemFlexibleProductRequest) RecvWindow(recvWindow int64) ApiLendingRedeemFlexibleProductRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiLendingRedeemFlexibleProductRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.LendingRedeemFlexibleProductExecute(r)
}

/*
LendingRedeemFlexibleProduct Redeem Flexible Product (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLendingRedeemFlexibleProductRequest
*/
func (a *SavingsApiService) LendingRedeemFlexibleProduct(ctx _context.Context) ApiLendingRedeemFlexibleProductRequest {
	return ApiLendingRedeemFlexibleProductRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *SavingsApiService) LendingRedeemFlexibleProductExecute(r ApiLendingRedeemFlexibleProductRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SavingsApiService.LendingRedeemFlexibleProduct")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/lending/daily/redeem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.productId == nil {
		return localVarReturnValue, nil, reportError("productId is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("productId", parameterToString(*r.productId, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
