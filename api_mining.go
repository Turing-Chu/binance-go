/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API generated with [binance/binance-api-swagger/blob/master/spot_api.yaml](https://github.com/binance/binance-api-swagger/blob/master/spot_api.yaml) with commit [v1.2.0 release](https://github.com/binance/binance-api-swagger/commit/60d14be031c031600c853d5cdab86db5ab73603e)  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
Contact: qishiwenjun@163.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// MiningApiService MiningApi service
type MiningApiService service

type ApiBlvtGetTokenInRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	algo       *string
	userName   *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiBlvtGetTokenInRequest) Algo(algo string) ApiBlvtGetTokenInRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiBlvtGetTokenInRequest) UserName(userName string) ApiBlvtGetTokenInRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiBlvtGetTokenInRequest) Timestamp(timestamp int64) ApiBlvtGetTokenInRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBlvtGetTokenInRequest) Signature(signature string) ApiBlvtGetTokenInRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiBlvtGetTokenInRequest) RecvWindow(recvWindow int64) ApiBlvtGetTokenInRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBlvtGetTokenInRequest) Execute() (InlineResponse20095, *_nethttp.Response, error) {
	return r.ApiService.BlvtGetTokenInExecute(r)
}

/*
BlvtGetTokenIn Statistic List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBlvtGetTokenInRequest
*/
func (a *MiningApiService) BlvtGetTokenIn(ctx _context.Context) ApiBlvtGetTokenInRequest {
	return ApiBlvtGetTokenInRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20095
func (a *MiningApiService) BlvtGetTokenInExecute(r ApiBlvtGetTokenInRequest) (InlineResponse20095, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20095
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.BlvtGetTokenIn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/statistics/user/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningCancelHashrateResaleConfigRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	configId   *string
	userName   *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Mining ID
func (r ApiMiningCancelHashrateResaleConfigRequest) ConfigId(configId string) ApiMiningCancelHashrateResaleConfigRequest {
	r.configId = &configId
	return r
}

// Mining Account
func (r ApiMiningCancelHashrateResaleConfigRequest) UserName(userName string) ApiMiningCancelHashrateResaleConfigRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiMiningCancelHashrateResaleConfigRequest) Timestamp(timestamp int64) ApiMiningCancelHashrateResaleConfigRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningCancelHashrateResaleConfigRequest) Signature(signature string) ApiMiningCancelHashrateResaleConfigRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningCancelHashrateResaleConfigRequest) RecvWindow(recvWindow int64) ApiMiningCancelHashrateResaleConfigRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningCancelHashrateResaleConfigRequest) Execute() (InlineResponse20094, *_nethttp.Response, error) {
	return r.ApiService.MiningCancelHashrateResaleConfigExecute(r)
}

/*
MiningCancelHashrateResaleConfig Cancel Hashrate Resale configuration (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningCancelHashrateResaleConfigRequest
*/
func (a *MiningApiService) MiningCancelHashrateResaleConfig(ctx _context.Context) ApiMiningCancelHashrateResaleConfigRequest {
	return ApiMiningCancelHashrateResaleConfigRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20094
func (a *MiningApiService) MiningCancelHashrateResaleConfigExecute(r ApiMiningCancelHashrateResaleConfigRequest) (InlineResponse20094, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20094
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningCancelHashrateResaleConfig")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("configId", parameterToString(*r.configId, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetAccountsRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	algo       *string
	userName   *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiMiningGetAccountsRequest) Algo(algo string) ApiMiningGetAccountsRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiMiningGetAccountsRequest) UserName(userName string) ApiMiningGetAccountsRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiMiningGetAccountsRequest) Timestamp(timestamp int64) ApiMiningGetAccountsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetAccountsRequest) Signature(signature string) ApiMiningGetAccountsRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetAccountsRequest) RecvWindow(recvWindow int64) ApiMiningGetAccountsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetAccountsRequest) Execute() (InlineResponse20096, *_nethttp.Response, error) {
	return r.ApiService.MiningGetAccountsExecute(r)
}

/*
MiningGetAccounts Account List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetAccountsRequest
*/
func (a *MiningApiService) MiningGetAccounts(ctx _context.Context) ApiMiningGetAccountsRequest {
	return ApiMiningGetAccountsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20096
func (a *MiningApiService) MiningGetAccountsExecute(r ApiMiningGetAccountsRequest) (InlineResponse20096, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20096
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetAccounts")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/statistics/user/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetAlgorithmsRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMiningGetAlgorithmsRequest) Timestamp(timestamp int64) ApiMiningGetAlgorithmsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetAlgorithmsRequest) Signature(signature string) ApiMiningGetAlgorithmsRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetAlgorithmsRequest) RecvWindow(recvWindow int64) ApiMiningGetAlgorithmsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetAlgorithmsRequest) Execute() (InlineResponse20085, *_nethttp.Response, error) {
	return r.ApiService.MiningGetAlgorithmsExecute(r)
}

/*
MiningGetAlgorithms Acquiring Algorithm (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetAlgorithmsRequest
*/
func (a *MiningApiService) MiningGetAlgorithms(ctx _context.Context) ApiMiningGetAlgorithmsRequest {
	return ApiMiningGetAlgorithmsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20085
func (a *MiningApiService) MiningGetAlgorithmsExecute(r ApiMiningGetAlgorithmsRequest) (InlineResponse20085, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20085
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetAlgorithms")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/pub/algoList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetCoinsRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMiningGetCoinsRequest) Timestamp(timestamp int64) ApiMiningGetCoinsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetCoinsRequest) Signature(signature string) ApiMiningGetCoinsRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetCoinsRequest) RecvWindow(recvWindow int64) ApiMiningGetCoinsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetCoinsRequest) Execute() (InlineResponse20086, *_nethttp.Response, error) {
	return r.ApiService.MiningGetCoinsExecute(r)
}

/*
MiningGetCoins Acquiring CoinName (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetCoinsRequest
*/
func (a *MiningApiService) MiningGetCoins(ctx _context.Context) ApiMiningGetCoinsRequest {
	return ApiMiningGetCoinsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20086
func (a *MiningApiService) MiningGetCoinsExecute(r ApiMiningGetCoinsRequest) (InlineResponse20086, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20086
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetCoins")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/pub/coinList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetEarningsRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	algo       *string
	userName   *string
	timestamp  *int64
	signature  *string
	coin       *string
	startDate  *string
	endDate    *string
	pageIndex  *int32
	pageSize   *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiMiningGetEarningsRequest) Algo(algo string) ApiMiningGetEarningsRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiMiningGetEarningsRequest) UserName(userName string) ApiMiningGetEarningsRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiMiningGetEarningsRequest) Timestamp(timestamp int64) ApiMiningGetEarningsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetEarningsRequest) Signature(signature string) ApiMiningGetEarningsRequest {
	r.signature = &signature
	return r
}

// Coin name
func (r ApiMiningGetEarningsRequest) Coin(coin string) ApiMiningGetEarningsRequest {
	r.coin = &coin
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiMiningGetEarningsRequest) StartDate(startDate string) ApiMiningGetEarningsRequest {
	r.startDate = &startDate
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiMiningGetEarningsRequest) EndDate(endDate string) ApiMiningGetEarningsRequest {
	r.endDate = &endDate
	return r
}

// Page number, default is first page, start form 1
func (r ApiMiningGetEarningsRequest) PageIndex(pageIndex int32) ApiMiningGetEarningsRequest {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiMiningGetEarningsRequest) PageSize(pageSize string) ApiMiningGetEarningsRequest {
	r.pageSize = &pageSize
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetEarningsRequest) RecvWindow(recvWindow int64) ApiMiningGetEarningsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetEarningsRequest) Execute() (InlineResponse20089, *_nethttp.Response, error) {
	return r.ApiService.MiningGetEarningsExecute(r)
}

/*
MiningGetEarnings Earnings List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetEarningsRequest
*/
func (a *MiningApiService) MiningGetEarnings(ctx _context.Context) ApiMiningGetEarningsRequest {
	return ApiMiningGetEarningsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20089
func (a *MiningApiService) MiningGetEarningsExecute(r ApiMiningGetEarningsRequest) (InlineResponse20089, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20089
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetEarnings")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetHashrateResaleDetaiRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	configId   *string
	userName   *string
	timestamp  *int64
	signature  *string
	pageIndex  *int32
	pageSize   *string
	recvWindow *int64
}

// Mining ID
func (r ApiMiningGetHashrateResaleDetaiRequest) ConfigId(configId string) ApiMiningGetHashrateResaleDetaiRequest {
	r.configId = &configId
	return r
}

// Mining Account
func (r ApiMiningGetHashrateResaleDetaiRequest) UserName(userName string) ApiMiningGetHashrateResaleDetaiRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiMiningGetHashrateResaleDetaiRequest) Timestamp(timestamp int64) ApiMiningGetHashrateResaleDetaiRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetHashrateResaleDetaiRequest) Signature(signature string) ApiMiningGetHashrateResaleDetaiRequest {
	r.signature = &signature
	return r
}

// Page number, default is first page, start form 1
func (r ApiMiningGetHashrateResaleDetaiRequest) PageIndex(pageIndex int32) ApiMiningGetHashrateResaleDetaiRequest {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiMiningGetHashrateResaleDetaiRequest) PageSize(pageSize string) ApiMiningGetHashrateResaleDetaiRequest {
	r.pageSize = &pageSize
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetHashrateResaleDetaiRequest) RecvWindow(recvWindow int64) ApiMiningGetHashrateResaleDetaiRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetHashrateResaleDetaiRequest) Execute() (InlineResponse20092, *_nethttp.Response, error) {
	return r.ApiService.MiningGetHashrateResaleDetaiExecute(r)
}

/*
MiningGetHashrateResaleDetai Hashrate Resale Details (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetHashrateResaleDetaiRequest
*/
func (a *MiningApiService) MiningGetHashrateResaleDetai(ctx _context.Context) ApiMiningGetHashrateResaleDetaiRequest {
	return ApiMiningGetHashrateResaleDetaiRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20092
func (a *MiningApiService) MiningGetHashrateResaleDetaiExecute(r ApiMiningGetHashrateResaleDetaiRequest) (InlineResponse20092, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20092
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetHashrateResaleDetai")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/profit/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("configId", parameterToString(*r.configId, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetOtherPaymentRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	algo       *string
	userName   *string
	timestamp  *int64
	signature  *string
	coin       *string
	startDate  *string
	endDate    *string
	pageIndex  *int32
	pageSize   *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiMiningGetOtherPaymentRequest) Algo(algo string) ApiMiningGetOtherPaymentRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiMiningGetOtherPaymentRequest) UserName(userName string) ApiMiningGetOtherPaymentRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiMiningGetOtherPaymentRequest) Timestamp(timestamp int64) ApiMiningGetOtherPaymentRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetOtherPaymentRequest) Signature(signature string) ApiMiningGetOtherPaymentRequest {
	r.signature = &signature
	return r
}

// Coin name
func (r ApiMiningGetOtherPaymentRequest) Coin(coin string) ApiMiningGetOtherPaymentRequest {
	r.coin = &coin
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiMiningGetOtherPaymentRequest) StartDate(startDate string) ApiMiningGetOtherPaymentRequest {
	r.startDate = &startDate
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiMiningGetOtherPaymentRequest) EndDate(endDate string) ApiMiningGetOtherPaymentRequest {
	r.endDate = &endDate
	return r
}

// Page number, default is first page, start form 1
func (r ApiMiningGetOtherPaymentRequest) PageIndex(pageIndex int32) ApiMiningGetOtherPaymentRequest {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiMiningGetOtherPaymentRequest) PageSize(pageSize string) ApiMiningGetOtherPaymentRequest {
	r.pageSize = &pageSize
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetOtherPaymentRequest) RecvWindow(recvWindow int64) ApiMiningGetOtherPaymentRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetOtherPaymentRequest) Execute() (InlineResponse20090, *_nethttp.Response, error) {
	return r.ApiService.MiningGetOtherPaymentExecute(r)
}

/*
MiningGetOtherPayment Extra Bonus List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetOtherPaymentRequest
*/
func (a *MiningApiService) MiningGetOtherPayment(ctx _context.Context) ApiMiningGetOtherPaymentRequest {
	return ApiMiningGetOtherPaymentRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20090
func (a *MiningApiService) MiningGetOtherPaymentExecute(r ApiMiningGetOtherPaymentRequest) (InlineResponse20090, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20090
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetOtherPayment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/other"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetWorkerDetailRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	algo       *string
	userName   *string
	workerName *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiMiningGetWorkerDetailRequest) Algo(algo string) ApiMiningGetWorkerDetailRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiMiningGetWorkerDetailRequest) UserName(userName string) ApiMiningGetWorkerDetailRequest {
	r.userName = &userName
	return r
}

// Miner’s name
func (r ApiMiningGetWorkerDetailRequest) WorkerName(workerName string) ApiMiningGetWorkerDetailRequest {
	r.workerName = &workerName
	return r
}

// UTC timestamp in ms
func (r ApiMiningGetWorkerDetailRequest) Timestamp(timestamp int64) ApiMiningGetWorkerDetailRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetWorkerDetailRequest) Signature(signature string) ApiMiningGetWorkerDetailRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetWorkerDetailRequest) RecvWindow(recvWindow int64) ApiMiningGetWorkerDetailRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetWorkerDetailRequest) Execute() (InlineResponse20087, *_nethttp.Response, error) {
	return r.ApiService.MiningGetWorkerDetailExecute(r)
}

/*
MiningGetWorkerDetail Request for Detail Miner List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetWorkerDetailRequest
*/
func (a *MiningApiService) MiningGetWorkerDetail(ctx _context.Context) ApiMiningGetWorkerDetailRequest {
	return ApiMiningGetWorkerDetailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20087
func (a *MiningApiService) MiningGetWorkerDetailExecute(r ApiMiningGetWorkerDetailRequest) (InlineResponse20087, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20087
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetWorkerDetail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/worker/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.workerName == nil {
		return localVarReturnValue, nil, reportError("workerName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	localVarQueryParams.Add("workerName", parameterToString(*r.workerName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningGetWorkersRequest struct {
	ctx          _context.Context
	ApiService   *MiningApiService
	algo         *string
	userName     *string
	timestamp    *int64
	signature    *string
	pageIndex    *int32
	sort         *int32
	sortColumn   *int32
	workerStatus *int32
	recvWindow   *int64
}

// Algorithm(sha256)
func (r ApiMiningGetWorkersRequest) Algo(algo string) ApiMiningGetWorkersRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiMiningGetWorkersRequest) UserName(userName string) ApiMiningGetWorkersRequest {
	r.userName = &userName
	return r
}

// UTC timestamp in ms
func (r ApiMiningGetWorkersRequest) Timestamp(timestamp int64) ApiMiningGetWorkersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningGetWorkersRequest) Signature(signature string) ApiMiningGetWorkersRequest {
	r.signature = &signature
	return r
}

// Page number, default is first page, start form 1
func (r ApiMiningGetWorkersRequest) PageIndex(pageIndex int32) ApiMiningGetWorkersRequest {
	r.pageIndex = &pageIndex
	return r
}

// sort sequence（default&#x3D;0）0 positive sequence, 1 negative sequence
func (r ApiMiningGetWorkersRequest) Sort(sort int32) ApiMiningGetWorkersRequest {
	r.sort = &sort
	return r
}

// Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
func (r ApiMiningGetWorkersRequest) SortColumn(sortColumn int32) ApiMiningGetWorkersRequest {
	r.sortColumn = &sortColumn
	return r
}

// miners status（default&#x3D;0）0 all, 1 valid, 2 invalid, 3 failure
func (r ApiMiningGetWorkersRequest) WorkerStatus(workerStatus int32) ApiMiningGetWorkersRequest {
	r.workerStatus = &workerStatus
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningGetWorkersRequest) RecvWindow(recvWindow int64) ApiMiningGetWorkersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningGetWorkersRequest) Execute() (InlineResponse20088, *_nethttp.Response, error) {
	return r.ApiService.MiningGetWorkersExecute(r)
}

/*
MiningGetWorkers Request for Miner List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningGetWorkersRequest
*/
func (a *MiningApiService) MiningGetWorkers(ctx _context.Context) ApiMiningGetWorkersRequest {
	return ApiMiningGetWorkersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20088
func (a *MiningApiService) MiningGetWorkersExecute(r ApiMiningGetWorkersRequest) (InlineResponse20088, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20088
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningGetWorkers")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/worker/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.sortColumn != nil {
		localVarQueryParams.Add("sortColumn", parameterToString(*r.sortColumn, ""))
	}
	if r.workerStatus != nil {
		localVarQueryParams.Add("workerStatus", parameterToString(*r.workerStatus, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningListHashrateResaleRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	timestamp  *int64
	signature  *string
	pageIndex  *int32
	pageSize   *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMiningListHashrateResaleRequest) Timestamp(timestamp int64) ApiMiningListHashrateResaleRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningListHashrateResaleRequest) Signature(signature string) ApiMiningListHashrateResaleRequest {
	r.signature = &signature
	return r
}

// Page number, default is first page, start form 1
func (r ApiMiningListHashrateResaleRequest) PageIndex(pageIndex int32) ApiMiningListHashrateResaleRequest {
	r.pageIndex = &pageIndex
	return r
}

// Number of pages, minimum 10, maximum 200
func (r ApiMiningListHashrateResaleRequest) PageSize(pageSize string) ApiMiningListHashrateResaleRequest {
	r.pageSize = &pageSize
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningListHashrateResaleRequest) RecvWindow(recvWindow int64) ApiMiningListHashrateResaleRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningListHashrateResaleRequest) Execute() (InlineResponse20091, *_nethttp.Response, error) {
	return r.ApiService.MiningListHashrateResaleExecute(r)
}

/*
MiningListHashrateResale Hashrate Resale List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningListHashrateResaleRequest
*/
func (a *MiningApiService) MiningListHashrateResale(ctx _context.Context) ApiMiningListHashrateResaleRequest {
	return ApiMiningListHashrateResaleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20091
func (a *MiningApiService) MiningListHashrateResaleExecute(r ApiMiningListHashrateResaleRequest) (InlineResponse20091, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20091
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningListHashrateResale")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config/details/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMiningRequestHashrateResaleRequest struct {
	ctx        _context.Context
	ApiService *MiningApiService
	userName   *string
	algo       *string
	toPoolUser *string
	hashRate   *string
	timestamp  *int64
	signature  *string
	startDate  *string
	endDate    *string
	recvWindow *int64
}

// Mining Account
func (r ApiMiningRequestHashrateResaleRequest) UserName(userName string) ApiMiningRequestHashrateResaleRequest {
	r.userName = &userName
	return r
}

// Algorithm(sha256)
func (r ApiMiningRequestHashrateResaleRequest) Algo(algo string) ApiMiningRequestHashrateResaleRequest {
	r.algo = &algo
	return r
}

// Mining Account
func (r ApiMiningRequestHashrateResaleRequest) ToPoolUser(toPoolUser string) ApiMiningRequestHashrateResaleRequest {
	r.toPoolUser = &toPoolUser
	return r
}

// Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
func (r ApiMiningRequestHashrateResaleRequest) HashRate(hashRate string) ApiMiningRequestHashrateResaleRequest {
	r.hashRate = &hashRate
	return r
}

// UTC timestamp in ms
func (r ApiMiningRequestHashrateResaleRequest) Timestamp(timestamp int64) ApiMiningRequestHashrateResaleRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMiningRequestHashrateResaleRequest) Signature(signature string) ApiMiningRequestHashrateResaleRequest {
	r.signature = &signature
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiMiningRequestHashrateResaleRequest) StartDate(startDate string) ApiMiningRequestHashrateResaleRequest {
	r.startDate = &startDate
	return r
}

// Search date, millisecond timestamp, while empty query all
func (r ApiMiningRequestHashrateResaleRequest) EndDate(endDate string) ApiMiningRequestHashrateResaleRequest {
	r.endDate = &endDate
	return r
}

// The value cannot be greater than 60000
func (r ApiMiningRequestHashrateResaleRequest) RecvWindow(recvWindow int64) ApiMiningRequestHashrateResaleRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMiningRequestHashrateResaleRequest) Execute() (InlineResponse20093, *_nethttp.Response, error) {
	return r.ApiService.MiningRequestHashrateResaleExecute(r)
}

/*
MiningRequestHashrateResale Hashrate Resale Request (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMiningRequestHashrateResaleRequest
*/
func (a *MiningApiService) MiningRequestHashrateResale(ctx _context.Context) ApiMiningRequestHashrateResaleRequest {
	return ApiMiningRequestHashrateResaleRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20093
func (a *MiningApiService) MiningRequestHashrateResaleExecute(r ApiMiningRequestHashrateResaleRequest) (InlineResponse20093, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20093
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.MiningRequestHashrateResale")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.toPoolUser == nil {
		return localVarReturnValue, nil, reportError("toPoolUser is required and must be specified")
	}
	if r.hashRate == nil {
		return localVarReturnValue, nil, reportError("hashRate is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	localVarQueryParams.Add("toPoolUser", parameterToString(*r.toPoolUser, ""))
	localVarQueryParams.Add("hashRate", parameterToString(*r.hashRate, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
