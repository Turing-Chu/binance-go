/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// MiningApiService MiningApi service
type MiningApiService service

type ApiSapiV1MiningHashTransferConfigCancelPostRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	configId *string
	userName *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Mining ID
func (r ApiSapiV1MiningHashTransferConfigCancelPostRequest) ConfigId(configId string) ApiSapiV1MiningHashTransferConfigCancelPostRequest {
	r.configId = &configId
	return r
}
// Mining Account
func (r ApiSapiV1MiningHashTransferConfigCancelPostRequest) UserName(userName string) ApiSapiV1MiningHashTransferConfigCancelPostRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningHashTransferConfigCancelPostRequest) Timestamp(timestamp int64) ApiSapiV1MiningHashTransferConfigCancelPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningHashTransferConfigCancelPostRequest) Signature(signature string) ApiSapiV1MiningHashTransferConfigCancelPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningHashTransferConfigCancelPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningHashTransferConfigCancelPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningHashTransferConfigCancelPostRequest) Execute() (InlineResponse20094, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningHashTransferConfigCancelPostExecute(r)
}

/*
SapiV1MiningHashTransferConfigCancelPost Cancel Hashrate Resale configuration (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningHashTransferConfigCancelPostRequest
*/
func (a *MiningApiService) SapiV1MiningHashTransferConfigCancelPost(ctx _context.Context) ApiSapiV1MiningHashTransferConfigCancelPostRequest {
	return ApiSapiV1MiningHashTransferConfigCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20094
func (a *MiningApiService) SapiV1MiningHashTransferConfigCancelPostExecute(r ApiSapiV1MiningHashTransferConfigCancelPostRequest) (InlineResponse20094, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20094
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningHashTransferConfigCancelPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("configId", parameterToString(*r.configId, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningHashTransferConfigDetailsListGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	timestamp *int64
	signature *string
	pageIndex *int32
	pageSize *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningHashTransferConfigDetailsListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) Signature(signature string) ApiSapiV1MiningHashTransferConfigDetailsListGetRequest {
	r.signature = &signature
	return r
}
// Page number, default is first page, start form 1
func (r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) PageIndex(pageIndex int32) ApiSapiV1MiningHashTransferConfigDetailsListGetRequest {
	r.pageIndex = &pageIndex
	return r
}
// Number of pages, minimum 10, maximum 200
func (r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) PageSize(pageSize string) ApiSapiV1MiningHashTransferConfigDetailsListGetRequest {
	r.pageSize = &pageSize
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningHashTransferConfigDetailsListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) Execute() (InlineResponse20091, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningHashTransferConfigDetailsListGetExecute(r)
}

/*
SapiV1MiningHashTransferConfigDetailsListGet Hashrate Resale List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningHashTransferConfigDetailsListGetRequest
*/
func (a *MiningApiService) SapiV1MiningHashTransferConfigDetailsListGet(ctx _context.Context) ApiSapiV1MiningHashTransferConfigDetailsListGetRequest {
	return ApiSapiV1MiningHashTransferConfigDetailsListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20091
func (a *MiningApiService) SapiV1MiningHashTransferConfigDetailsListGetExecute(r ApiSapiV1MiningHashTransferConfigDetailsListGetRequest) (InlineResponse20091, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20091
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningHashTransferConfigDetailsListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config/details/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningHashTransferConfigPostRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	userName *string
	algo *string
	toPoolUser *string
	hashRate *string
	timestamp *int64
	signature *string
	startDate *string
	endDate *string
	recvWindow *int64
}

// Mining Account
func (r ApiSapiV1MiningHashTransferConfigPostRequest) UserName(userName string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.userName = &userName
	return r
}
// Algorithm(sha256)
func (r ApiSapiV1MiningHashTransferConfigPostRequest) Algo(algo string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningHashTransferConfigPostRequest) ToPoolUser(toPoolUser string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.toPoolUser = &toPoolUser
	return r
}
// Resale hashrate h/s must be transferred (BTC is greater than 500000000000 ETH is greater than 500000)
func (r ApiSapiV1MiningHashTransferConfigPostRequest) HashRate(hashRate string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.hashRate = &hashRate
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningHashTransferConfigPostRequest) Timestamp(timestamp int64) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningHashTransferConfigPostRequest) Signature(signature string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.signature = &signature
	return r
}
// Search date, millisecond timestamp, while empty query all
func (r ApiSapiV1MiningHashTransferConfigPostRequest) StartDate(startDate string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.startDate = &startDate
	return r
}
// Search date, millisecond timestamp, while empty query all
func (r ApiSapiV1MiningHashTransferConfigPostRequest) EndDate(endDate string) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.endDate = &endDate
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningHashTransferConfigPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningHashTransferConfigPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningHashTransferConfigPostRequest) Execute() (InlineResponse20093, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningHashTransferConfigPostExecute(r)
}

/*
SapiV1MiningHashTransferConfigPost Hashrate Resale Request (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningHashTransferConfigPostRequest
*/
func (a *MiningApiService) SapiV1MiningHashTransferConfigPost(ctx _context.Context) ApiSapiV1MiningHashTransferConfigPostRequest {
	return ApiSapiV1MiningHashTransferConfigPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20093
func (a *MiningApiService) SapiV1MiningHashTransferConfigPostExecute(r ApiSapiV1MiningHashTransferConfigPostRequest) (InlineResponse20093, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20093
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningHashTransferConfigPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.toPoolUser == nil {
		return localVarReturnValue, nil, reportError("toPoolUser is required and must be specified")
	}
	if r.hashRate == nil {
		return localVarReturnValue, nil, reportError("hashRate is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	localVarQueryParams.Add("toPoolUser", parameterToString(*r.toPoolUser, ""))
	localVarQueryParams.Add("hashRate", parameterToString(*r.hashRate, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningHashTransferProfitDetailsGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	configId *string
	userName *string
	timestamp *int64
	signature *string
	pageIndex *int32
	pageSize *string
	recvWindow *int64
}

// Mining ID
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) ConfigId(configId string) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.configId = &configId
	return r
}
// Mining Account
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) UserName(userName string) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) Signature(signature string) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.signature = &signature
	return r
}
// Page number, default is first page, start form 1
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) PageIndex(pageIndex int32) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.pageIndex = &pageIndex
	return r
}
// Number of pages, minimum 10, maximum 200
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) PageSize(pageSize string) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.pageSize = &pageSize
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) Execute() (InlineResponse20092, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningHashTransferProfitDetailsGetExecute(r)
}

/*
SapiV1MiningHashTransferProfitDetailsGet Hashrate Resale Details (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningHashTransferProfitDetailsGetRequest
*/
func (a *MiningApiService) SapiV1MiningHashTransferProfitDetailsGet(ctx _context.Context) ApiSapiV1MiningHashTransferProfitDetailsGetRequest {
	return ApiSapiV1MiningHashTransferProfitDetailsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20092
func (a *MiningApiService) SapiV1MiningHashTransferProfitDetailsGetExecute(r ApiSapiV1MiningHashTransferProfitDetailsGetRequest) (InlineResponse20092, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20092
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningHashTransferProfitDetailsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/hash-transfer/profit/details"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.configId == nil {
		return localVarReturnValue, nil, reportError("configId is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("configId", parameterToString(*r.configId, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningPaymentListGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	algo *string
	userName *string
	timestamp *int64
	signature *string
	coin *string
	startDate *string
	endDate *string
	pageIndex *int32
	pageSize *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiSapiV1MiningPaymentListGetRequest) Algo(algo string) ApiSapiV1MiningPaymentListGetRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningPaymentListGetRequest) UserName(userName string) ApiSapiV1MiningPaymentListGetRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningPaymentListGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningPaymentListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningPaymentListGetRequest) Signature(signature string) ApiSapiV1MiningPaymentListGetRequest {
	r.signature = &signature
	return r
}
// Coin name
func (r ApiSapiV1MiningPaymentListGetRequest) Coin(coin string) ApiSapiV1MiningPaymentListGetRequest {
	r.coin = &coin
	return r
}
// Search date, millisecond timestamp, while empty query all
func (r ApiSapiV1MiningPaymentListGetRequest) StartDate(startDate string) ApiSapiV1MiningPaymentListGetRequest {
	r.startDate = &startDate
	return r
}
// Search date, millisecond timestamp, while empty query all
func (r ApiSapiV1MiningPaymentListGetRequest) EndDate(endDate string) ApiSapiV1MiningPaymentListGetRequest {
	r.endDate = &endDate
	return r
}
// Page number, default is first page, start form 1
func (r ApiSapiV1MiningPaymentListGetRequest) PageIndex(pageIndex int32) ApiSapiV1MiningPaymentListGetRequest {
	r.pageIndex = &pageIndex
	return r
}
// Number of pages, minimum 10, maximum 200
func (r ApiSapiV1MiningPaymentListGetRequest) PageSize(pageSize string) ApiSapiV1MiningPaymentListGetRequest {
	r.pageSize = &pageSize
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningPaymentListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningPaymentListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningPaymentListGetRequest) Execute() (InlineResponse20089, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningPaymentListGetExecute(r)
}

/*
SapiV1MiningPaymentListGet Earnings List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningPaymentListGetRequest
*/
func (a *MiningApiService) SapiV1MiningPaymentListGet(ctx _context.Context) ApiSapiV1MiningPaymentListGetRequest {
	return ApiSapiV1MiningPaymentListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20089
func (a *MiningApiService) SapiV1MiningPaymentListGetExecute(r ApiSapiV1MiningPaymentListGetRequest) (InlineResponse20089, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20089
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningPaymentListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningPaymentOtherGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	algo *string
	userName *string
	timestamp *int64
	signature *string
	coin *string
	startDate *string
	endDate *string
	pageIndex *int32
	pageSize *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiSapiV1MiningPaymentOtherGetRequest) Algo(algo string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningPaymentOtherGetRequest) UserName(userName string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningPaymentOtherGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningPaymentOtherGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningPaymentOtherGetRequest) Signature(signature string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.signature = &signature
	return r
}
// Coin name
func (r ApiSapiV1MiningPaymentOtherGetRequest) Coin(coin string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.coin = &coin
	return r
}
// Search date, millisecond timestamp, while empty query all
func (r ApiSapiV1MiningPaymentOtherGetRequest) StartDate(startDate string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.startDate = &startDate
	return r
}
// Search date, millisecond timestamp, while empty query all
func (r ApiSapiV1MiningPaymentOtherGetRequest) EndDate(endDate string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.endDate = &endDate
	return r
}
// Page number, default is first page, start form 1
func (r ApiSapiV1MiningPaymentOtherGetRequest) PageIndex(pageIndex int32) ApiSapiV1MiningPaymentOtherGetRequest {
	r.pageIndex = &pageIndex
	return r
}
// Number of pages, minimum 10, maximum 200
func (r ApiSapiV1MiningPaymentOtherGetRequest) PageSize(pageSize string) ApiSapiV1MiningPaymentOtherGetRequest {
	r.pageSize = &pageSize
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningPaymentOtherGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningPaymentOtherGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningPaymentOtherGetRequest) Execute() (InlineResponse20090, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningPaymentOtherGetExecute(r)
}

/*
SapiV1MiningPaymentOtherGet Extra Bonus List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningPaymentOtherGetRequest
*/
func (a *MiningApiService) SapiV1MiningPaymentOtherGet(ctx _context.Context) ApiSapiV1MiningPaymentOtherGetRequest {
	return ApiSapiV1MiningPaymentOtherGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20090
func (a *MiningApiService) SapiV1MiningPaymentOtherGetExecute(r ApiSapiV1MiningPaymentOtherGetRequest) (InlineResponse20090, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20090
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningPaymentOtherGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/payment/other"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.startDate != nil {
		localVarQueryParams.Add("startDate", parameterToString(*r.startDate, ""))
	}
	if r.endDate != nil {
		localVarQueryParams.Add("endDate", parameterToString(*r.endDate, ""))
	}
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningPubAlgoListGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MiningPubAlgoListGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningPubAlgoListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningPubAlgoListGetRequest) Signature(signature string) ApiSapiV1MiningPubAlgoListGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningPubAlgoListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningPubAlgoListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningPubAlgoListGetRequest) Execute() (InlineResponse20085, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningPubAlgoListGetExecute(r)
}

/*
SapiV1MiningPubAlgoListGet Acquiring Algorithm (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningPubAlgoListGetRequest
*/
func (a *MiningApiService) SapiV1MiningPubAlgoListGet(ctx _context.Context) ApiSapiV1MiningPubAlgoListGetRequest {
	return ApiSapiV1MiningPubAlgoListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20085
func (a *MiningApiService) SapiV1MiningPubAlgoListGetExecute(r ApiSapiV1MiningPubAlgoListGetRequest) (InlineResponse20085, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20085
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningPubAlgoListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/pub/algoList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningPubCoinListGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MiningPubCoinListGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningPubCoinListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningPubCoinListGetRequest) Signature(signature string) ApiSapiV1MiningPubCoinListGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningPubCoinListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningPubCoinListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningPubCoinListGetRequest) Execute() (InlineResponse20086, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningPubCoinListGetExecute(r)
}

/*
SapiV1MiningPubCoinListGet Acquiring CoinName (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningPubCoinListGetRequest
*/
func (a *MiningApiService) SapiV1MiningPubCoinListGet(ctx _context.Context) ApiSapiV1MiningPubCoinListGetRequest {
	return ApiSapiV1MiningPubCoinListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20086
func (a *MiningApiService) SapiV1MiningPubCoinListGetExecute(r ApiSapiV1MiningPubCoinListGetRequest) (InlineResponse20086, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20086
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningPubCoinListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/pub/coinList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningStatisticsUserListGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	algo *string
	userName *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiSapiV1MiningStatisticsUserListGetRequest) Algo(algo string) ApiSapiV1MiningStatisticsUserListGetRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningStatisticsUserListGetRequest) UserName(userName string) ApiSapiV1MiningStatisticsUserListGetRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningStatisticsUserListGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningStatisticsUserListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningStatisticsUserListGetRequest) Signature(signature string) ApiSapiV1MiningStatisticsUserListGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningStatisticsUserListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningStatisticsUserListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningStatisticsUserListGetRequest) Execute() (InlineResponse20096, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningStatisticsUserListGetExecute(r)
}

/*
SapiV1MiningStatisticsUserListGet Account List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningStatisticsUserListGetRequest
*/
func (a *MiningApiService) SapiV1MiningStatisticsUserListGet(ctx _context.Context) ApiSapiV1MiningStatisticsUserListGetRequest {
	return ApiSapiV1MiningStatisticsUserListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20096
func (a *MiningApiService) SapiV1MiningStatisticsUserListGetExecute(r ApiSapiV1MiningStatisticsUserListGetRequest) (InlineResponse20096, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20096
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningStatisticsUserListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/statistics/user/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningStatisticsUserStatusGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	algo *string
	userName *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiSapiV1MiningStatisticsUserStatusGetRequest) Algo(algo string) ApiSapiV1MiningStatisticsUserStatusGetRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningStatisticsUserStatusGetRequest) UserName(userName string) ApiSapiV1MiningStatisticsUserStatusGetRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningStatisticsUserStatusGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningStatisticsUserStatusGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningStatisticsUserStatusGetRequest) Signature(signature string) ApiSapiV1MiningStatisticsUserStatusGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningStatisticsUserStatusGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningStatisticsUserStatusGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningStatisticsUserStatusGetRequest) Execute() (InlineResponse20095, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningStatisticsUserStatusGetExecute(r)
}

/*
SapiV1MiningStatisticsUserStatusGet Statistic List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningStatisticsUserStatusGetRequest
*/
func (a *MiningApiService) SapiV1MiningStatisticsUserStatusGet(ctx _context.Context) ApiSapiV1MiningStatisticsUserStatusGetRequest {
	return ApiSapiV1MiningStatisticsUserStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20095
func (a *MiningApiService) SapiV1MiningStatisticsUserStatusGetExecute(r ApiSapiV1MiningStatisticsUserStatusGetRequest) (InlineResponse20095, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20095
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningStatisticsUserStatusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/statistics/user/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningWorkerDetailGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	algo *string
	userName *string
	workerName *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiSapiV1MiningWorkerDetailGetRequest) Algo(algo string) ApiSapiV1MiningWorkerDetailGetRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningWorkerDetailGetRequest) UserName(userName string) ApiSapiV1MiningWorkerDetailGetRequest {
	r.userName = &userName
	return r
}
// Miner’s name
func (r ApiSapiV1MiningWorkerDetailGetRequest) WorkerName(workerName string) ApiSapiV1MiningWorkerDetailGetRequest {
	r.workerName = &workerName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningWorkerDetailGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningWorkerDetailGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningWorkerDetailGetRequest) Signature(signature string) ApiSapiV1MiningWorkerDetailGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningWorkerDetailGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningWorkerDetailGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningWorkerDetailGetRequest) Execute() (InlineResponse20087, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningWorkerDetailGetExecute(r)
}

/*
SapiV1MiningWorkerDetailGet Request for Detail Miner List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningWorkerDetailGetRequest
*/
func (a *MiningApiService) SapiV1MiningWorkerDetailGet(ctx _context.Context) ApiSapiV1MiningWorkerDetailGetRequest {
	return ApiSapiV1MiningWorkerDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20087
func (a *MiningApiService) SapiV1MiningWorkerDetailGetExecute(r ApiSapiV1MiningWorkerDetailGetRequest) (InlineResponse20087, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20087
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningWorkerDetailGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/worker/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.workerName == nil {
		return localVarReturnValue, nil, reportError("workerName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	localVarQueryParams.Add("workerName", parameterToString(*r.workerName, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MiningWorkerListGetRequest struct {
	ctx _context.Context
	ApiService *MiningApiService
	algo *string
	userName *string
	timestamp *int64
	signature *string
	pageIndex *int32
	sort *int32
	sortColumn *int32
	workerStatus *int32
	recvWindow *int64
}

// Algorithm(sha256)
func (r ApiSapiV1MiningWorkerListGetRequest) Algo(algo string) ApiSapiV1MiningWorkerListGetRequest {
	r.algo = &algo
	return r
}
// Mining Account
func (r ApiSapiV1MiningWorkerListGetRequest) UserName(userName string) ApiSapiV1MiningWorkerListGetRequest {
	r.userName = &userName
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MiningWorkerListGetRequest) Timestamp(timestamp int64) ApiSapiV1MiningWorkerListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MiningWorkerListGetRequest) Signature(signature string) ApiSapiV1MiningWorkerListGetRequest {
	r.signature = &signature
	return r
}
// Page number, default is first page, start form 1
func (r ApiSapiV1MiningWorkerListGetRequest) PageIndex(pageIndex int32) ApiSapiV1MiningWorkerListGetRequest {
	r.pageIndex = &pageIndex
	return r
}
// sort sequence（default&#x3D;0）0 positive sequence, 1 negative sequence
func (r ApiSapiV1MiningWorkerListGetRequest) Sort(sort int32) ApiSapiV1MiningWorkerListGetRequest {
	r.sort = &sort
	return r
}
// Sort by( default 1): 1: miner name, 2: real-time computing power, 3: daily average computing power, 4: real-time rejection rate, 5: last submission time
func (r ApiSapiV1MiningWorkerListGetRequest) SortColumn(sortColumn int32) ApiSapiV1MiningWorkerListGetRequest {
	r.sortColumn = &sortColumn
	return r
}
// miners status（default&#x3D;0）0 all, 1 valid, 2 invalid, 3 failure
func (r ApiSapiV1MiningWorkerListGetRequest) WorkerStatus(workerStatus int32) ApiSapiV1MiningWorkerListGetRequest {
	r.workerStatus = &workerStatus
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MiningWorkerListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MiningWorkerListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MiningWorkerListGetRequest) Execute() (InlineResponse20088, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MiningWorkerListGetExecute(r)
}

/*
SapiV1MiningWorkerListGet Request for Miner List (USER_DATA)

Weight(IP): 5

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MiningWorkerListGetRequest
*/
func (a *MiningApiService) SapiV1MiningWorkerListGet(ctx _context.Context) ApiSapiV1MiningWorkerListGetRequest {
	return ApiSapiV1MiningWorkerListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20088
func (a *MiningApiService) SapiV1MiningWorkerListGetExecute(r ApiSapiV1MiningWorkerListGetRequest) (InlineResponse20088, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20088
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MiningApiService.SapiV1MiningWorkerListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/mining/worker/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.algo == nil {
		return localVarReturnValue, nil, reportError("algo is required and must be specified")
	}
	if r.userName == nil {
		return localVarReturnValue, nil, reportError("userName is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("algo", parameterToString(*r.algo, ""))
	localVarQueryParams.Add("userName", parameterToString(*r.userName, ""))
	if r.pageIndex != nil {
		localVarQueryParams.Add("pageIndex", parameterToString(*r.pageIndex, ""))
	}
	if r.sort != nil {
		localVarQueryParams.Add("sort", parameterToString(*r.sort, ""))
	}
	if r.sortColumn != nil {
		localVarQueryParams.Add("sortColumn", parameterToString(*r.sortColumn, ""))
	}
	if r.workerStatus != nil {
		localVarQueryParams.Add("workerStatus", parameterToString(*r.workerStatus, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
