/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// MarginApiService MarginApi service
type MarginApiService service

type ApiSapiV1BnbBurnGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1BnbBurnGetRequest) Timestamp(timestamp int64) ApiSapiV1BnbBurnGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BnbBurnGetRequest) Signature(signature string) ApiSapiV1BnbBurnGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BnbBurnGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BnbBurnGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BnbBurnGetRequest) Execute() (BnbBurnStatus, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BnbBurnGetExecute(r)
}

/*
SapiV1BnbBurnGet Get All Isolated Margin Symbol(USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BnbBurnGetRequest
*/
func (a *MarginApiService) SapiV1BnbBurnGet(ctx _context.Context) ApiSapiV1BnbBurnGetRequest {
	return ApiSapiV1BnbBurnGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BnbBurnStatus
func (a *MarginApiService) SapiV1BnbBurnGetExecute(r ApiSapiV1BnbBurnGetRequest) (BnbBurnStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BnbBurnStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1BnbBurnGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BnbBurnPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	spotBNBBurn *string
	interestBNBBurn *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1BnbBurnPostRequest) Timestamp(timestamp int64) ApiSapiV1BnbBurnPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BnbBurnPostRequest) Signature(signature string) ApiSapiV1BnbBurnPostRequest {
	r.signature = &signature
	return r
}
// Determines whether to use BNB to pay for trading fees on SPOT
func (r ApiSapiV1BnbBurnPostRequest) SpotBNBBurn(spotBNBBurn string) ApiSapiV1BnbBurnPostRequest {
	r.spotBNBBurn = &spotBNBBurn
	return r
}
// Determines whether to use BNB to pay for margin loan&#39;s interest
func (r ApiSapiV1BnbBurnPostRequest) InterestBNBBurn(interestBNBBurn string) ApiSapiV1BnbBurnPostRequest {
	r.interestBNBBurn = &interestBNBBurn
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BnbBurnPostRequest) RecvWindow(recvWindow int64) ApiSapiV1BnbBurnPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BnbBurnPostRequest) Execute() (BnbBurnStatus, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BnbBurnPostExecute(r)
}

/*
SapiV1BnbBurnPost Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)

- "spotBNBBurn" and "interestBNBBurn" should be sent at least one.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BnbBurnPostRequest
*/
func (a *MarginApiService) SapiV1BnbBurnPost(ctx _context.Context) ApiSapiV1BnbBurnPostRequest {
	return ApiSapiV1BnbBurnPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BnbBurnStatus
func (a *MarginApiService) SapiV1BnbBurnPostExecute(r ApiSapiV1BnbBurnPostRequest) (BnbBurnStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BnbBurnStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1BnbBurnPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.spotBNBBurn != nil {
		localVarQueryParams.Add("spotBNBBurn", parameterToString(*r.spotBNBBurn, ""))
	}
	if r.interestBNBBurn != nil {
		localVarQueryParams.Add("interestBNBBurn", parameterToString(*r.interestBNBBurn, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAccountGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginAccountGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginAccountGetRequest) Signature(signature string) ApiSapiV1MarginAccountGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginAccountGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginAccountGetRequest) Execute() (InlineResponse20019, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAccountGetExecute(r)
}

/*
SapiV1MarginAccountGet Query Cross Margin Account Details (USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginAccountGetRequest
*/
func (a *MarginApiService) SapiV1MarginAccountGet(ctx _context.Context) ApiSapiV1MarginAccountGetRequest {
	return ApiSapiV1MarginAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20019
func (a *MarginApiService) SapiV1MarginAccountGetExecute(r ApiSapiV1MarginAccountGetRequest) (InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20019
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllAssetsGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
}


func (r ApiSapiV1MarginAllAssetsGetRequest) Execute() ([]InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllAssetsGetExecute(r)
}

/*
SapiV1MarginAllAssetsGet Get All Margin Assets (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginAllAssetsGetRequest
*/
func (a *MarginApiService) SapiV1MarginAllAssetsGet(ctx _context.Context) ApiSapiV1MarginAllAssetsGetRequest {
	return ApiSapiV1MarginAllAssetsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20014
func (a *MarginApiService) SapiV1MarginAllAssetsGetExecute(r ApiSapiV1MarginAllAssetsGetRequest) ([]InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllAssetsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allAssets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllOrderListGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	isIsolated *string
	symbol *string
	fromId *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginAllOrderListGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginAllOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginAllOrderListGetRequest) Signature(signature string) ApiSapiV1MarginAllOrderListGetRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginAllOrderListGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginAllOrderListGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// Mandatory for isolated margin, not supported for cross margin
func (r ApiSapiV1MarginAllOrderListGetRequest) Symbol(symbol string) ApiSapiV1MarginAllOrderListGetRequest {
	r.symbol = &symbol
	return r
}
// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r ApiSapiV1MarginAllOrderListGetRequest) FromId(fromId string) ApiSapiV1MarginAllOrderListGetRequest {
	r.fromId = &fromId
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginAllOrderListGetRequest) StartTime(startTime int64) ApiSapiV1MarginAllOrderListGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginAllOrderListGetRequest) EndTime(endTime int64) ApiSapiV1MarginAllOrderListGetRequest {
	r.endTime = &endTime
	return r
}
// Default Value: 500; Max Value: 1000
func (r ApiSapiV1MarginAllOrderListGetRequest) Limit(limit int32) ApiSapiV1MarginAllOrderListGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginAllOrderListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginAllOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginAllOrderListGetRequest) Execute() ([]InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllOrderListGetExecute(r)
}

/*
SapiV1MarginAllOrderListGet Query Margin Account's all OCO (USER_DATA)

Retrieves all OCO for a specific margin account based on provided optional parameters

Weight(IP): 200

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginAllOrderListGetRequest
*/
func (a *MarginApiService) SapiV1MarginAllOrderListGet(ctx _context.Context) ApiSapiV1MarginAllOrderListGetRequest {
	return ApiSapiV1MarginAllOrderListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2006
func (a *MarginApiService) SapiV1MarginAllOrderListGetExecute(r ApiSapiV1MarginAllOrderListGetRequest) ([]InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllOrdersGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	isIsolated *string
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginAllOrdersGetRequest) Symbol(symbol string) ApiSapiV1MarginAllOrdersGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginAllOrdersGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginAllOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginAllOrdersGetRequest) Signature(signature string) ApiSapiV1MarginAllOrdersGetRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginAllOrdersGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginAllOrdersGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// Order id
func (r ApiSapiV1MarginAllOrdersGetRequest) OrderId(orderId int64) ApiSapiV1MarginAllOrdersGetRequest {
	r.orderId = &orderId
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginAllOrdersGetRequest) StartTime(startTime int64) ApiSapiV1MarginAllOrdersGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginAllOrdersGetRequest) EndTime(endTime int64) ApiSapiV1MarginAllOrdersGetRequest {
	r.endTime = &endTime
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1MarginAllOrdersGetRequest) Limit(limit int32) ApiSapiV1MarginAllOrdersGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginAllOrdersGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginAllOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginAllOrdersGetRequest) Execute() ([]MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllOrdersGetExecute(r)
}

/*
SapiV1MarginAllOrdersGet Query Margin Account's All Orders (USER_DATA)

- If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 200

Request Limit: 60 times/min per IP

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginAllOrdersGetRequest
*/
func (a *MarginApiService) SapiV1MarginAllOrdersGet(ctx _context.Context) ApiSapiV1MarginAllOrdersGetRequest {
	return ApiSapiV1MarginAllOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginOrderDetail
func (a *MarginApiService) SapiV1MarginAllOrdersGetExecute(r ApiSapiV1MarginAllOrdersGetRequest) ([]MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAllPairsGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
}


func (r ApiSapiV1MarginAllPairsGetRequest) Execute() ([]InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAllPairsGetExecute(r)
}

/*
SapiV1MarginAllPairsGet Get All Cross Margin Pairs (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginAllPairsGetRequest
*/
func (a *MarginApiService) SapiV1MarginAllPairsGet(ctx _context.Context) ApiSapiV1MarginAllPairsGetRequest {
	return ApiSapiV1MarginAllPairsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20015
func (a *MarginApiService) SapiV1MarginAllPairsGetExecute(r ApiSapiV1MarginAllPairsGetRequest) ([]InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAllPairsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allPairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginAssetGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
}

func (r ApiSapiV1MarginAssetGetRequest) Asset(asset string) ApiSapiV1MarginAssetGetRequest {
	r.asset = &asset
	return r
}

func (r ApiSapiV1MarginAssetGetRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginAssetGetExecute(r)
}

/*
SapiV1MarginAssetGet Query Margin Asset (MARKET_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginAssetGetRequest
*/
func (a *MarginApiService) SapiV1MarginAssetGet(ctx _context.Context) ApiSapiV1MarginAssetGetRequest {
	return ApiSapiV1MarginAssetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20012
func (a *MarginApiService) SapiV1MarginAssetGetExecute(r ApiSapiV1MarginAssetGetRequest) (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginAssetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginForceLiquidationRecGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	startTime *int64
	endTime *int64
	isolatedSymbol *string
	current *int32
	size *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Signature(signature string) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.signature = &signature
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) StartTime(startTime int64) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) EndTime(endTime int64) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.endTime = &endTime
	return r
}
// Isolated symbol
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) IsolatedSymbol(isolatedSymbol string) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Current(current int32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Size(size int32) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginForceLiquidationRecGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginForceLiquidationRecGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginForceLiquidationRecGetRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginForceLiquidationRecGetExecute(r)
}

/*
SapiV1MarginForceLiquidationRecGet Get Force Liquidation Record (USER_DATA)

- Response in descending order

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginForceLiquidationRecGetRequest
*/
func (a *MarginApiService) SapiV1MarginForceLiquidationRecGet(ctx _context.Context) ApiSapiV1MarginForceLiquidationRecGetRequest {
	return ApiSapiV1MarginForceLiquidationRecGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20018
func (a *MarginApiService) SapiV1MarginForceLiquidationRecGetExecute(r ApiSapiV1MarginForceLiquidationRecGetRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginForceLiquidationRecGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/forceLiquidationRec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginInterestHistoryGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	asset *string
	isolatedSymbol *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	archived *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginInterestHistoryGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginInterestHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginInterestHistoryGetRequest) Signature(signature string) ApiSapiV1MarginInterestHistoryGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1MarginInterestHistoryGetRequest) Asset(asset string) ApiSapiV1MarginInterestHistoryGetRequest {
	r.asset = &asset
	return r
}
// Isolated symbol
func (r ApiSapiV1MarginInterestHistoryGetRequest) IsolatedSymbol(isolatedSymbol string) ApiSapiV1MarginInterestHistoryGetRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginInterestHistoryGetRequest) StartTime(startTime int64) ApiSapiV1MarginInterestHistoryGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginInterestHistoryGetRequest) EndTime(endTime int64) ApiSapiV1MarginInterestHistoryGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1MarginInterestHistoryGetRequest) Current(current int32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1MarginInterestHistoryGetRequest) Size(size int32) ApiSapiV1MarginInterestHistoryGetRequest {
	r.size = &size
	return r
}
// Default: false. Set to true for archived data from 6 months ago
func (r ApiSapiV1MarginInterestHistoryGetRequest) Archived(archived string) ApiSapiV1MarginInterestHistoryGetRequest {
	r.archived = &archived
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginInterestHistoryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginInterestHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginInterestHistoryGetRequest) Execute() (InlineResponse20017, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginInterestHistoryGetExecute(r)
}

/*
SapiV1MarginInterestHistoryGet Get Interest History (USER_DATA)

- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago
- `type` in response has 4 enums:
  - `PERIODIC` interest charged per hour
  - `ON_BORROW` first interest charged on borrow
  - `PERIODIC_CONVERTED` interest charged per hour converted into BNB
  - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginInterestHistoryGetRequest
*/
func (a *MarginApiService) SapiV1MarginInterestHistoryGet(ctx _context.Context) ApiSapiV1MarginInterestHistoryGetRequest {
	return ApiSapiV1MarginInterestHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20017
func (a *MarginApiService) SapiV1MarginInterestHistoryGetExecute(r ApiSapiV1MarginInterestHistoryGetRequest) (InlineResponse20017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginInterestHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/interestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginInterestRateHistoryGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	timestamp *int64
	signature *string
	vipLevel *int32
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiSapiV1MarginInterestRateHistoryGetRequest) Asset(asset string) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) Signature(signature string) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.signature = &signature
	return r
}
// Defaults to user&#39;s vip level
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) VipLevel(vipLevel int32) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.vipLevel = &vipLevel
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) StartTime(startTime int64) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) EndTime(endTime int64) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.endTime = &endTime
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) Limit(limit int32) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginInterestRateHistoryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginInterestRateHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginInterestRateHistoryGetRequest) Execute() ([]InlineResponse20028, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginInterestRateHistoryGetExecute(r)
}

/*
SapiV1MarginInterestRateHistoryGet Margin Interest Rate History (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginInterestRateHistoryGetRequest
*/
func (a *MarginApiService) SapiV1MarginInterestRateHistoryGet(ctx _context.Context) ApiSapiV1MarginInterestRateHistoryGetRequest {
	return ApiSapiV1MarginInterestRateHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20028
func (a *MarginApiService) SapiV1MarginInterestRateHistoryGetExecute(r ApiSapiV1MarginInterestRateHistoryGetRequest) ([]InlineResponse20028, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20028
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginInterestRateHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/interestRateHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.vipLevel != nil {
		localVarQueryParams.Add("vipLevel", parameterToString(*r.vipLevel, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedAccountDeleteRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginIsolatedAccountDeleteRequest) Symbol(symbol string) ApiSapiV1MarginIsolatedAccountDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedAccountDeleteRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedAccountDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedAccountDeleteRequest) Signature(signature string) ApiSapiV1MarginIsolatedAccountDeleteRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedAccountDeleteRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedAccountDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedAccountDeleteRequest) Execute() (InlineResponse20025, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedAccountDeleteExecute(r)
}

/*
SapiV1MarginIsolatedAccountDelete Disable Isolated Margin Account (TRADE)

Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .

Weight(UID): 300

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedAccountDeleteRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedAccountDelete(ctx _context.Context) ApiSapiV1MarginIsolatedAccountDeleteRequest {
	return ApiSapiV1MarginIsolatedAccountDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20025
func (a *MarginApiService) SapiV1MarginIsolatedAccountDeleteExecute(r ApiSapiV1MarginIsolatedAccountDeleteRequest) (InlineResponse20025, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20025
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedAccountDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedAccountGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	symbols *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedAccountGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedAccountGetRequest) Signature(signature string) ApiSapiV1MarginIsolatedAccountGetRequest {
	r.signature = &signature
	return r
}
// Max 5 symbols can be sent; separated by &#39;,&#39;
func (r ApiSapiV1MarginIsolatedAccountGetRequest) Symbols(symbols string) ApiSapiV1MarginIsolatedAccountGetRequest {
	r.symbols = &symbols
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedAccountGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedAccountGetRequest) Execute() (IsolatedMarginAccountInfo, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedAccountGetExecute(r)
}

/*
SapiV1MarginIsolatedAccountGet Query Isolated Margin Account Info (USER_DATA)

- If "symbols" is not sent, all isolated assets will be returned.
- If "symbols" is sent, only the isolated assets of the sent symbols will be returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedAccountGetRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedAccountGet(ctx _context.Context) ApiSapiV1MarginIsolatedAccountGetRequest {
	return ApiSapiV1MarginIsolatedAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return IsolatedMarginAccountInfo
func (a *MarginApiService) SapiV1MarginIsolatedAccountGetExecute(r ApiSapiV1MarginIsolatedAccountGetRequest) (IsolatedMarginAccountInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IsolatedMarginAccountInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbols != nil {
		localVarQueryParams.Add("symbols", parameterToString(*r.symbols, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedAccountLimitGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedAccountLimitGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedAccountLimitGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedAccountLimitGetRequest) Signature(signature string) ApiSapiV1MarginIsolatedAccountLimitGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedAccountLimitGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedAccountLimitGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedAccountLimitGetRequest) Execute() (InlineResponse20026, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedAccountLimitGetExecute(r)
}

/*
SapiV1MarginIsolatedAccountLimitGet Query Enabled Isolated Margin Account Limit (USER_DATA)

Query enabled isolated margin account limit.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedAccountLimitGetRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedAccountLimitGet(ctx _context.Context) ApiSapiV1MarginIsolatedAccountLimitGetRequest {
	return ApiSapiV1MarginIsolatedAccountLimitGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20026
func (a *MarginApiService) SapiV1MarginIsolatedAccountLimitGetExecute(r ApiSapiV1MarginIsolatedAccountLimitGetRequest) (InlineResponse20026, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20026
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedAccountLimitGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/accountLimit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedAccountPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginIsolatedAccountPostRequest) Symbol(symbol string) ApiSapiV1MarginIsolatedAccountPostRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedAccountPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedAccountPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedAccountPostRequest) Signature(signature string) ApiSapiV1MarginIsolatedAccountPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedAccountPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedAccountPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedAccountPostRequest) Execute() (InlineResponse20025, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedAccountPostExecute(r)
}

/*
SapiV1MarginIsolatedAccountPost Enable Isolated Margin Account (TRADE)

Enable isolated margin account for a specific symbol.

Weight(UID): 300

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedAccountPostRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedAccountPost(ctx _context.Context) ApiSapiV1MarginIsolatedAccountPostRequest {
	return ApiSapiV1MarginIsolatedAccountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20025
func (a *MarginApiService) SapiV1MarginIsolatedAccountPostExecute(r ApiSapiV1MarginIsolatedAccountPostRequest) (InlineResponse20025, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20025
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedAccountPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedAllPairsGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedAllPairsGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedAllPairsGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedAllPairsGetRequest) Signature(signature string) ApiSapiV1MarginIsolatedAllPairsGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedAllPairsGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedAllPairsGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedAllPairsGetRequest) Execute() ([]InlineResponse20027, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedAllPairsGetExecute(r)
}

/*
SapiV1MarginIsolatedAllPairsGet Get All Isolated Margin Symbol(USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedAllPairsGetRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedAllPairsGet(ctx _context.Context) ApiSapiV1MarginIsolatedAllPairsGetRequest {
	return ApiSapiV1MarginIsolatedAllPairsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20027
func (a *MarginApiService) SapiV1MarginIsolatedAllPairsGetExecute(r ApiSapiV1MarginIsolatedAllPairsGetRequest) ([]InlineResponse20027, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20027
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedAllPairsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/allPairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedPairGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginIsolatedPairGetRequest) Symbol(symbol string) ApiSapiV1MarginIsolatedPairGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedPairGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedPairGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedPairGetRequest) Signature(signature string) ApiSapiV1MarginIsolatedPairGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedPairGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedPairGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedPairGetRequest) Execute() (InlineResponse20027, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedPairGetExecute(r)
}

/*
SapiV1MarginIsolatedPairGet Query Isolated Margin Symbol (USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedPairGetRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedPairGet(ctx _context.Context) ApiSapiV1MarginIsolatedPairGetRequest {
	return ApiSapiV1MarginIsolatedPairGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20027
func (a *MarginApiService) SapiV1MarginIsolatedPairGetExecute(r ApiSapiV1MarginIsolatedPairGetRequest) (InlineResponse20027, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20027
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedPairGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedTransferGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	asset *string
	transFrom *string
	transTo *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginIsolatedTransferGetRequest) Symbol(symbol string) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedTransferGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedTransferGetRequest) Signature(signature string) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1MarginIsolatedTransferGetRequest) Asset(asset string) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginIsolatedTransferGetRequest) TransFrom(transFrom string) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.transFrom = &transFrom
	return r
}
func (r ApiSapiV1MarginIsolatedTransferGetRequest) TransTo(transTo string) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.transTo = &transTo
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedTransferGetRequest) StartTime(startTime int64) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedTransferGetRequest) EndTime(endTime int64) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1MarginIsolatedTransferGetRequest) Current(current int32) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1MarginIsolatedTransferGetRequest) Size(size int32) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedTransferGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedTransferGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedTransferGetRequest) Execute() (MarginTransferDetails, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedTransferGetExecute(r)
}

/*
SapiV1MarginIsolatedTransferGet Get Isolated Margin Transfer History (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedTransferGetRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedTransferGet(ctx _context.Context) ApiSapiV1MarginIsolatedTransferGetRequest {
	return ApiSapiV1MarginIsolatedTransferGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginTransferDetails
func (a *MarginApiService) SapiV1MarginIsolatedTransferGetExecute(r ApiSapiV1MarginIsolatedTransferGetRequest) (MarginTransferDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginTransferDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.transFrom != nil {
		localVarQueryParams.Add("transFrom", parameterToString(*r.transFrom, ""))
	}
	if r.transTo != nil {
		localVarQueryParams.Add("transTo", parameterToString(*r.transTo, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginIsolatedTransferPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	symbol *string
	amount *float64
	timestamp *int64
	signature *string
	transFrom *string
	transTo *string
	recvWindow *int64
}

func (r ApiSapiV1MarginIsolatedTransferPostRequest) Asset(asset string) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.asset = &asset
	return r
}
// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginIsolatedTransferPostRequest) Symbol(symbol string) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.symbol = &symbol
	return r
}
func (r ApiSapiV1MarginIsolatedTransferPostRequest) Amount(amount float64) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginIsolatedTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginIsolatedTransferPostRequest) Signature(signature string) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1MarginIsolatedTransferPostRequest) TransFrom(transFrom string) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.transFrom = &transFrom
	return r
}
func (r ApiSapiV1MarginIsolatedTransferPostRequest) TransTo(transTo string) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.transTo = &transTo
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginIsolatedTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginIsolatedTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginIsolatedTransferPostRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginIsolatedTransferPostExecute(r)
}

/*
SapiV1MarginIsolatedTransferPost Isolated Margin Account Transfer (MARGIN)

Weight(UID): 600

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginIsolatedTransferPostRequest
*/
func (a *MarginApiService) SapiV1MarginIsolatedTransferPost(ctx _context.Context) ApiSapiV1MarginIsolatedTransferPostRequest {
	return ApiSapiV1MarginIsolatedTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MarginApiService) SapiV1MarginIsolatedTransferPostExecute(r ApiSapiV1MarginIsolatedTransferPostRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginIsolatedTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.transFrom != nil {
		localVarQueryParams.Add("transFrom", parameterToString(*r.transFrom, ""))
	}
	if r.transTo != nil {
		localVarQueryParams.Add("transTo", parameterToString(*r.transTo, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginLoanGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	timestamp *int64
	signature *string
	isolatedSymbol *string
	txId *int64
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	archived *string
	recvWindow *int64
}

func (r ApiSapiV1MarginLoanGetRequest) Asset(asset string) ApiSapiV1MarginLoanGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginLoanGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginLoanGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginLoanGetRequest) Signature(signature string) ApiSapiV1MarginLoanGetRequest {
	r.signature = &signature
	return r
}
// Isolated symbol
func (r ApiSapiV1MarginLoanGetRequest) IsolatedSymbol(isolatedSymbol string) ApiSapiV1MarginLoanGetRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}
// the tranId in  &#x60;POST /sapi/v1/margin/loan&#x60;
func (r ApiSapiV1MarginLoanGetRequest) TxId(txId int64) ApiSapiV1MarginLoanGetRequest {
	r.txId = &txId
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginLoanGetRequest) StartTime(startTime int64) ApiSapiV1MarginLoanGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginLoanGetRequest) EndTime(endTime int64) ApiSapiV1MarginLoanGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1MarginLoanGetRequest) Current(current int32) ApiSapiV1MarginLoanGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1MarginLoanGetRequest) Size(size int32) ApiSapiV1MarginLoanGetRequest {
	r.size = &size
	return r
}
// Default: false. Set to true for archived data from 6 months ago
func (r ApiSapiV1MarginLoanGetRequest) Archived(archived string) ApiSapiV1MarginLoanGetRequest {
	r.archived = &archived
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginLoanGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginLoanGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginLoanGetRequest) Execute() (InlineResponse20010, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginLoanGetExecute(r)
}

/*
SapiV1MarginLoanGet Query Loan Record (USER_DATA)

- `txId` or `startTime` must be sent. `txId` takes precedence.
- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginLoanGetRequest
*/
func (a *MarginApiService) SapiV1MarginLoanGet(ctx _context.Context) ApiSapiV1MarginLoanGetRequest {
	return ApiSapiV1MarginLoanGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20010
func (a *MarginApiService) SapiV1MarginLoanGetExecute(r ApiSapiV1MarginLoanGetRequest) (InlineResponse20010, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20010
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginLoanGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.txId != nil {
		localVarQueryParams.Add("txId", parameterToString(*r.txId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginLoanPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	isIsolated *string
	symbol *string
	recvWindow *int64
}

func (r ApiSapiV1MarginLoanPostRequest) Asset(asset string) ApiSapiV1MarginLoanPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginLoanPostRequest) Amount(amount float64) ApiSapiV1MarginLoanPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginLoanPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginLoanPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginLoanPostRequest) Signature(signature string) ApiSapiV1MarginLoanPostRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginLoanPostRequest) IsIsolated(isIsolated string) ApiSapiV1MarginLoanPostRequest {
	r.isIsolated = &isIsolated
	return r
}
// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginLoanPostRequest) Symbol(symbol string) ApiSapiV1MarginLoanPostRequest {
	r.symbol = &symbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginLoanPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginLoanPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginLoanPostRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginLoanPostExecute(r)
}

/*
SapiV1MarginLoanPost Margin Account Borrow (MARGIN)

Apply for a loan.

- If "isIsolated" = "TRUE", "symbol" must be sent
- "isIsolated" = "FALSE" for crossed margin loan

Weight(UID): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginLoanPostRequest
*/
func (a *MarginApiService) SapiV1MarginLoanPost(ctx _context.Context) ApiSapiV1MarginLoanPostRequest {
	return ApiSapiV1MarginLoanPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Transaction
func (a *MarginApiService) SapiV1MarginLoanPostExecute(r ApiSapiV1MarginLoanPostRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginLoanPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginMaxBorrowableGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	timestamp *int64
	signature *string
	isolatedSymbol *string
	recvWindow *int64
}

func (r ApiSapiV1MarginMaxBorrowableGetRequest) Asset(asset string) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginMaxBorrowableGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginMaxBorrowableGetRequest) Signature(signature string) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.signature = &signature
	return r
}
// Isolated symbol
func (r ApiSapiV1MarginMaxBorrowableGetRequest) IsolatedSymbol(isolatedSymbol string) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginMaxBorrowableGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginMaxBorrowableGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginMaxBorrowableGetRequest) Execute() (InlineResponse20023, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginMaxBorrowableGetExecute(r)
}

/*
SapiV1MarginMaxBorrowableGet Query Max Borrow (USER_DATA)

- If `isolatedSymbol` is not sent, crossed margin data will be sent.
- `borrowLimit` is also available from https://www.binance.com/en/margin-fee

Weight(IP): 50

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginMaxBorrowableGetRequest
*/
func (a *MarginApiService) SapiV1MarginMaxBorrowableGet(ctx _context.Context) ApiSapiV1MarginMaxBorrowableGetRequest {
	return ApiSapiV1MarginMaxBorrowableGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20023
func (a *MarginApiService) SapiV1MarginMaxBorrowableGetExecute(r ApiSapiV1MarginMaxBorrowableGetRequest) (InlineResponse20023, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20023
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginMaxBorrowableGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/maxBorrowable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginMaxTransferableGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	timestamp *int64
	signature *string
	isolatedSymbol *string
	recvWindow *int64
}

func (r ApiSapiV1MarginMaxTransferableGetRequest) Asset(asset string) ApiSapiV1MarginMaxTransferableGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginMaxTransferableGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginMaxTransferableGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginMaxTransferableGetRequest) Signature(signature string) ApiSapiV1MarginMaxTransferableGetRequest {
	r.signature = &signature
	return r
}
// Isolated symbol
func (r ApiSapiV1MarginMaxTransferableGetRequest) IsolatedSymbol(isolatedSymbol string) ApiSapiV1MarginMaxTransferableGetRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginMaxTransferableGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginMaxTransferableGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginMaxTransferableGetRequest) Execute() (InlineResponse20024, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginMaxTransferableGetExecute(r)
}

/*
SapiV1MarginMaxTransferableGet Query Max Transfer-Out Amount (USER_DATA)

- If `isolatedSymbol` is not sent, crossed margin data will be sent.

Weight(IP): 50

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginMaxTransferableGetRequest
*/
func (a *MarginApiService) SapiV1MarginMaxTransferableGet(ctx _context.Context) ApiSapiV1MarginMaxTransferableGetRequest {
	return ApiSapiV1MarginMaxTransferableGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20024
func (a *MarginApiService) SapiV1MarginMaxTransferableGetExecute(r ApiSapiV1MarginMaxTransferableGetRequest) (InlineResponse20024, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20024
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginMaxTransferableGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/maxTransferable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginMyTradesGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	isIsolated *string
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginMyTradesGetRequest) Symbol(symbol string) ApiSapiV1MarginMyTradesGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginMyTradesGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginMyTradesGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginMyTradesGetRequest) Signature(signature string) ApiSapiV1MarginMyTradesGetRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginMyTradesGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginMyTradesGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginMyTradesGetRequest) StartTime(startTime int64) ApiSapiV1MarginMyTradesGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginMyTradesGetRequest) EndTime(endTime int64) ApiSapiV1MarginMyTradesGetRequest {
	r.endTime = &endTime
	return r
}
// Trade id to fetch from. Default gets most recent trades.
func (r ApiSapiV1MarginMyTradesGetRequest) FromId(fromId int64) ApiSapiV1MarginMyTradesGetRequest {
	r.fromId = &fromId
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1MarginMyTradesGetRequest) Limit(limit int32) ApiSapiV1MarginMyTradesGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginMyTradesGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginMyTradesGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginMyTradesGetRequest) Execute() ([]MarginTrade, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginMyTradesGetExecute(r)
}

/*
SapiV1MarginMyTradesGet Query Margin Account's Trade List (USER_DATA)

- If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginMyTradesGetRequest
*/
func (a *MarginApiService) SapiV1MarginMyTradesGet(ctx _context.Context) ApiSapiV1MarginMyTradesGetRequest {
	return ApiSapiV1MarginMyTradesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginTrade
func (a *MarginApiService) SapiV1MarginMyTradesGetExecute(r ApiSapiV1MarginMyTradesGetRequest) ([]MarginTrade, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginMyTradesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOpenOrderListGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	isIsolated *string
	symbol *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginOpenOrderListGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginOpenOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOpenOrderListGetRequest) Signature(signature string) ApiSapiV1MarginOpenOrderListGetRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOpenOrderListGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOpenOrderListGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// Mandatory for isolated margin, not supported for cross margin
func (r ApiSapiV1MarginOpenOrderListGetRequest) Symbol(symbol string) ApiSapiV1MarginOpenOrderListGetRequest {
	r.symbol = &symbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOpenOrderListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOpenOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOpenOrderListGetRequest) Execute() ([]InlineResponse20022, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOpenOrderListGetExecute(r)
}

/*
SapiV1MarginOpenOrderListGet Query Margin Account's Open OCO (USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOpenOrderListGetRequest
*/
func (a *MarginApiService) SapiV1MarginOpenOrderListGet(ctx _context.Context) ApiSapiV1MarginOpenOrderListGetRequest {
	return ApiSapiV1MarginOpenOrderListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20022
func (a *MarginApiService) SapiV1MarginOpenOrderListGetExecute(r ApiSapiV1MarginOpenOrderListGetRequest) ([]InlineResponse20022, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20022
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOpenOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOpenOrdersDeleteRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	isIsolated *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOpenOrdersDeleteRequest) Symbol(symbol string) ApiSapiV1MarginOpenOrdersDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginOpenOrdersDeleteRequest) Timestamp(timestamp int64) ApiSapiV1MarginOpenOrdersDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOpenOrdersDeleteRequest) Signature(signature string) ApiSapiV1MarginOpenOrdersDeleteRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOpenOrdersDeleteRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOpenOrdersDeleteRequest {
	r.isIsolated = &isIsolated
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOpenOrdersDeleteRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOpenOrdersDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOpenOrdersDeleteRequest) Execute() ([]AnyOfcanceledMarginOrderDetailmarginOcoOrder, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOpenOrdersDeleteExecute(r)
}

/*
SapiV1MarginOpenOrdersDelete Margin Account Cancel all Open Orders on a Symbol (TRADE)

- Cancels all active orders on a symbol for margin account.
- This includes OCO orders.

Weight(IP): 1


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOpenOrdersDeleteRequest
*/
func (a *MarginApiService) SapiV1MarginOpenOrdersDelete(ctx _context.Context) ApiSapiV1MarginOpenOrdersDeleteRequest {
	return ApiSapiV1MarginOpenOrdersDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AnyOfcanceledMarginOrderDetailmarginOcoOrder
func (a *MarginApiService) SapiV1MarginOpenOrdersDeleteExecute(r ApiSapiV1MarginOpenOrdersDeleteRequest) ([]AnyOfcanceledMarginOrderDetailmarginOcoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AnyOfcanceledMarginOrderDetailmarginOcoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOpenOrdersDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOpenOrdersGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	symbol *string
	isIsolated *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginOpenOrdersGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginOpenOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOpenOrdersGetRequest) Signature(signature string) ApiSapiV1MarginOpenOrdersGetRequest {
	r.signature = &signature
	return r
}
// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOpenOrdersGetRequest) Symbol(symbol string) ApiSapiV1MarginOpenOrdersGetRequest {
	r.symbol = &symbol
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOpenOrdersGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOpenOrdersGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOpenOrdersGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOpenOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOpenOrdersGetRequest) Execute() ([]MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOpenOrdersGetExecute(r)
}

/*
SapiV1MarginOpenOrdersGet Query Margin Account's Open Orders (USER_DATA)

- If the `symbol` is not sent, orders for all symbols will be returned in an array.
- When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange
- If isIsolated ="TRUE", symbol must be sent.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOpenOrdersGetRequest
*/
func (a *MarginApiService) SapiV1MarginOpenOrdersGet(ctx _context.Context) ApiSapiV1MarginOpenOrdersGetRequest {
	return ApiSapiV1MarginOpenOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MarginOrderDetail
func (a *MarginApiService) SapiV1MarginOpenOrdersGetExecute(r ApiSapiV1MarginOpenOrdersGetRequest) ([]MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOpenOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderDeleteRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	isIsolated *string
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOrderDeleteRequest) Symbol(symbol string) ApiSapiV1MarginOrderDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginOrderDeleteRequest) Timestamp(timestamp int64) ApiSapiV1MarginOrderDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOrderDeleteRequest) Signature(signature string) ApiSapiV1MarginOrderDeleteRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOrderDeleteRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOrderDeleteRequest {
	r.isIsolated = &isIsolated
	return r
}
// Order id
func (r ApiSapiV1MarginOrderDeleteRequest) OrderId(orderId int64) ApiSapiV1MarginOrderDeleteRequest {
	r.orderId = &orderId
	return r
}
// Order id from client
func (r ApiSapiV1MarginOrderDeleteRequest) OrigClientOrderId(origClientOrderId string) ApiSapiV1MarginOrderDeleteRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiSapiV1MarginOrderDeleteRequest) NewClientOrderId(newClientOrderId string) ApiSapiV1MarginOrderDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOrderDeleteRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOrderDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOrderDeleteRequest) Execute() (MarginOrder, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderDeleteExecute(r)
}

/*
SapiV1MarginOrderDelete Margin Account Cancel Order (TRADE)

Cancel an active order for margin account.

Either `orderId` or `origClientOrderId` must be sent.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOrderDeleteRequest
*/
func (a *MarginApiService) SapiV1MarginOrderDelete(ctx _context.Context) ApiSapiV1MarginOrderDeleteRequest {
	return ApiSapiV1MarginOrderDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginOrder
func (a *MarginApiService) SapiV1MarginOrderDeleteExecute(r ApiSapiV1MarginOrderDeleteRequest) (MarginOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	isIsolated *string
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOrderGetRequest) Symbol(symbol string) ApiSapiV1MarginOrderGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginOrderGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginOrderGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOrderGetRequest) Signature(signature string) ApiSapiV1MarginOrderGetRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOrderGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOrderGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// Order id
func (r ApiSapiV1MarginOrderGetRequest) OrderId(orderId int64) ApiSapiV1MarginOrderGetRequest {
	r.orderId = &orderId
	return r
}
// Order id from client
func (r ApiSapiV1MarginOrderGetRequest) OrigClientOrderId(origClientOrderId string) ApiSapiV1MarginOrderGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOrderGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOrderGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOrderGetRequest) Execute() (MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderGetExecute(r)
}

/*
SapiV1MarginOrderGet Query Margin Account's Order (USER_DATA)

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOrderGetRequest
*/
func (a *MarginApiService) SapiV1MarginOrderGet(ctx _context.Context) ApiSapiV1MarginOrderGetRequest {
	return ApiSapiV1MarginOrderGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginOrderDetail
func (a *MarginApiService) SapiV1MarginOrderGetExecute(r ApiSapiV1MarginOrderGetRequest) (MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderListDeleteRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	timestamp *int64
	signature *string
	isIsolated *string
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOrderListDeleteRequest) Symbol(symbol string) ApiSapiV1MarginOrderListDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginOrderListDeleteRequest) Timestamp(timestamp int64) ApiSapiV1MarginOrderListDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOrderListDeleteRequest) Signature(signature string) ApiSapiV1MarginOrderListDeleteRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOrderListDeleteRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOrderListDeleteRequest {
	r.isIsolated = &isIsolated
	return r
}
// Order list id
func (r ApiSapiV1MarginOrderListDeleteRequest) OrderListId(orderListId int64) ApiSapiV1MarginOrderListDeleteRequest {
	r.orderListId = &orderListId
	return r
}
// A unique Id for the entire orderList
func (r ApiSapiV1MarginOrderListDeleteRequest) ListClientOrderId(listClientOrderId string) ApiSapiV1MarginOrderListDeleteRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiSapiV1MarginOrderListDeleteRequest) NewClientOrderId(newClientOrderId string) ApiSapiV1MarginOrderListDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOrderListDeleteRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOrderListDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOrderListDeleteRequest) Execute() (MarginOcoOrder, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderListDeleteExecute(r)
}

/*
SapiV1MarginOrderListDelete Margin Account Cancel OCO (TRADE)

Cancel an entire Order List for a margin account

- Canceling an individual leg will cancel the entire OCO
- Either `orderListId` or `listClientOrderId` must be provided

Weight(UID): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOrderListDeleteRequest
*/
func (a *MarginApiService) SapiV1MarginOrderListDelete(ctx _context.Context) ApiSapiV1MarginOrderListDeleteRequest {
	return ApiSapiV1MarginOrderListDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MarginOcoOrder
func (a *MarginApiService) SapiV1MarginOrderListDeleteExecute(r ApiSapiV1MarginOrderListDeleteRequest) (MarginOcoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOcoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderListDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderListGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	isIsolated *string
	symbol *string
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginOrderListGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOrderListGetRequest) Signature(signature string) ApiSapiV1MarginOrderListGetRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOrderListGetRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOrderListGetRequest {
	r.isIsolated = &isIsolated
	return r
}
// Mandatory for isolated margin, not supported for cross margin
func (r ApiSapiV1MarginOrderListGetRequest) Symbol(symbol string) ApiSapiV1MarginOrderListGetRequest {
	r.symbol = &symbol
	return r
}
// Order list id
func (r ApiSapiV1MarginOrderListGetRequest) OrderListId(orderListId int64) ApiSapiV1MarginOrderListGetRequest {
	r.orderListId = &orderListId
	return r
}
// Order id from client
func (r ApiSapiV1MarginOrderListGetRequest) OrigClientOrderId(origClientOrderId string) ApiSapiV1MarginOrderListGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOrderListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOrderListGetRequest) Execute() (InlineResponse20021, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderListGetExecute(r)
}

/*
SapiV1MarginOrderListGet Query Margin Account's OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

- Either `orderListId` or `origClientOrderId` must be provided

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOrderListGetRequest
*/
func (a *MarginApiService) SapiV1MarginOrderListGet(ctx _context.Context) ApiSapiV1MarginOrderListGetRequest {
	return ApiSapiV1MarginOrderListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20021
func (a *MarginApiService) SapiV1MarginOrderListGetExecute(r ApiSapiV1MarginOrderListGetRequest) (InlineResponse20021, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20021
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderOcoPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	side *string
	quantity *float64
	price *float64
	stopPrice *float64
	timestamp *int64
	signature *string
	isIsolated *string
	listClientOrderId *string
	limitClientOrderId *string
	limitIcebergQty *float64
	stopClientOrderId *string
	stopLimitPrice *float64
	stopIcebergQty *float64
	stopLimitTimeInForce *string
	newOrderRespType *string
	sideEffectType *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOrderOcoPostRequest) Symbol(symbol string) ApiSapiV1MarginOrderOcoPostRequest {
	r.symbol = &symbol
	return r
}
// SELL or BUY
func (r ApiSapiV1MarginOrderOcoPostRequest) Side(side string) ApiSapiV1MarginOrderOcoPostRequest {
	r.side = &side
	return r
}
func (r ApiSapiV1MarginOrderOcoPostRequest) Quantity(quantity float64) ApiSapiV1MarginOrderOcoPostRequest {
	r.quantity = &quantity
	return r
}
// Order price
func (r ApiSapiV1MarginOrderOcoPostRequest) Price(price float64) ApiSapiV1MarginOrderOcoPostRequest {
	r.price = &price
	return r
}
func (r ApiSapiV1MarginOrderOcoPostRequest) StopPrice(stopPrice float64) ApiSapiV1MarginOrderOcoPostRequest {
	r.stopPrice = &stopPrice
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginOrderOcoPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginOrderOcoPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOrderOcoPostRequest) Signature(signature string) ApiSapiV1MarginOrderOcoPostRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOrderOcoPostRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOrderOcoPostRequest {
	r.isIsolated = &isIsolated
	return r
}
// A unique Id for the entire orderList
func (r ApiSapiV1MarginOrderOcoPostRequest) ListClientOrderId(listClientOrderId string) ApiSapiV1MarginOrderOcoPostRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}
// A unique Id for the limit order
func (r ApiSapiV1MarginOrderOcoPostRequest) LimitClientOrderId(limitClientOrderId string) ApiSapiV1MarginOrderOcoPostRequest {
	r.limitClientOrderId = &limitClientOrderId
	return r
}
func (r ApiSapiV1MarginOrderOcoPostRequest) LimitIcebergQty(limitIcebergQty float64) ApiSapiV1MarginOrderOcoPostRequest {
	r.limitIcebergQty = &limitIcebergQty
	return r
}
// A unique Id for the stop loss/stop loss limit leg
func (r ApiSapiV1MarginOrderOcoPostRequest) StopClientOrderId(stopClientOrderId string) ApiSapiV1MarginOrderOcoPostRequest {
	r.stopClientOrderId = &stopClientOrderId
	return r
}
// If provided, stopLimitTimeInForce is required.
func (r ApiSapiV1MarginOrderOcoPostRequest) StopLimitPrice(stopLimitPrice float64) ApiSapiV1MarginOrderOcoPostRequest {
	r.stopLimitPrice = &stopLimitPrice
	return r
}
func (r ApiSapiV1MarginOrderOcoPostRequest) StopIcebergQty(stopIcebergQty float64) ApiSapiV1MarginOrderOcoPostRequest {
	r.stopIcebergQty = &stopIcebergQty
	return r
}
func (r ApiSapiV1MarginOrderOcoPostRequest) StopLimitTimeInForce(stopLimitTimeInForce string) ApiSapiV1MarginOrderOcoPostRequest {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}
// Set the response JSON.
func (r ApiSapiV1MarginOrderOcoPostRequest) NewOrderRespType(newOrderRespType string) ApiSapiV1MarginOrderOcoPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
// Default NO_SIDE_EFFECT
func (r ApiSapiV1MarginOrderOcoPostRequest) SideEffectType(sideEffectType string) ApiSapiV1MarginOrderOcoPostRequest {
	r.sideEffectType = &sideEffectType
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOrderOcoPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOrderOcoPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOrderOcoPostRequest) Execute() (InlineResponse20020, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderOcoPostExecute(r)
}

/*
SapiV1MarginOrderOcoPost Margin Account New OCO (TRADE)

Send in a new OCO for a margin account

- Price Restrictions:
  - SELL: Limit Price > Last Price > Stop Price
  - BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
  - Both legs must have the same quantity
  - ICEBERG quantities however do not have to be the same.
- Order Rate Limit
  - OCO counts as 2 orders against the order rate limit.

Weight(UID): 6

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOrderOcoPostRequest
*/
func (a *MarginApiService) SapiV1MarginOrderOcoPost(ctx _context.Context) ApiSapiV1MarginOrderOcoPostRequest {
	return ApiSapiV1MarginOrderOcoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20020
func (a *MarginApiService) SapiV1MarginOrderOcoPostExecute(r ApiSapiV1MarginOrderOcoPostRequest) (InlineResponse20020, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20020
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderOcoPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.limitClientOrderId != nil {
		localVarQueryParams.Add("limitClientOrderId", parameterToString(*r.limitClientOrderId, ""))
	}
	localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	if r.limitIcebergQty != nil {
		localVarQueryParams.Add("limitIcebergQty", parameterToString(*r.limitIcebergQty, ""))
	}
	if r.stopClientOrderId != nil {
		localVarQueryParams.Add("stopClientOrderId", parameterToString(*r.stopClientOrderId, ""))
	}
	localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	if r.stopLimitPrice != nil {
		localVarQueryParams.Add("stopLimitPrice", parameterToString(*r.stopLimitPrice, ""))
	}
	if r.stopIcebergQty != nil {
		localVarQueryParams.Add("stopIcebergQty", parameterToString(*r.stopIcebergQty, ""))
	}
	if r.stopLimitTimeInForce != nil {
		localVarQueryParams.Add("stopLimitTimeInForce", parameterToString(*r.stopLimitTimeInForce, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginOrderPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
	side *string
	type_ *string
	quantity *float64
	timestamp *int64
	signature *string
	isIsolated *string
	quoteOrderQty *float64
	price *float64
	stopPrice *float64
	newClientOrderId *string
	icebergQty *float64
	newOrderRespType *string
	sideEffectType *string
	timeInForce *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginOrderPostRequest) Symbol(symbol string) ApiSapiV1MarginOrderPostRequest {
	r.symbol = &symbol
	return r
}
// SELL or BUY
func (r ApiSapiV1MarginOrderPostRequest) Side(side string) ApiSapiV1MarginOrderPostRequest {
	r.side = &side
	return r
}
// Order type
func (r ApiSapiV1MarginOrderPostRequest) Type_(type_ string) ApiSapiV1MarginOrderPostRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1MarginOrderPostRequest) Quantity(quantity float64) ApiSapiV1MarginOrderPostRequest {
	r.quantity = &quantity
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginOrderPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginOrderPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginOrderPostRequest) Signature(signature string) ApiSapiV1MarginOrderPostRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginOrderPostRequest) IsIsolated(isIsolated string) ApiSapiV1MarginOrderPostRequest {
	r.isIsolated = &isIsolated
	return r
}
// Quote quantity
func (r ApiSapiV1MarginOrderPostRequest) QuoteOrderQty(quoteOrderQty float64) ApiSapiV1MarginOrderPostRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}
// Order price
func (r ApiSapiV1MarginOrderPostRequest) Price(price float64) ApiSapiV1MarginOrderPostRequest {
	r.price = &price
	return r
}
// Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
func (r ApiSapiV1MarginOrderPostRequest) StopPrice(stopPrice float64) ApiSapiV1MarginOrderPostRequest {
	r.stopPrice = &stopPrice
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiSapiV1MarginOrderPostRequest) NewClientOrderId(newClientOrderId string) ApiSapiV1MarginOrderPostRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
func (r ApiSapiV1MarginOrderPostRequest) IcebergQty(icebergQty float64) ApiSapiV1MarginOrderPostRequest {
	r.icebergQty = &icebergQty
	return r
}
// Set the response JSON.
func (r ApiSapiV1MarginOrderPostRequest) NewOrderRespType(newOrderRespType string) ApiSapiV1MarginOrderPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
// Default NO_SIDE_EFFECT
func (r ApiSapiV1MarginOrderPostRequest) SideEffectType(sideEffectType string) ApiSapiV1MarginOrderPostRequest {
	r.sideEffectType = &sideEffectType
	return r
}
// Order time in force
func (r ApiSapiV1MarginOrderPostRequest) TimeInForce(timeInForce string) ApiSapiV1MarginOrderPostRequest {
	r.timeInForce = &timeInForce
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginOrderPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginOrderPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginOrderPostRequest) Execute() (OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginOrderPostExecute(r)
}

/*
SapiV1MarginOrderPost Margin Account New Order (TRADE)

Post a new order for margin account.

Weight(UID): 6

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginOrderPostRequest
*/
func (a *MarginApiService) SapiV1MarginOrderPost(ctx _context.Context) ApiSapiV1MarginOrderPostRequest {
	return ApiSapiV1MarginOrderPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull
func (a *MarginApiService) SapiV1MarginOrderPostExecute(r ApiSapiV1MarginOrderPostRequest) (OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginOrderPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginPairGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginPairGetRequest) Symbol(symbol string) ApiSapiV1MarginPairGetRequest {
	r.symbol = &symbol
	return r
}

func (r ApiSapiV1MarginPairGetRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginPairGetExecute(r)
}

/*
SapiV1MarginPairGet Query Cross Margin Pair (MARKET_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginPairGetRequest
*/
func (a *MarginApiService) SapiV1MarginPairGet(ctx _context.Context) ApiSapiV1MarginPairGetRequest {
	return ApiSapiV1MarginPairGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20013
func (a *MarginApiService) SapiV1MarginPairGetExecute(r ApiSapiV1MarginPairGetRequest) (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginPairGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginPriceIndexGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	symbol *string
}

// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginPriceIndexGetRequest) Symbol(symbol string) ApiSapiV1MarginPriceIndexGetRequest {
	r.symbol = &symbol
	return r
}

func (r ApiSapiV1MarginPriceIndexGetRequest) Execute() (InlineResponse20016, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginPriceIndexGetExecute(r)
}

/*
SapiV1MarginPriceIndexGet Query Margin PriceIndex (MARKET_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginPriceIndexGetRequest
*/
func (a *MarginApiService) SapiV1MarginPriceIndexGet(ctx _context.Context) ApiSapiV1MarginPriceIndexGetRequest {
	return ApiSapiV1MarginPriceIndexGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20016
func (a *MarginApiService) SapiV1MarginPriceIndexGetExecute(r ApiSapiV1MarginPriceIndexGetRequest) (InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginPriceIndexGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/priceIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginRepayGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	timestamp *int64
	signature *string
	isolatedSymbol *string
	txId *int64
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	archived *string
	recvWindow *int64
}

func (r ApiSapiV1MarginRepayGetRequest) Asset(asset string) ApiSapiV1MarginRepayGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginRepayGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginRepayGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginRepayGetRequest) Signature(signature string) ApiSapiV1MarginRepayGetRequest {
	r.signature = &signature
	return r
}
// Isolated symbol
func (r ApiSapiV1MarginRepayGetRequest) IsolatedSymbol(isolatedSymbol string) ApiSapiV1MarginRepayGetRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}
// the tranId in  &#x60;POST /sapi/v1/margin/repay&#x60;
func (r ApiSapiV1MarginRepayGetRequest) TxId(txId int64) ApiSapiV1MarginRepayGetRequest {
	r.txId = &txId
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginRepayGetRequest) StartTime(startTime int64) ApiSapiV1MarginRepayGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginRepayGetRequest) EndTime(endTime int64) ApiSapiV1MarginRepayGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1MarginRepayGetRequest) Current(current int32) ApiSapiV1MarginRepayGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1MarginRepayGetRequest) Size(size int32) ApiSapiV1MarginRepayGetRequest {
	r.size = &size
	return r
}
// Default: false. Set to true for archived data from 6 months ago
func (r ApiSapiV1MarginRepayGetRequest) Archived(archived string) ApiSapiV1MarginRepayGetRequest {
	r.archived = &archived
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginRepayGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginRepayGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginRepayGetRequest) Execute() (InlineResponse20011, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginRepayGetExecute(r)
}

/*
SapiV1MarginRepayGet Query Repay Record (USER_DATA)

- `txId` or `startTime` must be sent. `txId` takes precedence.
- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginRepayGetRequest
*/
func (a *MarginApiService) SapiV1MarginRepayGet(ctx _context.Context) ApiSapiV1MarginRepayGetRequest {
	return ApiSapiV1MarginRepayGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20011
func (a *MarginApiService) SapiV1MarginRepayGetExecute(r ApiSapiV1MarginRepayGetRequest) (InlineResponse20011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginRepayGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.txId != nil {
		localVarQueryParams.Add("txId", parameterToString(*r.txId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginRepayPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	isIsolated *string
	symbol *string
	recvWindow *int64
}

func (r ApiSapiV1MarginRepayPostRequest) Asset(asset string) ApiSapiV1MarginRepayPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginRepayPostRequest) Amount(amount float64) ApiSapiV1MarginRepayPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginRepayPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginRepayPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginRepayPostRequest) Signature(signature string) ApiSapiV1MarginRepayPostRequest {
	r.signature = &signature
	return r
}
// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiSapiV1MarginRepayPostRequest) IsIsolated(isIsolated string) ApiSapiV1MarginRepayPostRequest {
	r.isIsolated = &isIsolated
	return r
}
// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1MarginRepayPostRequest) Symbol(symbol string) ApiSapiV1MarginRepayPostRequest {
	r.symbol = &symbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginRepayPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginRepayPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginRepayPostRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginRepayPostExecute(r)
}

/*
SapiV1MarginRepayPost Margin Account Repay (MARGIN)

Repay loan for margin account.

- If "isIsolated" = "TRUE", "symbol" must be sent
- "isIsolated" = "FALSE" for crossed margin repay

Weight(IP): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginRepayPostRequest
*/
func (a *MarginApiService) SapiV1MarginRepayPost(ctx _context.Context) ApiSapiV1MarginRepayPostRequest {
	return ApiSapiV1MarginRepayPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Transaction
func (a *MarginApiService) SapiV1MarginRepayPostExecute(r ApiSapiV1MarginRepayPostRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginRepayPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginTransferGetRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	timestamp *int64
	signature *string
	asset *string
	type_ *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	archived *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1MarginTransferGetRequest) Timestamp(timestamp int64) ApiSapiV1MarginTransferGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginTransferGetRequest) Signature(signature string) ApiSapiV1MarginTransferGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1MarginTransferGetRequest) Asset(asset string) ApiSapiV1MarginTransferGetRequest {
	r.asset = &asset
	return r
}
// Tranfer Type
func (r ApiSapiV1MarginTransferGetRequest) Type_(type_ string) ApiSapiV1MarginTransferGetRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginTransferGetRequest) StartTime(startTime int64) ApiSapiV1MarginTransferGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginTransferGetRequest) EndTime(endTime int64) ApiSapiV1MarginTransferGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1MarginTransferGetRequest) Current(current int32) ApiSapiV1MarginTransferGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1MarginTransferGetRequest) Size(size int32) ApiSapiV1MarginTransferGetRequest {
	r.size = &size
	return r
}
// Default: false. Set to true for archived data from 6 months ago
func (r ApiSapiV1MarginTransferGetRequest) Archived(archived string) ApiSapiV1MarginTransferGetRequest {
	r.archived = &archived
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginTransferGetRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginTransferGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginTransferGetRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginTransferGetExecute(r)
}

/*
SapiV1MarginTransferGet Get Cross Margin Transfer History (USER_DATA)

- Response in descending order
- Returns data for last 7 days by default
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginTransferGetRequest
*/
func (a *MarginApiService) SapiV1MarginTransferGet(ctx _context.Context) ApiSapiV1MarginTransferGetRequest {
	return ApiSapiV1MarginTransferGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2009
func (a *MarginApiService) SapiV1MarginTransferGetExecute(r ApiSapiV1MarginTransferGetRequest) (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1MarginTransferPostRequest struct {
	ctx _context.Context
	ApiService *MarginApiService
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	type_ *int32
	recvWindow *int64
}

func (r ApiSapiV1MarginTransferPostRequest) Asset(asset string) ApiSapiV1MarginTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1MarginTransferPostRequest) Amount(amount float64) ApiSapiV1MarginTransferPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1MarginTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1MarginTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1MarginTransferPostRequest) Signature(signature string) ApiSapiV1MarginTransferPostRequest {
	r.signature = &signature
	return r
}
// 1 -&gt; transfer from main account to margin account \\ 2 -&gt; transfer from margin account to main account
func (r ApiSapiV1MarginTransferPostRequest) Type_(type_ int32) ApiSapiV1MarginTransferPostRequest {
	r.type_ = &type_
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1MarginTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1MarginTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1MarginTransferPostRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.SapiV1MarginTransferPostExecute(r)
}

/*
SapiV1MarginTransferPost Cross Margin Account Transfer (MARGIN)

Execute transfer between spot account and cross margin account.

Weight(IP): 600

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1MarginTransferPostRequest
*/
func (a *MarginApiService) SapiV1MarginTransferPost(ctx _context.Context) ApiSapiV1MarginTransferPostRequest {
	return ApiSapiV1MarginTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Transaction
func (a *MarginApiService) SapiV1MarginTransferPostExecute(r ApiSapiV1MarginTransferPostRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.SapiV1MarginTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
