/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API generated with [binance/binance-api-swagger/blob/master/spot_api.yaml](https://github.com/binance/binance-api-swagger/blob/master/spot_api.yaml) with commit [v1.2.0 release](https://github.com/binance/binance-api-swagger/commit/60d14be031c031600c853d5cdab86db5ab73603e)  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
Contact: qishiwenjun@163.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// MarginApiService MarginApi service
type MarginApiService service

type ApiEnableBnbBurnRequest struct {
	ctx             _context.Context
	ApiService      *MarginApiService
	timestamp       *int64
	signature       *string
	spotBNBBurn     *string
	interestBNBBurn *string
	recvWindow      *int64
}

// UTC timestamp in ms
func (r ApiEnableBnbBurnRequest) Timestamp(timestamp int64) ApiEnableBnbBurnRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiEnableBnbBurnRequest) Signature(signature string) ApiEnableBnbBurnRequest {
	r.signature = &signature
	return r
}

// Determines whether to use BNB to pay for trading fees on SPOT
func (r ApiEnableBnbBurnRequest) SpotBNBBurn(spotBNBBurn string) ApiEnableBnbBurnRequest {
	r.spotBNBBurn = &spotBNBBurn
	return r
}

// Determines whether to use BNB to pay for margin loan&#39;s interest
func (r ApiEnableBnbBurnRequest) InterestBNBBurn(interestBNBBurn string) ApiEnableBnbBurnRequest {
	r.interestBNBBurn = &interestBNBBurn
	return r
}

// The value cannot be greater than 60000
func (r ApiEnableBnbBurnRequest) RecvWindow(recvWindow int64) ApiEnableBnbBurnRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiEnableBnbBurnRequest) Execute() (BnbBurnStatus, *_nethttp.Response, error) {
	return r.ApiService.EnableBnbBurnExecute(r)
}

/*
EnableBnbBurn Toggle BNB Burn On Spot Trade And Margin Interest (USER_DATA)

- "spotBNBBurn" and "interestBNBBurn" should be sent at least one.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiEnableBnbBurnRequest
*/
func (a *MarginApiService) EnableBnbBurn(ctx _context.Context) ApiEnableBnbBurnRequest {
	return ApiEnableBnbBurnRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BnbBurnStatus
func (a *MarginApiService) EnableBnbBurnExecute(r ApiEnableBnbBurnRequest) (BnbBurnStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BnbBurnStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.EnableBnbBurn")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.spotBNBBurn != nil {
		localVarQueryParams.Add("spotBNBBurn", parameterToString(*r.spotBNBBurn, ""))
	}
	if r.interestBNBBurn != nil {
		localVarQueryParams.Add("interestBNBBurn", parameterToString(*r.interestBNBBurn, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBnbBurnStatusRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiGetBnbBurnStatusRequest) Timestamp(timestamp int64) ApiGetBnbBurnStatusRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetBnbBurnStatusRequest) Signature(signature string) ApiGetBnbBurnStatusRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiGetBnbBurnStatusRequest) RecvWindow(recvWindow int64) ApiGetBnbBurnStatusRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetBnbBurnStatusRequest) Execute() (BnbBurnStatus, *_nethttp.Response, error) {
	return r.ApiService.GetBnbBurnStatusExecute(r)
}

/*
GetBnbBurnStatus Get All Isolated Margin Symbol(USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBnbBurnStatusRequest
*/
func (a *MarginApiService) GetBnbBurnStatus(ctx _context.Context) ApiGetBnbBurnStatusRequest {
	return ApiGetBnbBurnStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return BnbBurnStatus
func (a *MarginApiService) GetBnbBurnStatusExecute(r ApiGetBnbBurnStatusRequest) (BnbBurnStatus, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BnbBurnStatus
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.GetBnbBurnStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bnbBurn"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginAccountRepayRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	asset      *string
	amount     *float64
	timestamp  *int64
	signature  *string
	isIsolated *string
	symbol     *string
	recvWindow *int64
}

func (r ApiMarginAccountRepayRequest) Asset(asset string) ApiMarginAccountRepayRequest {
	r.asset = &asset
	return r
}
func (r ApiMarginAccountRepayRequest) Amount(amount float64) ApiMarginAccountRepayRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiMarginAccountRepayRequest) Timestamp(timestamp int64) ApiMarginAccountRepayRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginAccountRepayRequest) Signature(signature string) ApiMarginAccountRepayRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginAccountRepayRequest) IsIsolated(isIsolated string) ApiMarginAccountRepayRequest {
	r.isIsolated = &isIsolated
	return r
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginAccountRepayRequest) Symbol(symbol string) ApiMarginAccountRepayRequest {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginAccountRepayRequest) RecvWindow(recvWindow int64) ApiMarginAccountRepayRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginAccountRepayRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.MarginAccountRepayExecute(r)
}

/*
MarginAccountRepay Margin Account Repay (MARGIN)

Repay loan for margin account.

- If "isIsolated" = "TRUE", "symbol" must be sent
- "isIsolated" = "FALSE" for crossed margin repay

Weight(IP): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginAccountRepayRequest
*/
func (a *MarginApiService) MarginAccountRepay(ctx _context.Context) ApiMarginAccountRepayRequest {
	return ApiMarginAccountRepayRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Transaction
func (a *MarginApiService) MarginAccountRepayExecute(r ApiMarginAccountRepayRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginAccountRepay")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginApplyLoanRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	asset      *string
	amount     *float64
	timestamp  *int64
	signature  *string
	isIsolated *string
	symbol     *string
	recvWindow *int64
}

func (r ApiMarginApplyLoanRequest) Asset(asset string) ApiMarginApplyLoanRequest {
	r.asset = &asset
	return r
}
func (r ApiMarginApplyLoanRequest) Amount(amount float64) ApiMarginApplyLoanRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiMarginApplyLoanRequest) Timestamp(timestamp int64) ApiMarginApplyLoanRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginApplyLoanRequest) Signature(signature string) ApiMarginApplyLoanRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginApplyLoanRequest) IsIsolated(isIsolated string) ApiMarginApplyLoanRequest {
	r.isIsolated = &isIsolated
	return r
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginApplyLoanRequest) Symbol(symbol string) ApiMarginApplyLoanRequest {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginApplyLoanRequest) RecvWindow(recvWindow int64) ApiMarginApplyLoanRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginApplyLoanRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.MarginApplyLoanExecute(r)
}

/*
MarginApplyLoan Margin Account Borrow (MARGIN)

Apply for a loan.

- If "isIsolated" = "TRUE", "symbol" must be sent
- "isIsolated" = "FALSE" for crossed margin loan

Weight(UID): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginApplyLoanRequest
*/
func (a *MarginApiService) MarginApplyLoan(ctx _context.Context) ApiMarginApplyLoanRequest {
	return ApiMarginApplyLoanRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Transaction
func (a *MarginApiService) MarginApplyLoanExecute(r ApiMarginApplyLoanRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginApplyLoan")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCancelAllSymbolOrdersRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	isIsolated *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginCancelAllSymbolOrdersRequest) Symbol(symbol string) ApiMarginCancelAllSymbolOrdersRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginCancelAllSymbolOrdersRequest) Timestamp(timestamp int64) ApiMarginCancelAllSymbolOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginCancelAllSymbolOrdersRequest) Signature(signature string) ApiMarginCancelAllSymbolOrdersRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginCancelAllSymbolOrdersRequest) IsIsolated(isIsolated string) ApiMarginCancelAllSymbolOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginCancelAllSymbolOrdersRequest) RecvWindow(recvWindow int64) ApiMarginCancelAllSymbolOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCancelAllSymbolOrdersRequest) Execute() ([]AnyOfcanceledMarginOrderDetailmarginOcoOrder, *_nethttp.Response, error) {
	return r.ApiService.MarginCancelAllSymbolOrdersExecute(r)
}

/*
MarginCancelAllSymbolOrders Margin Account Cancel all Open Orders on a Symbol (TRADE)

- Cancels all active orders on a symbol for margin account.
- This includes OCO orders.

Weight(IP): 1


 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCancelAllSymbolOrdersRequest
*/
func (a *MarginApiService) MarginCancelAllSymbolOrders(ctx _context.Context) ApiMarginCancelAllSymbolOrdersRequest {
	return ApiMarginCancelAllSymbolOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []AnyOfcanceledMarginOrderDetailmarginOcoOrder
func (a *MarginApiService) MarginCancelAllSymbolOrdersExecute(r ApiMarginCancelAllSymbolOrdersRequest) ([]AnyOfcanceledMarginOrderDetailmarginOcoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AnyOfcanceledMarginOrderDetailmarginOcoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginCancelAllSymbolOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCancelOcoOrdersRequest struct {
	ctx               _context.Context
	ApiService        *MarginApiService
	symbol            *string
	timestamp         *int64
	signature         *string
	isIsolated        *string
	orderListId       *int64
	listClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginCancelOcoOrdersRequest) Symbol(symbol string) ApiMarginCancelOcoOrdersRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginCancelOcoOrdersRequest) Timestamp(timestamp int64) ApiMarginCancelOcoOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginCancelOcoOrdersRequest) Signature(signature string) ApiMarginCancelOcoOrdersRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginCancelOcoOrdersRequest) IsIsolated(isIsolated string) ApiMarginCancelOcoOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// Order list id
func (r ApiMarginCancelOcoOrdersRequest) OrderListId(orderListId int64) ApiMarginCancelOcoOrdersRequest {
	r.orderListId = &orderListId
	return r
}

// A unique Id for the entire orderList
func (r ApiMarginCancelOcoOrdersRequest) ListClientOrderId(listClientOrderId string) ApiMarginCancelOcoOrdersRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiMarginCancelOcoOrdersRequest) NewClientOrderId(newClientOrderId string) ApiMarginCancelOcoOrdersRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginCancelOcoOrdersRequest) RecvWindow(recvWindow int64) ApiMarginCancelOcoOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCancelOcoOrdersRequest) Execute() (MarginOcoOrder, *_nethttp.Response, error) {
	return r.ApiService.MarginCancelOcoOrdersExecute(r)
}

/*
MarginCancelOcoOrders Margin Account Cancel OCO (TRADE)

Cancel an entire Order List for a margin account

- Canceling an individual leg will cancel the entire OCO
- Either `orderListId` or `listClientOrderId` must be provided

Weight(UID): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCancelOcoOrdersRequest
*/
func (a *MarginApiService) MarginCancelOcoOrders(ctx _context.Context) ApiMarginCancelOcoOrdersRequest {
	return ApiMarginCancelOcoOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MarginOcoOrder
func (a *MarginApiService) MarginCancelOcoOrdersExecute(r ApiMarginCancelOcoOrdersRequest) (MarginOcoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOcoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginCancelOcoOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCancelOrderRequest struct {
	ctx               _context.Context
	ApiService        *MarginApiService
	symbol            *string
	timestamp         *int64
	signature         *string
	isIsolated        *string
	orderId           *int64
	origClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginCancelOrderRequest) Symbol(symbol string) ApiMarginCancelOrderRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginCancelOrderRequest) Timestamp(timestamp int64) ApiMarginCancelOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginCancelOrderRequest) Signature(signature string) ApiMarginCancelOrderRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginCancelOrderRequest) IsIsolated(isIsolated string) ApiMarginCancelOrderRequest {
	r.isIsolated = &isIsolated
	return r
}

// Order id
func (r ApiMarginCancelOrderRequest) OrderId(orderId int64) ApiMarginCancelOrderRequest {
	r.orderId = &orderId
	return r
}

// Order id from client
func (r ApiMarginCancelOrderRequest) OrigClientOrderId(origClientOrderId string) ApiMarginCancelOrderRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiMarginCancelOrderRequest) NewClientOrderId(newClientOrderId string) ApiMarginCancelOrderRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginCancelOrderRequest) RecvWindow(recvWindow int64) ApiMarginCancelOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCancelOrderRequest) Execute() (MarginOrder, *_nethttp.Response, error) {
	return r.ApiService.MarginCancelOrderExecute(r)
}

/*
MarginCancelOrder Margin Account Cancel Order (TRADE)

Cancel an active order for margin account.

Either `orderId` or `origClientOrderId` must be sent.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCancelOrderRequest
*/
func (a *MarginApiService) MarginCancelOrder(ctx _context.Context) ApiMarginCancelOrderRequest {
	return ApiMarginCancelOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MarginOrder
func (a *MarginApiService) MarginCancelOrderExecute(r ApiMarginCancelOrderRequest) (MarginOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginCancelOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateOcoOrderRequest struct {
	ctx                  _context.Context
	ApiService           *MarginApiService
	symbol               *string
	side                 *string
	quantity             *float64
	price                *float64
	stopPrice            *float64
	timestamp            *int64
	signature            *string
	isIsolated           *string
	listClientOrderId    *string
	limitClientOrderId   *string
	limitIcebergQty      *float64
	stopClientOrderId    *string
	stopLimitPrice       *float64
	stopIcebergQty       *float64
	stopLimitTimeInForce *string
	newOrderRespType     *string
	sideEffectType       *string
	recvWindow           *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginCreateOcoOrderRequest) Symbol(symbol string) ApiMarginCreateOcoOrderRequest {
	r.symbol = &symbol
	return r
}

// SELL or BUY
func (r ApiMarginCreateOcoOrderRequest) Side(side string) ApiMarginCreateOcoOrderRequest {
	r.side = &side
	return r
}
func (r ApiMarginCreateOcoOrderRequest) Quantity(quantity float64) ApiMarginCreateOcoOrderRequest {
	r.quantity = &quantity
	return r
}

// Order price
func (r ApiMarginCreateOcoOrderRequest) Price(price float64) ApiMarginCreateOcoOrderRequest {
	r.price = &price
	return r
}
func (r ApiMarginCreateOcoOrderRequest) StopPrice(stopPrice float64) ApiMarginCreateOcoOrderRequest {
	r.stopPrice = &stopPrice
	return r
}

// UTC timestamp in ms
func (r ApiMarginCreateOcoOrderRequest) Timestamp(timestamp int64) ApiMarginCreateOcoOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginCreateOcoOrderRequest) Signature(signature string) ApiMarginCreateOcoOrderRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginCreateOcoOrderRequest) IsIsolated(isIsolated string) ApiMarginCreateOcoOrderRequest {
	r.isIsolated = &isIsolated
	return r
}

// A unique Id for the entire orderList
func (r ApiMarginCreateOcoOrderRequest) ListClientOrderId(listClientOrderId string) ApiMarginCreateOcoOrderRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}

// A unique Id for the limit order
func (r ApiMarginCreateOcoOrderRequest) LimitClientOrderId(limitClientOrderId string) ApiMarginCreateOcoOrderRequest {
	r.limitClientOrderId = &limitClientOrderId
	return r
}
func (r ApiMarginCreateOcoOrderRequest) LimitIcebergQty(limitIcebergQty float64) ApiMarginCreateOcoOrderRequest {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

// A unique Id for the stop loss/stop loss limit leg
func (r ApiMarginCreateOcoOrderRequest) StopClientOrderId(stopClientOrderId string) ApiMarginCreateOcoOrderRequest {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

// If provided, stopLimitTimeInForce is required.
func (r ApiMarginCreateOcoOrderRequest) StopLimitPrice(stopLimitPrice float64) ApiMarginCreateOcoOrderRequest {
	r.stopLimitPrice = &stopLimitPrice
	return r
}
func (r ApiMarginCreateOcoOrderRequest) StopIcebergQty(stopIcebergQty float64) ApiMarginCreateOcoOrderRequest {
	r.stopIcebergQty = &stopIcebergQty
	return r
}
func (r ApiMarginCreateOcoOrderRequest) StopLimitTimeInForce(stopLimitTimeInForce string) ApiMarginCreateOcoOrderRequest {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

// Set the response JSON.
func (r ApiMarginCreateOcoOrderRequest) NewOrderRespType(newOrderRespType string) ApiMarginCreateOcoOrderRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}

// Default NO_SIDE_EFFECT
func (r ApiMarginCreateOcoOrderRequest) SideEffectType(sideEffectType string) ApiMarginCreateOcoOrderRequest {
	r.sideEffectType = &sideEffectType
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginCreateOcoOrderRequest) RecvWindow(recvWindow int64) ApiMarginCreateOcoOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateOcoOrderRequest) Execute() (InlineResponse20020, *_nethttp.Response, error) {
	return r.ApiService.MarginCreateOcoOrderExecute(r)
}

/*
MarginCreateOcoOrder Margin Account New OCO (TRADE)

Send in a new OCO for a margin account

- Price Restrictions:
  - SELL: Limit Price > Last Price > Stop Price
  - BUY: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
  - Both legs must have the same quantity
  - ICEBERG quantities however do not have to be the same.
- Order Rate Limit
  - OCO counts as 2 orders against the order rate limit.

Weight(UID): 6

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateOcoOrderRequest
*/
func (a *MarginApiService) MarginCreateOcoOrder(ctx _context.Context) ApiMarginCreateOcoOrderRequest {
	return ApiMarginCreateOcoOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20020
func (a *MarginApiService) MarginCreateOcoOrderExecute(r ApiMarginCreateOcoOrderRequest) (InlineResponse20020, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20020
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginCreateOcoOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.limitClientOrderId != nil {
		localVarQueryParams.Add("limitClientOrderId", parameterToString(*r.limitClientOrderId, ""))
	}
	localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	if r.limitIcebergQty != nil {
		localVarQueryParams.Add("limitIcebergQty", parameterToString(*r.limitIcebergQty, ""))
	}
	if r.stopClientOrderId != nil {
		localVarQueryParams.Add("stopClientOrderId", parameterToString(*r.stopClientOrderId, ""))
	}
	localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	if r.stopLimitPrice != nil {
		localVarQueryParams.Add("stopLimitPrice", parameterToString(*r.stopLimitPrice, ""))
	}
	if r.stopIcebergQty != nil {
		localVarQueryParams.Add("stopIcebergQty", parameterToString(*r.stopIcebergQty, ""))
	}
	if r.stopLimitTimeInForce != nil {
		localVarQueryParams.Add("stopLimitTimeInForce", parameterToString(*r.stopLimitTimeInForce, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginCreateOrderRequest struct {
	ctx              _context.Context
	ApiService       *MarginApiService
	symbol           *string
	side             *string
	type_            *string
	quantity         *float64
	timestamp        *int64
	signature        *string
	isIsolated       *string
	quoteOrderQty    *float64
	price            *float64
	stopPrice        *float64
	newClientOrderId *string
	icebergQty       *float64
	newOrderRespType *string
	sideEffectType   *string
	timeInForce      *string
	recvWindow       *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginCreateOrderRequest) Symbol(symbol string) ApiMarginCreateOrderRequest {
	r.symbol = &symbol
	return r
}

// SELL or BUY
func (r ApiMarginCreateOrderRequest) Side(side string) ApiMarginCreateOrderRequest {
	r.side = &side
	return r
}

// Order type
func (r ApiMarginCreateOrderRequest) Type_(type_ string) ApiMarginCreateOrderRequest {
	r.type_ = &type_
	return r
}
func (r ApiMarginCreateOrderRequest) Quantity(quantity float64) ApiMarginCreateOrderRequest {
	r.quantity = &quantity
	return r
}

// UTC timestamp in ms
func (r ApiMarginCreateOrderRequest) Timestamp(timestamp int64) ApiMarginCreateOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginCreateOrderRequest) Signature(signature string) ApiMarginCreateOrderRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginCreateOrderRequest) IsIsolated(isIsolated string) ApiMarginCreateOrderRequest {
	r.isIsolated = &isIsolated
	return r
}

// Quote quantity
func (r ApiMarginCreateOrderRequest) QuoteOrderQty(quoteOrderQty float64) ApiMarginCreateOrderRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

// Order price
func (r ApiMarginCreateOrderRequest) Price(price float64) ApiMarginCreateOrderRequest {
	r.price = &price
	return r
}

// Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
func (r ApiMarginCreateOrderRequest) StopPrice(stopPrice float64) ApiMarginCreateOrderRequest {
	r.stopPrice = &stopPrice
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiMarginCreateOrderRequest) NewClientOrderId(newClientOrderId string) ApiMarginCreateOrderRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
func (r ApiMarginCreateOrderRequest) IcebergQty(icebergQty float64) ApiMarginCreateOrderRequest {
	r.icebergQty = &icebergQty
	return r
}

// Set the response JSON.
func (r ApiMarginCreateOrderRequest) NewOrderRespType(newOrderRespType string) ApiMarginCreateOrderRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}

// Default NO_SIDE_EFFECT
func (r ApiMarginCreateOrderRequest) SideEffectType(sideEffectType string) ApiMarginCreateOrderRequest {
	r.sideEffectType = &sideEffectType
	return r
}

// Order time in force
func (r ApiMarginCreateOrderRequest) TimeInForce(timeInForce string) ApiMarginCreateOrderRequest {
	r.timeInForce = &timeInForce
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginCreateOrderRequest) RecvWindow(recvWindow int64) ApiMarginCreateOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginCreateOrderRequest) Execute() (OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull, *_nethttp.Response, error) {
	return r.ApiService.MarginCreateOrderExecute(r)
}

/*
MarginCreateOrder Margin Account New Order (TRADE)

Post a new order for margin account.

Weight(UID): 6

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginCreateOrderRequest
*/
func (a *MarginApiService) MarginCreateOrder(ctx _context.Context) ApiMarginCreateOrderRequest {
	return ApiMarginCreateOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull
func (a *MarginApiService) MarginCreateOrderExecute(r ApiMarginCreateOrderRequest) (OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfmarginOrderResponseAckmarginOrderResponseResultmarginOrderResponseFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginCreateOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginDisableAccountRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginDisableAccountRequest) Symbol(symbol string) ApiMarginDisableAccountRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginDisableAccountRequest) Timestamp(timestamp int64) ApiMarginDisableAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginDisableAccountRequest) Signature(signature string) ApiMarginDisableAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginDisableAccountRequest) RecvWindow(recvWindow int64) ApiMarginDisableAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginDisableAccountRequest) Execute() (InlineResponse20025, *_nethttp.Response, error) {
	return r.ApiService.MarginDisableAccountExecute(r)
}

/*
MarginDisableAccount Disable Isolated Margin Account (TRADE)

Disable isolated margin account for a specific symbol. Each trading pair can only be deactivated once every 24 hours .

Weight(UID): 300

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginDisableAccountRequest
*/
func (a *MarginApiService) MarginDisableAccount(ctx _context.Context) ApiMarginDisableAccountRequest {
	return ApiMarginDisableAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20025
func (a *MarginApiService) MarginDisableAccountExecute(r ApiMarginDisableAccountRequest) (InlineResponse20025, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20025
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginDisableAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginEnableAccountRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginEnableAccountRequest) Symbol(symbol string) ApiMarginEnableAccountRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginEnableAccountRequest) Timestamp(timestamp int64) ApiMarginEnableAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginEnableAccountRequest) Signature(signature string) ApiMarginEnableAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginEnableAccountRequest) RecvWindow(recvWindow int64) ApiMarginEnableAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginEnableAccountRequest) Execute() (InlineResponse20025, *_nethttp.Response, error) {
	return r.ApiService.MarginEnableAccountExecute(r)
}

/*
MarginEnableAccount Enable Isolated Margin Account (TRADE)

Enable isolated margin account for a specific symbol.

Weight(UID): 300

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginEnableAccountRequest
*/
func (a *MarginApiService) MarginEnableAccount(ctx _context.Context) ApiMarginEnableAccountRequest {
	return ApiMarginEnableAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20025
func (a *MarginApiService) MarginEnableAccountExecute(r ApiMarginEnableAccountRequest) (InlineResponse20025, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20025
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginEnableAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginExecuteTransferRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	asset      *string
	amount     *float64
	timestamp  *int64
	signature  *string
	type_      *int32
	recvWindow *int64
}

func (r ApiMarginExecuteTransferRequest) Asset(asset string) ApiMarginExecuteTransferRequest {
	r.asset = &asset
	return r
}
func (r ApiMarginExecuteTransferRequest) Amount(amount float64) ApiMarginExecuteTransferRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiMarginExecuteTransferRequest) Timestamp(timestamp int64) ApiMarginExecuteTransferRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginExecuteTransferRequest) Signature(signature string) ApiMarginExecuteTransferRequest {
	r.signature = &signature
	return r
}

// 1 -&gt; transfer from main account to margin account \\ 2 -&gt; transfer from margin account to main account
func (r ApiMarginExecuteTransferRequest) Type_(type_ int32) ApiMarginExecuteTransferRequest {
	r.type_ = &type_
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginExecuteTransferRequest) RecvWindow(recvWindow int64) ApiMarginExecuteTransferRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginExecuteTransferRequest) Execute() (Transaction, *_nethttp.Response, error) {
	return r.ApiService.MarginExecuteTransferExecute(r)
}

/*
MarginExecuteTransfer Cross Margin Account Transfer (MARGIN)

Execute transfer between spot account and cross margin account.

Weight(IP): 600

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginExecuteTransferRequest
*/
func (a *MarginApiService) MarginExecuteTransfer(ctx _context.Context) ApiMarginExecuteTransferRequest {
	return ApiMarginExecuteTransferRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Transaction
func (a *MarginApiService) MarginExecuteTransferExecute(r ApiMarginExecuteTransferRequest) (Transaction, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Transaction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginExecuteTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAccountRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetAccountRequest) Timestamp(timestamp int64) ApiMarginGetAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetAccountRequest) Signature(signature string) ApiMarginGetAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetAccountRequest) RecvWindow(recvWindow int64) ApiMarginGetAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetAccountRequest) Execute() (InlineResponse20019, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAccountExecute(r)
}

/*
MarginGetAccount Query Cross Margin Account Details (USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAccountRequest
*/
func (a *MarginApiService) MarginGetAccount(ctx _context.Context) ApiMarginGetAccountRequest {
	return ApiMarginGetAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20019
func (a *MarginApiService) MarginGetAccountExecute(r ApiMarginGetAccountRequest) (InlineResponse20019, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20019
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAccountInfoRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	symbols    *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetAccountInfoRequest) Timestamp(timestamp int64) ApiMarginGetAccountInfoRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetAccountInfoRequest) Signature(signature string) ApiMarginGetAccountInfoRequest {
	r.signature = &signature
	return r
}

// Max 5 symbols can be sent; separated by &#39;,&#39;
func (r ApiMarginGetAccountInfoRequest) Symbols(symbols string) ApiMarginGetAccountInfoRequest {
	r.symbols = &symbols
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetAccountInfoRequest) RecvWindow(recvWindow int64) ApiMarginGetAccountInfoRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetAccountInfoRequest) Execute() (IsolatedMarginAccountInfo, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAccountInfoExecute(r)
}

/*
MarginGetAccountInfo Query Isolated Margin Account Info (USER_DATA)

- If "symbols" is not sent, all isolated assets will be returned.
- If "symbols" is sent, only the isolated assets of the sent symbols will be returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAccountInfoRequest
*/
func (a *MarginApiService) MarginGetAccountInfo(ctx _context.Context) ApiMarginGetAccountInfoRequest {
	return ApiMarginGetAccountInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return IsolatedMarginAccountInfo
func (a *MarginApiService) MarginGetAccountInfoExecute(r ApiMarginGetAccountInfoRequest) (IsolatedMarginAccountInfo, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  IsolatedMarginAccountInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAccountInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbols != nil {
		localVarQueryParams.Add("symbols", parameterToString(*r.symbols, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAccountLimitRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetAccountLimitRequest) Timestamp(timestamp int64) ApiMarginGetAccountLimitRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetAccountLimitRequest) Signature(signature string) ApiMarginGetAccountLimitRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetAccountLimitRequest) RecvWindow(recvWindow int64) ApiMarginGetAccountLimitRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetAccountLimitRequest) Execute() (InlineResponse20026, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAccountLimitExecute(r)
}

/*
MarginGetAccountLimit Query Enabled Isolated Margin Account Limit (USER_DATA)

Query enabled isolated margin account limit.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAccountLimitRequest
*/
func (a *MarginApiService) MarginGetAccountLimit(ctx _context.Context) ApiMarginGetAccountLimitRequest {
	return ApiMarginGetAccountLimitRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20026
func (a *MarginApiService) MarginGetAccountLimitExecute(r ApiMarginGetAccountLimitRequest) (InlineResponse20026, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20026
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAccountLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/accountLimit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAllAssetsRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
}

func (r ApiMarginGetAllAssetsRequest) Execute() ([]InlineResponse20014, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAllAssetsExecute(r)
}

/*
MarginGetAllAssets Get All Margin Assets (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAllAssetsRequest
*/
func (a *MarginApiService) MarginGetAllAssets(ctx _context.Context) ApiMarginGetAllAssetsRequest {
	return ApiMarginGetAllAssetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20014
func (a *MarginApiService) MarginGetAllAssetsExecute(r ApiMarginGetAllAssetsRequest) ([]InlineResponse20014, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20014
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAllAssets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allAssets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAllCrossPairsRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
}

func (r ApiMarginGetAllCrossPairsRequest) Execute() ([]InlineResponse20015, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAllCrossPairsExecute(r)
}

/*
MarginGetAllCrossPairs Get All Cross Margin Pairs (MARKET_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAllCrossPairsRequest
*/
func (a *MarginApiService) MarginGetAllCrossPairs(ctx _context.Context) ApiMarginGetAllCrossPairsRequest {
	return ApiMarginGetAllCrossPairsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20015
func (a *MarginApiService) MarginGetAllCrossPairsExecute(r ApiMarginGetAllCrossPairsRequest) ([]InlineResponse20015, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20015
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAllCrossPairs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allPairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAllOcoOrdersRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	isIsolated *string
	symbol     *string
	fromId     *string
	startTime  *int64
	endTime    *int64
	limit      *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetAllOcoOrdersRequest) Timestamp(timestamp int64) ApiMarginGetAllOcoOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetAllOcoOrdersRequest) Signature(signature string) ApiMarginGetAllOcoOrdersRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetAllOcoOrdersRequest) IsIsolated(isIsolated string) ApiMarginGetAllOcoOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// Mandatory for isolated margin, not supported for cross margin
func (r ApiMarginGetAllOcoOrdersRequest) Symbol(symbol string) ApiMarginGetAllOcoOrdersRequest {
	r.symbol = &symbol
	return r
}

// If supplied, neither &#x60;startTime&#x60; or &#x60;endTime&#x60; can be provided
func (r ApiMarginGetAllOcoOrdersRequest) FromId(fromId string) ApiMarginGetAllOcoOrdersRequest {
	r.fromId = &fromId
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetAllOcoOrdersRequest) StartTime(startTime int64) ApiMarginGetAllOcoOrdersRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetAllOcoOrdersRequest) EndTime(endTime int64) ApiMarginGetAllOcoOrdersRequest {
	r.endTime = &endTime
	return r
}

// Default Value: 500; Max Value: 1000
func (r ApiMarginGetAllOcoOrdersRequest) Limit(limit int32) ApiMarginGetAllOcoOrdersRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetAllOcoOrdersRequest) RecvWindow(recvWindow int64) ApiMarginGetAllOcoOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetAllOcoOrdersRequest) Execute() ([]InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAllOcoOrdersExecute(r)
}

/*
MarginGetAllOcoOrders Query Margin Account's all OCO (USER_DATA)

Retrieves all OCO for a specific margin account based on provided optional parameters

Weight(IP): 200

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAllOcoOrdersRequest
*/
func (a *MarginApiService) MarginGetAllOcoOrders(ctx _context.Context) ApiMarginGetAllOcoOrdersRequest {
	return ApiMarginGetAllOcoOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2006
func (a *MarginApiService) MarginGetAllOcoOrdersExecute(r ApiMarginGetAllOcoOrdersRequest) ([]InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAllOcoOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAllOrdersRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	isIsolated *string
	orderId    *int64
	startTime  *int64
	endTime    *int64
	limit      *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetAllOrdersRequest) Symbol(symbol string) ApiMarginGetAllOrdersRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetAllOrdersRequest) Timestamp(timestamp int64) ApiMarginGetAllOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetAllOrdersRequest) Signature(signature string) ApiMarginGetAllOrdersRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetAllOrdersRequest) IsIsolated(isIsolated string) ApiMarginGetAllOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// Order id
func (r ApiMarginGetAllOrdersRequest) OrderId(orderId int64) ApiMarginGetAllOrdersRequest {
	r.orderId = &orderId
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetAllOrdersRequest) StartTime(startTime int64) ApiMarginGetAllOrdersRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetAllOrdersRequest) EndTime(endTime int64) ApiMarginGetAllOrdersRequest {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiMarginGetAllOrdersRequest) Limit(limit int32) ApiMarginGetAllOrdersRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetAllOrdersRequest) RecvWindow(recvWindow int64) ApiMarginGetAllOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetAllOrdersRequest) Execute() ([]MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAllOrdersExecute(r)
}

/*
MarginGetAllOrders Query Margin Account's All Orders (USER_DATA)

- If `orderId` is set, it will get orders >= that orderId. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 200

Request Limit: 60 times/min per IP

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAllOrdersRequest
*/
func (a *MarginApiService) MarginGetAllOrders(ctx _context.Context) ApiMarginGetAllOrdersRequest {
	return ApiMarginGetAllOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []MarginOrderDetail
func (a *MarginApiService) MarginGetAllOrdersExecute(r ApiMarginGetAllOrdersRequest) ([]MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAllOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAllPairsRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetAllPairsRequest) Timestamp(timestamp int64) ApiMarginGetAllPairsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetAllPairsRequest) Signature(signature string) ApiMarginGetAllPairsRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetAllPairsRequest) RecvWindow(recvWindow int64) ApiMarginGetAllPairsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetAllPairsRequest) Execute() ([]InlineResponse20027, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAllPairsExecute(r)
}

/*
MarginGetAllPairs Get All Isolated Margin Symbol(USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAllPairsRequest
*/
func (a *MarginApiService) MarginGetAllPairs(ctx _context.Context) ApiMarginGetAllPairsRequest {
	return ApiMarginGetAllPairsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20027
func (a *MarginApiService) MarginGetAllPairsExecute(r ApiMarginGetAllPairsRequest) ([]InlineResponse20027, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20027
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAllPairs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/allPairs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetAssetRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	asset      *string
}

func (r ApiMarginGetAssetRequest) Asset(asset string) ApiMarginGetAssetRequest {
	r.asset = &asset
	return r
}

func (r ApiMarginGetAssetRequest) Execute() (InlineResponse20012, *_nethttp.Response, error) {
	return r.ApiService.MarginGetAssetExecute(r)
}

/*
MarginGetAsset Query Margin Asset (MARKET_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetAssetRequest
*/
func (a *MarginApiService) MarginGetAsset(ctx _context.Context) ApiMarginGetAssetRequest {
	return ApiMarginGetAssetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20012
func (a *MarginApiService) MarginGetAssetExecute(r ApiMarginGetAssetRequest) (InlineResponse20012, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20012
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetAsset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetCrossTransferRecordRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	asset      *string
	type_      *string
	startTime  *int64
	endTime    *int64
	current    *int32
	size       *int32
	archived   *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetCrossTransferRecordRequest) Timestamp(timestamp int64) ApiMarginGetCrossTransferRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetCrossTransferRecordRequest) Signature(signature string) ApiMarginGetCrossTransferRecordRequest {
	r.signature = &signature
	return r
}
func (r ApiMarginGetCrossTransferRecordRequest) Asset(asset string) ApiMarginGetCrossTransferRecordRequest {
	r.asset = &asset
	return r
}

// Tranfer Type
func (r ApiMarginGetCrossTransferRecordRequest) Type_(type_ string) ApiMarginGetCrossTransferRecordRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetCrossTransferRecordRequest) StartTime(startTime int64) ApiMarginGetCrossTransferRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetCrossTransferRecordRequest) EndTime(endTime int64) ApiMarginGetCrossTransferRecordRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiMarginGetCrossTransferRecordRequest) Current(current int32) ApiMarginGetCrossTransferRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetCrossTransferRecordRequest) Size(size int32) ApiMarginGetCrossTransferRecordRequest {
	r.size = &size
	return r
}

// Default: false. Set to true for archived data from 6 months ago
func (r ApiMarginGetCrossTransferRecordRequest) Archived(archived string) ApiMarginGetCrossTransferRecordRequest {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetCrossTransferRecordRequest) RecvWindow(recvWindow int64) ApiMarginGetCrossTransferRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetCrossTransferRecordRequest) Execute() (InlineResponse2009, *_nethttp.Response, error) {
	return r.ApiService.MarginGetCrossTransferRecordExecute(r)
}

/*
MarginGetCrossTransferRecord Get Cross Margin Transfer History (USER_DATA)

- Response in descending order
- Returns data for last 7 days by default
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetCrossTransferRecordRequest
*/
func (a *MarginApiService) MarginGetCrossTransferRecord(ctx _context.Context) ApiMarginGetCrossTransferRecordRequest {
	return ApiMarginGetCrossTransferRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2009
func (a *MarginApiService) MarginGetCrossTransferRecordExecute(r ApiMarginGetCrossTransferRecordRequest) (InlineResponse2009, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2009
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetCrossTransferRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetForceLiquidationRecordRequest struct {
	ctx            _context.Context
	ApiService     *MarginApiService
	timestamp      *int64
	signature      *string
	startTime      *int64
	endTime        *int64
	isolatedSymbol *string
	current        *int32
	size           *int32
	recvWindow     *int64
}

// UTC timestamp in ms
func (r ApiMarginGetForceLiquidationRecordRequest) Timestamp(timestamp int64) ApiMarginGetForceLiquidationRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetForceLiquidationRecordRequest) Signature(signature string) ApiMarginGetForceLiquidationRecordRequest {
	r.signature = &signature
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetForceLiquidationRecordRequest) StartTime(startTime int64) ApiMarginGetForceLiquidationRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetForceLiquidationRecordRequest) EndTime(endTime int64) ApiMarginGetForceLiquidationRecordRequest {
	r.endTime = &endTime
	return r
}

// Isolated symbol
func (r ApiMarginGetForceLiquidationRecordRequest) IsolatedSymbol(isolatedSymbol string) ApiMarginGetForceLiquidationRecordRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiMarginGetForceLiquidationRecordRequest) Current(current int32) ApiMarginGetForceLiquidationRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetForceLiquidationRecordRequest) Size(size int32) ApiMarginGetForceLiquidationRecordRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetForceLiquidationRecordRequest) RecvWindow(recvWindow int64) ApiMarginGetForceLiquidationRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetForceLiquidationRecordRequest) Execute() (InlineResponse20018, *_nethttp.Response, error) {
	return r.ApiService.MarginGetForceLiquidationRecordExecute(r)
}

/*
MarginGetForceLiquidationRecord Get Force Liquidation Record (USER_DATA)

- Response in descending order

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetForceLiquidationRecordRequest
*/
func (a *MarginApiService) MarginGetForceLiquidationRecord(ctx _context.Context) ApiMarginGetForceLiquidationRecordRequest {
	return ApiMarginGetForceLiquidationRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20018
func (a *MarginApiService) MarginGetForceLiquidationRecordExecute(r ApiMarginGetForceLiquidationRecordRequest) (InlineResponse20018, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20018
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetForceLiquidationRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/forceLiquidationRec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetInterestRateRecordRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	asset      *string
	timestamp  *int64
	signature  *string
	vipLevel   *int32
	startTime  *int64
	endTime    *int64
	limit      *int32
	recvWindow *int64
}

func (r ApiMarginGetInterestRateRecordRequest) Asset(asset string) ApiMarginGetInterestRateRecordRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetInterestRateRecordRequest) Timestamp(timestamp int64) ApiMarginGetInterestRateRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetInterestRateRecordRequest) Signature(signature string) ApiMarginGetInterestRateRecordRequest {
	r.signature = &signature
	return r
}

// Defaults to user&#39;s vip level
func (r ApiMarginGetInterestRateRecordRequest) VipLevel(vipLevel int32) ApiMarginGetInterestRateRecordRequest {
	r.vipLevel = &vipLevel
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetInterestRateRecordRequest) StartTime(startTime int64) ApiMarginGetInterestRateRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetInterestRateRecordRequest) EndTime(endTime int64) ApiMarginGetInterestRateRecordRequest {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiMarginGetInterestRateRecordRequest) Limit(limit int32) ApiMarginGetInterestRateRecordRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetInterestRateRecordRequest) RecvWindow(recvWindow int64) ApiMarginGetInterestRateRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetInterestRateRecordRequest) Execute() ([]InlineResponse20028, *_nethttp.Response, error) {
	return r.ApiService.MarginGetInterestRateRecordExecute(r)
}

/*
MarginGetInterestRateRecord Margin Interest Rate History (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetInterestRateRecordRequest
*/
func (a *MarginApiService) MarginGetInterestRateRecord(ctx _context.Context) ApiMarginGetInterestRateRecordRequest {
	return ApiMarginGetInterestRateRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20028
func (a *MarginApiService) MarginGetInterestRateRecordExecute(r ApiMarginGetInterestRateRecordRequest) ([]InlineResponse20028, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20028
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetInterestRateRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/interestRateHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.vipLevel != nil {
		localVarQueryParams.Add("vipLevel", parameterToString(*r.vipLevel, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetInterestRecordRequest struct {
	ctx            _context.Context
	ApiService     *MarginApiService
	timestamp      *int64
	signature      *string
	asset          *string
	isolatedSymbol *string
	startTime      *int64
	endTime        *int64
	current        *int32
	size           *int32
	archived       *string
	recvWindow     *int64
}

// UTC timestamp in ms
func (r ApiMarginGetInterestRecordRequest) Timestamp(timestamp int64) ApiMarginGetInterestRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetInterestRecordRequest) Signature(signature string) ApiMarginGetInterestRecordRequest {
	r.signature = &signature
	return r
}
func (r ApiMarginGetInterestRecordRequest) Asset(asset string) ApiMarginGetInterestRecordRequest {
	r.asset = &asset
	return r
}

// Isolated symbol
func (r ApiMarginGetInterestRecordRequest) IsolatedSymbol(isolatedSymbol string) ApiMarginGetInterestRecordRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetInterestRecordRequest) StartTime(startTime int64) ApiMarginGetInterestRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetInterestRecordRequest) EndTime(endTime int64) ApiMarginGetInterestRecordRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiMarginGetInterestRecordRequest) Current(current int32) ApiMarginGetInterestRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetInterestRecordRequest) Size(size int32) ApiMarginGetInterestRecordRequest {
	r.size = &size
	return r
}

// Default: false. Set to true for archived data from 6 months ago
func (r ApiMarginGetInterestRecordRequest) Archived(archived string) ApiMarginGetInterestRecordRequest {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetInterestRecordRequest) RecvWindow(recvWindow int64) ApiMarginGetInterestRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetInterestRecordRequest) Execute() (InlineResponse20017, *_nethttp.Response, error) {
	return r.ApiService.MarginGetInterestRecordExecute(r)
}

/*
MarginGetInterestRecord Get Interest History (USER_DATA)

- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago
- `type` in response has 4 enums:
  - `PERIODIC` interest charged per hour
  - `ON_BORROW` first interest charged on borrow
  - `PERIODIC_CONVERTED` interest charged per hour converted into BNB
  - `ON_BORROW_CONVERTED` first interest charged on borrow converted into BNB

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetInterestRecordRequest
*/
func (a *MarginApiService) MarginGetInterestRecord(ctx _context.Context) ApiMarginGetInterestRecordRequest {
	return ApiMarginGetInterestRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20017
func (a *MarginApiService) MarginGetInterestRecordExecute(r ApiMarginGetInterestRecordRequest) (InlineResponse20017, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20017
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetInterestRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/interestHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetLoanRequest struct {
	ctx            _context.Context
	ApiService     *MarginApiService
	asset          *string
	timestamp      *int64
	signature      *string
	isolatedSymbol *string
	txId           *int64
	startTime      *int64
	endTime        *int64
	current        *int32
	size           *int32
	archived       *string
	recvWindow     *int64
}

func (r ApiMarginGetLoanRequest) Asset(asset string) ApiMarginGetLoanRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetLoanRequest) Timestamp(timestamp int64) ApiMarginGetLoanRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetLoanRequest) Signature(signature string) ApiMarginGetLoanRequest {
	r.signature = &signature
	return r
}

// Isolated symbol
func (r ApiMarginGetLoanRequest) IsolatedSymbol(isolatedSymbol string) ApiMarginGetLoanRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// the tranId in  &#x60;POST /sapi/v1/margin/loan&#x60;
func (r ApiMarginGetLoanRequest) TxId(txId int64) ApiMarginGetLoanRequest {
	r.txId = &txId
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetLoanRequest) StartTime(startTime int64) ApiMarginGetLoanRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetLoanRequest) EndTime(endTime int64) ApiMarginGetLoanRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiMarginGetLoanRequest) Current(current int32) ApiMarginGetLoanRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetLoanRequest) Size(size int32) ApiMarginGetLoanRequest {
	r.size = &size
	return r
}

// Default: false. Set to true for archived data from 6 months ago
func (r ApiMarginGetLoanRequest) Archived(archived string) ApiMarginGetLoanRequest {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetLoanRequest) RecvWindow(recvWindow int64) ApiMarginGetLoanRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetLoanRequest) Execute() (InlineResponse20010, *_nethttp.Response, error) {
	return r.ApiService.MarginGetLoanExecute(r)
}

/*
MarginGetLoan Query Loan Record (USER_DATA)

- `txId` or `startTime` must be sent. `txId` takes precedence.
- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetLoanRequest
*/
func (a *MarginApiService) MarginGetLoan(ctx _context.Context) ApiMarginGetLoanRequest {
	return ApiMarginGetLoanRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20010
func (a *MarginApiService) MarginGetLoanExecute(r ApiMarginGetLoanRequest) (InlineResponse20010, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20010
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetLoan")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/loan"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.txId != nil {
		localVarQueryParams.Add("txId", parameterToString(*r.txId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMaxBorrowableRequest struct {
	ctx            _context.Context
	ApiService     *MarginApiService
	asset          *string
	timestamp      *int64
	signature      *string
	isolatedSymbol *string
	recvWindow     *int64
}

func (r ApiMarginGetMaxBorrowableRequest) Asset(asset string) ApiMarginGetMaxBorrowableRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetMaxBorrowableRequest) Timestamp(timestamp int64) ApiMarginGetMaxBorrowableRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetMaxBorrowableRequest) Signature(signature string) ApiMarginGetMaxBorrowableRequest {
	r.signature = &signature
	return r
}

// Isolated symbol
func (r ApiMarginGetMaxBorrowableRequest) IsolatedSymbol(isolatedSymbol string) ApiMarginGetMaxBorrowableRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetMaxBorrowableRequest) RecvWindow(recvWindow int64) ApiMarginGetMaxBorrowableRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMaxBorrowableRequest) Execute() (InlineResponse20023, *_nethttp.Response, error) {
	return r.ApiService.MarginGetMaxBorrowableExecute(r)
}

/*
MarginGetMaxBorrowable Query Max Borrow (USER_DATA)

- If `isolatedSymbol` is not sent, crossed margin data will be sent.
- `borrowLimit` is also available from https://www.binance.com/en/margin-fee

Weight(IP): 50

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMaxBorrowableRequest
*/
func (a *MarginApiService) MarginGetMaxBorrowable(ctx _context.Context) ApiMarginGetMaxBorrowableRequest {
	return ApiMarginGetMaxBorrowableRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20023
func (a *MarginApiService) MarginGetMaxBorrowableExecute(r ApiMarginGetMaxBorrowableRequest) (InlineResponse20023, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20023
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetMaxBorrowable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/maxBorrowable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetMaxTransferableRequest struct {
	ctx            _context.Context
	ApiService     *MarginApiService
	asset          *string
	timestamp      *int64
	signature      *string
	isolatedSymbol *string
	recvWindow     *int64
}

func (r ApiMarginGetMaxTransferableRequest) Asset(asset string) ApiMarginGetMaxTransferableRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetMaxTransferableRequest) Timestamp(timestamp int64) ApiMarginGetMaxTransferableRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetMaxTransferableRequest) Signature(signature string) ApiMarginGetMaxTransferableRequest {
	r.signature = &signature
	return r
}

// Isolated symbol
func (r ApiMarginGetMaxTransferableRequest) IsolatedSymbol(isolatedSymbol string) ApiMarginGetMaxTransferableRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetMaxTransferableRequest) RecvWindow(recvWindow int64) ApiMarginGetMaxTransferableRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetMaxTransferableRequest) Execute() (InlineResponse20024, *_nethttp.Response, error) {
	return r.ApiService.MarginGetMaxTransferableExecute(r)
}

/*
MarginGetMaxTransferable Query Max Transfer-Out Amount (USER_DATA)

- If `isolatedSymbol` is not sent, crossed margin data will be sent.

Weight(IP): 50

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetMaxTransferableRequest
*/
func (a *MarginApiService) MarginGetMaxTransferable(ctx _context.Context) ApiMarginGetMaxTransferableRequest {
	return ApiMarginGetMaxTransferableRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20024
func (a *MarginApiService) MarginGetMaxTransferableExecute(r ApiMarginGetMaxTransferableRequest) (InlineResponse20024, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20024
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetMaxTransferable")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/maxTransferable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetOcoOrdersRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	isIsolated *string
	symbol     *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetOcoOrdersRequest) Timestamp(timestamp int64) ApiMarginGetOcoOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetOcoOrdersRequest) Signature(signature string) ApiMarginGetOcoOrdersRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetOcoOrdersRequest) IsIsolated(isIsolated string) ApiMarginGetOcoOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// Mandatory for isolated margin, not supported for cross margin
func (r ApiMarginGetOcoOrdersRequest) Symbol(symbol string) ApiMarginGetOcoOrdersRequest {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetOcoOrdersRequest) RecvWindow(recvWindow int64) ApiMarginGetOcoOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetOcoOrdersRequest) Execute() ([]InlineResponse20022, *_nethttp.Response, error) {
	return r.ApiService.MarginGetOcoOrdersExecute(r)
}

/*
MarginGetOcoOrders Query Margin Account's Open OCO (USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetOcoOrdersRequest
*/
func (a *MarginApiService) MarginGetOcoOrders(ctx _context.Context) ApiMarginGetOcoOrdersRequest {
	return ApiMarginGetOcoOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20022
func (a *MarginApiService) MarginGetOcoOrdersExecute(r ApiMarginGetOcoOrdersRequest) ([]InlineResponse20022, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20022
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetOcoOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetOrderRequest struct {
	ctx               _context.Context
	ApiService        *MarginApiService
	symbol            *string
	timestamp         *int64
	signature         *string
	isIsolated        *string
	orderId           *int64
	origClientOrderId *string
	recvWindow        *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetOrderRequest) Symbol(symbol string) ApiMarginGetOrderRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetOrderRequest) Timestamp(timestamp int64) ApiMarginGetOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetOrderRequest) Signature(signature string) ApiMarginGetOrderRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetOrderRequest) IsIsolated(isIsolated string) ApiMarginGetOrderRequest {
	r.isIsolated = &isIsolated
	return r
}

// Order id
func (r ApiMarginGetOrderRequest) OrderId(orderId int64) ApiMarginGetOrderRequest {
	r.orderId = &orderId
	return r
}

// Order id from client
func (r ApiMarginGetOrderRequest) OrigClientOrderId(origClientOrderId string) ApiMarginGetOrderRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetOrderRequest) RecvWindow(recvWindow int64) ApiMarginGetOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetOrderRequest) Execute() (MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.MarginGetOrderExecute(r)
}

/*
MarginGetOrder Query Margin Account's Order (USER_DATA)

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetOrderRequest
*/
func (a *MarginApiService) MarginGetOrder(ctx _context.Context) ApiMarginGetOrderRequest {
	return ApiMarginGetOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MarginOrderDetail
func (a *MarginApiService) MarginGetOrderExecute(r ApiMarginGetOrderRequest) (MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetOrdersRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	timestamp  *int64
	signature  *string
	symbol     *string
	isIsolated *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiMarginGetOrdersRequest) Timestamp(timestamp int64) ApiMarginGetOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetOrdersRequest) Signature(signature string) ApiMarginGetOrdersRequest {
	r.signature = &signature
	return r
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetOrdersRequest) Symbol(symbol string) ApiMarginGetOrdersRequest {
	r.symbol = &symbol
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetOrdersRequest) IsIsolated(isIsolated string) ApiMarginGetOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetOrdersRequest) RecvWindow(recvWindow int64) ApiMarginGetOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetOrdersRequest) Execute() ([]MarginOrderDetail, *_nethttp.Response, error) {
	return r.ApiService.MarginGetOrdersExecute(r)
}

/*
MarginGetOrders Query Margin Account's Open Orders (USER_DATA)

- If the `symbol` is not sent, orders for all symbols will be returned in an array.
- When all symbols are returned, the number of requests counted against the rate limiter is equal to the number of symbols currently trading on the exchange
- If isIsolated ="TRUE", symbol must be sent.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetOrdersRequest
*/
func (a *MarginApiService) MarginGetOrders(ctx _context.Context) ApiMarginGetOrdersRequest {
	return ApiMarginGetOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []MarginOrderDetail
func (a *MarginApiService) MarginGetOrdersExecute(r ApiMarginGetOrdersRequest) ([]MarginOrderDetail, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginOrderDetail
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetPairRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetPairRequest) Symbol(symbol string) ApiMarginGetPairRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetPairRequest) Timestamp(timestamp int64) ApiMarginGetPairRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetPairRequest) Signature(signature string) ApiMarginGetPairRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetPairRequest) RecvWindow(recvWindow int64) ApiMarginGetPairRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetPairRequest) Execute() (InlineResponse20027, *_nethttp.Response, error) {
	return r.ApiService.MarginGetPairExecute(r)
}

/*
MarginGetPair Query Isolated Margin Symbol (USER_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetPairRequest
*/
func (a *MarginApiService) MarginGetPair(ctx _context.Context) ApiMarginGetPairRequest {
	return ApiMarginGetPairRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20027
func (a *MarginApiService) MarginGetPairExecute(r ApiMarginGetPairRequest) (InlineResponse20027, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20027
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetPair")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetPairsRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetPairsRequest) Symbol(symbol string) ApiMarginGetPairsRequest {
	r.symbol = &symbol
	return r
}

func (r ApiMarginGetPairsRequest) Execute() (InlineResponse20013, *_nethttp.Response, error) {
	return r.ApiService.MarginGetPairsExecute(r)
}

/*
MarginGetPairs Query Cross Margin Pair (MARKET_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetPairsRequest
*/
func (a *MarginApiService) MarginGetPairs(ctx _context.Context) ApiMarginGetPairsRequest {
	return ApiMarginGetPairsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20013
func (a *MarginApiService) MarginGetPairsExecute(r ApiMarginGetPairsRequest) (InlineResponse20013, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20013
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetPairs")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetPriceIndexRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetPriceIndexRequest) Symbol(symbol string) ApiMarginGetPriceIndexRequest {
	r.symbol = &symbol
	return r
}

func (r ApiMarginGetPriceIndexRequest) Execute() (InlineResponse20016, *_nethttp.Response, error) {
	return r.ApiService.MarginGetPriceIndexExecute(r)
}

/*
MarginGetPriceIndex Query Margin PriceIndex (MARKET_DATA)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetPriceIndexRequest
*/
func (a *MarginApiService) MarginGetPriceIndex(ctx _context.Context) ApiMarginGetPriceIndexRequest {
	return ApiMarginGetPriceIndexRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20016
func (a *MarginApiService) MarginGetPriceIndexExecute(r ApiMarginGetPriceIndexRequest) (InlineResponse20016, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20016
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetPriceIndex")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/priceIndex"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetRepayRecordRequest struct {
	ctx            _context.Context
	ApiService     *MarginApiService
	asset          *string
	timestamp      *int64
	signature      *string
	isolatedSymbol *string
	txId           *int64
	startTime      *int64
	endTime        *int64
	current        *int32
	size           *int32
	archived       *string
	recvWindow     *int64
}

func (r ApiMarginGetRepayRecordRequest) Asset(asset string) ApiMarginGetRepayRecordRequest {
	r.asset = &asset
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetRepayRecordRequest) Timestamp(timestamp int64) ApiMarginGetRepayRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetRepayRecordRequest) Signature(signature string) ApiMarginGetRepayRecordRequest {
	r.signature = &signature
	return r
}

// Isolated symbol
func (r ApiMarginGetRepayRecordRequest) IsolatedSymbol(isolatedSymbol string) ApiMarginGetRepayRecordRequest {
	r.isolatedSymbol = &isolatedSymbol
	return r
}

// the tranId in  &#x60;POST /sapi/v1/margin/repay&#x60;
func (r ApiMarginGetRepayRecordRequest) TxId(txId int64) ApiMarginGetRepayRecordRequest {
	r.txId = &txId
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetRepayRecordRequest) StartTime(startTime int64) ApiMarginGetRepayRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetRepayRecordRequest) EndTime(endTime int64) ApiMarginGetRepayRecordRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiMarginGetRepayRecordRequest) Current(current int32) ApiMarginGetRepayRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetRepayRecordRequest) Size(size int32) ApiMarginGetRepayRecordRequest {
	r.size = &size
	return r
}

// Default: false. Set to true for archived data from 6 months ago
func (r ApiMarginGetRepayRecordRequest) Archived(archived string) ApiMarginGetRepayRecordRequest {
	r.archived = &archived
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetRepayRecordRequest) RecvWindow(recvWindow int64) ApiMarginGetRepayRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetRepayRecordRequest) Execute() (InlineResponse20011, *_nethttp.Response, error) {
	return r.ApiService.MarginGetRepayRecordExecute(r)
}

/*
MarginGetRepayRecord Query Repay Record (USER_DATA)

- `txId` or `startTime` must be sent. `txId` takes precedence.
- Response in descending order
- If `isolatedSymbol` is not sent, crossed margin data will be returned
- Set `archived` to `true` to query data from 6 months ago

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetRepayRecordRequest
*/
func (a *MarginApiService) MarginGetRepayRecord(ctx _context.Context) ApiMarginGetRepayRecordRequest {
	return ApiMarginGetRepayRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20011
func (a *MarginApiService) MarginGetRepayRecordExecute(r ApiMarginGetRepayRecordRequest) (InlineResponse20011, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20011
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetRepayRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/repay"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.isolatedSymbol != nil {
		localVarQueryParams.Add("isolatedSymbol", parameterToString(*r.isolatedSymbol, ""))
	}
	if r.txId != nil {
		localVarQueryParams.Add("txId", parameterToString(*r.txId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.archived != nil {
		localVarQueryParams.Add("archived", parameterToString(*r.archived, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetSpecificOcoOrdersRequest struct {
	ctx               _context.Context
	ApiService        *MarginApiService
	timestamp         *int64
	signature         *string
	isIsolated        *string
	symbol            *string
	orderListId       *int64
	origClientOrderId *string
	recvWindow        *int64
}

// UTC timestamp in ms
func (r ApiMarginGetSpecificOcoOrdersRequest) Timestamp(timestamp int64) ApiMarginGetSpecificOcoOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetSpecificOcoOrdersRequest) Signature(signature string) ApiMarginGetSpecificOcoOrdersRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetSpecificOcoOrdersRequest) IsIsolated(isIsolated string) ApiMarginGetSpecificOcoOrdersRequest {
	r.isIsolated = &isIsolated
	return r
}

// Mandatory for isolated margin, not supported for cross margin
func (r ApiMarginGetSpecificOcoOrdersRequest) Symbol(symbol string) ApiMarginGetSpecificOcoOrdersRequest {
	r.symbol = &symbol
	return r
}

// Order list id
func (r ApiMarginGetSpecificOcoOrdersRequest) OrderListId(orderListId int64) ApiMarginGetSpecificOcoOrdersRequest {
	r.orderListId = &orderListId
	return r
}

// Order id from client
func (r ApiMarginGetSpecificOcoOrdersRequest) OrigClientOrderId(origClientOrderId string) ApiMarginGetSpecificOcoOrdersRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetSpecificOcoOrdersRequest) RecvWindow(recvWindow int64) ApiMarginGetSpecificOcoOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetSpecificOcoOrdersRequest) Execute() (InlineResponse20021, *_nethttp.Response, error) {
	return r.ApiService.MarginGetSpecificOcoOrdersExecute(r)
}

/*
MarginGetSpecificOcoOrders Query Margin Account's OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

- Either `orderListId` or `origClientOrderId` must be provided

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetSpecificOcoOrdersRequest
*/
func (a *MarginApiService) MarginGetSpecificOcoOrders(ctx _context.Context) ApiMarginGetSpecificOcoOrdersRequest {
	return ApiMarginGetSpecificOcoOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20021
func (a *MarginApiService) MarginGetSpecificOcoOrdersExecute(r ApiMarginGetSpecificOcoOrdersRequest) (InlineResponse20021, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20021
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetSpecificOcoOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetTradesRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	isIsolated *string
	startTime  *int64
	endTime    *int64
	fromId     *int64
	limit      *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetTradesRequest) Symbol(symbol string) ApiMarginGetTradesRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetTradesRequest) Timestamp(timestamp int64) ApiMarginGetTradesRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetTradesRequest) Signature(signature string) ApiMarginGetTradesRequest {
	r.signature = &signature
	return r
}

// For isolated margin or not, &#39;TRUE&#39;, &#39;FALSE&#39;, default &#39;FALSE&#39;
func (r ApiMarginGetTradesRequest) IsIsolated(isIsolated string) ApiMarginGetTradesRequest {
	r.isIsolated = &isIsolated
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetTradesRequest) StartTime(startTime int64) ApiMarginGetTradesRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetTradesRequest) EndTime(endTime int64) ApiMarginGetTradesRequest {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r ApiMarginGetTradesRequest) FromId(fromId int64) ApiMarginGetTradesRequest {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r ApiMarginGetTradesRequest) Limit(limit int32) ApiMarginGetTradesRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetTradesRequest) RecvWindow(recvWindow int64) ApiMarginGetTradesRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetTradesRequest) Execute() ([]MarginTrade, *_nethttp.Response, error) {
	return r.ApiService.MarginGetTradesExecute(r)
}

/*
MarginGetTrades Query Margin Account's Trade List (USER_DATA)

- If `fromId` is set, it will get orders >= that `fromId`. Otherwise most recent trades are returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetTradesRequest
*/
func (a *MarginApiService) MarginGetTrades(ctx _context.Context) ApiMarginGetTradesRequest {
	return ApiMarginGetTradesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []MarginTrade
func (a *MarginApiService) MarginGetTradesExecute(r ApiMarginGetTradesRequest) ([]MarginTrade, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MarginTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetTrades")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.isIsolated != nil {
		localVarQueryParams.Add("isIsolated", parameterToString(*r.isIsolated, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginGetTransferRecordRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	asset      *string
	transFrom  *string
	transTo    *string
	startTime  *int64
	endTime    *int64
	current    *int32
	size       *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginGetTransferRecordRequest) Symbol(symbol string) ApiMarginGetTransferRecordRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetTransferRecordRequest) Timestamp(timestamp int64) ApiMarginGetTransferRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginGetTransferRecordRequest) Signature(signature string) ApiMarginGetTransferRecordRequest {
	r.signature = &signature
	return r
}
func (r ApiMarginGetTransferRecordRequest) Asset(asset string) ApiMarginGetTransferRecordRequest {
	r.asset = &asset
	return r
}
func (r ApiMarginGetTransferRecordRequest) TransFrom(transFrom string) ApiMarginGetTransferRecordRequest {
	r.transFrom = &transFrom
	return r
}
func (r ApiMarginGetTransferRecordRequest) TransTo(transTo string) ApiMarginGetTransferRecordRequest {
	r.transTo = &transTo
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetTransferRecordRequest) StartTime(startTime int64) ApiMarginGetTransferRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiMarginGetTransferRecordRequest) EndTime(endTime int64) ApiMarginGetTransferRecordRequest {
	r.endTime = &endTime
	return r
}

// Current querying page. Start from 1. Default:1
func (r ApiMarginGetTransferRecordRequest) Current(current int32) ApiMarginGetTransferRecordRequest {
	r.current = &current
	return r
}

// Default:10 Max:100
func (r ApiMarginGetTransferRecordRequest) Size(size int32) ApiMarginGetTransferRecordRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginGetTransferRecordRequest) RecvWindow(recvWindow int64) ApiMarginGetTransferRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginGetTransferRecordRequest) Execute() (MarginTransferDetails, *_nethttp.Response, error) {
	return r.ApiService.MarginGetTransferRecordExecute(r)
}

/*
MarginGetTransferRecord Get Isolated Margin Transfer History (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginGetTransferRecordRequest
*/
func (a *MarginApiService) MarginGetTransferRecord(ctx _context.Context) ApiMarginGetTransferRecordRequest {
	return ApiMarginGetTransferRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return MarginTransferDetails
func (a *MarginApiService) MarginGetTransferRecordExecute(r ApiMarginGetTransferRecordRequest) (MarginTransferDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  MarginTransferDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginGetTransferRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.transFrom != nil {
		localVarQueryParams.Add("transFrom", parameterToString(*r.transFrom, ""))
	}
	if r.transTo != nil {
		localVarQueryParams.Add("transTo", parameterToString(*r.transTo, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarginTransferRequest struct {
	ctx        _context.Context
	ApiService *MarginApiService
	asset      *string
	symbol     *string
	amount     *float64
	timestamp  *int64
	signature  *string
	transFrom  *string
	transTo    *string
	recvWindow *int64
}

func (r ApiMarginTransferRequest) Asset(asset string) ApiMarginTransferRequest {
	r.asset = &asset
	return r
}

// Trading symbol, e.g. BNBUSDT
func (r ApiMarginTransferRequest) Symbol(symbol string) ApiMarginTransferRequest {
	r.symbol = &symbol
	return r
}
func (r ApiMarginTransferRequest) Amount(amount float64) ApiMarginTransferRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiMarginTransferRequest) Timestamp(timestamp int64) ApiMarginTransferRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiMarginTransferRequest) Signature(signature string) ApiMarginTransferRequest {
	r.signature = &signature
	return r
}
func (r ApiMarginTransferRequest) TransFrom(transFrom string) ApiMarginTransferRequest {
	r.transFrom = &transFrom
	return r
}
func (r ApiMarginTransferRequest) TransTo(transTo string) ApiMarginTransferRequest {
	r.transTo = &transTo
	return r
}

// The value cannot be greater than 60000
func (r ApiMarginTransferRequest) RecvWindow(recvWindow int64) ApiMarginTransferRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiMarginTransferRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.MarginTransferExecute(r)
}

/*
MarginTransfer Isolated Margin Account Transfer (MARGIN)

Weight(UID): 600

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarginTransferRequest
*/
func (a *MarginApiService) MarginTransfer(ctx _context.Context) ApiMarginTransferRequest {
	return ApiMarginTransferRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *MarginApiService) MarginTransferExecute(r ApiMarginTransferRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MarginApiService.MarginTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/margin/isolated/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.transFrom != nil {
		localVarQueryParams.Add("transFrom", parameterToString(*r.transFrom, ""))
	}
	if r.transTo != nil {
		localVarQueryParams.Add("transTo", parameterToString(*r.transTo, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
