/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API generated with [binance/binance-api-swagger/blob/master/spot_api.yaml](https://github.com/binance/binance-api-swagger/blob/master/spot_api.yaml) with commit [v1.2.0 release](https://github.com/binance/binance-api-swagger/commit/60d14be031c031600c853d5cdab86db5ab73603e)  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
Contact: qishiwenjun@163.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// SubAccountApiService SubAccountApi service
type SubAccountApiService service

type ApiSubaccountCreateVirtualSubAccountRequest struct {
	ctx              _context.Context
	ApiService       *SubAccountApiService
	subAccountString *string
	timestamp        *int64
	signature        *string
	recvWindow       *int64
}

// Please input a string. We will create a virtual email using that string for you to register
func (r ApiSubaccountCreateVirtualSubAccountRequest) SubAccountString(subAccountString string) ApiSubaccountCreateVirtualSubAccountRequest {
	r.subAccountString = &subAccountString
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountCreateVirtualSubAccountRequest) Timestamp(timestamp int64) ApiSubaccountCreateVirtualSubAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountCreateVirtualSubAccountRequest) Signature(signature string) ApiSubaccountCreateVirtualSubAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountCreateVirtualSubAccountRequest) RecvWindow(recvWindow int64) ApiSubaccountCreateVirtualSubAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountCreateVirtualSubAccountRequest) Execute() (InlineResponse20046, *_nethttp.Response, error) {
	return r.ApiService.SubaccountCreateVirtualSubAccountExecute(r)
}

/*
SubaccountCreateVirtualSubAccount Create a Virtual Sub-account(For Master Account)

- This request will generate a virtual sub account under your master account.
- You need to enable "trade" option for the api key which requests this endpoint.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountCreateVirtualSubAccountRequest
*/
func (a *SubAccountApiService) SubaccountCreateVirtualSubAccount(ctx _context.Context) ApiSubaccountCreateVirtualSubAccountRequest {
	return ApiSubaccountCreateVirtualSubAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20046
func (a *SubAccountApiService) SubaccountCreateVirtualSubAccountExecute(r ApiSubaccountCreateVirtualSubAccountRequest) (InlineResponse20046, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20046
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountCreateVirtualSubAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/virtualSubAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subAccountString == nil {
		return localVarReturnValue, nil, reportError("subAccountString is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("subAccountString", parameterToString(*r.subAccountString, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountDepositRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	toEmail    *string
	asset      *string
	amount     *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Recipient email
func (r ApiSubaccountDepositRequest) ToEmail(toEmail string) ApiSubaccountDepositRequest {
	r.toEmail = &toEmail
	return r
}
func (r ApiSubaccountDepositRequest) Asset(asset string) ApiSubaccountDepositRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountDepositRequest) Amount(amount float64) ApiSubaccountDepositRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountDepositRequest) Timestamp(timestamp int64) ApiSubaccountDepositRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountDepositRequest) Signature(signature string) ApiSubaccountDepositRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountDepositRequest) RecvWindow(recvWindow int64) ApiSubaccountDepositRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountDepositRequest) Execute() (InlineResponse20068, *_nethttp.Response, error) {
	return r.ApiService.SubaccountDepositExecute(r)
}

/*
SubaccountDeposit Deposit assets into the managed sub-account（For Investor Master Account）

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountDepositRequest
*/
func (a *SubAccountApiService) SubaccountDeposit(ctx _context.Context) ApiSubaccountDepositRequest {
	return ApiSubaccountDepositRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20068
func (a *SubAccountApiService) SubaccountDepositExecute(r ApiSubaccountDepositRequest) (InlineResponse20068, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20068
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountDeposit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountEnableFuturesRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountEnableFuturesRequest) Email(email string) ApiSubaccountEnableFuturesRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountEnableFuturesRequest) Timestamp(timestamp int64) ApiSubaccountEnableFuturesRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountEnableFuturesRequest) Signature(signature string) ApiSubaccountEnableFuturesRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountEnableFuturesRequest) RecvWindow(recvWindow int64) ApiSubaccountEnableFuturesRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountEnableFuturesRequest) Execute() (InlineResponse20059, *_nethttp.Response, error) {
	return r.ApiService.SubaccountEnableFuturesExecute(r)
}

/*
SubaccountEnableFutures Enable Futures for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountEnableFuturesRequest
*/
func (a *SubAccountApiService) SubaccountEnableFutures(ctx _context.Context) ApiSubaccountEnableFuturesRequest {
	return ApiSubaccountEnableFuturesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20059
func (a *SubAccountApiService) SubaccountEnableFuturesExecute(r ApiSubaccountEnableFuturesRequest) (InlineResponse20059, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20059
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountEnableFutures")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountEnableLeverageTokenRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	enableBlvt *bool
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountEnableLeverageTokenRequest) Email(email string) ApiSubaccountEnableLeverageTokenRequest {
	r.email = &email
	return r
}

// Only true for now
func (r ApiSubaccountEnableLeverageTokenRequest) EnableBlvt(enableBlvt bool) ApiSubaccountEnableLeverageTokenRequest {
	r.enableBlvt = &enableBlvt
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountEnableLeverageTokenRequest) Timestamp(timestamp int64) ApiSubaccountEnableLeverageTokenRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountEnableLeverageTokenRequest) Signature(signature string) ApiSubaccountEnableLeverageTokenRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountEnableLeverageTokenRequest) RecvWindow(recvWindow int64) ApiSubaccountEnableLeverageTokenRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountEnableLeverageTokenRequest) Execute() (InlineResponse20067, *_nethttp.Response, error) {
	return r.ApiService.SubaccountEnableLeverageTokenExecute(r)
}

/*
SubaccountEnableLeverageToken Enable Leverage Token for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountEnableLeverageTokenRequest
*/
func (a *SubAccountApiService) SubaccountEnableLeverageToken(ctx _context.Context) ApiSubaccountEnableLeverageTokenRequest {
	return ApiSubaccountEnableLeverageTokenRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20067
func (a *SubAccountApiService) SubaccountEnableLeverageTokenExecute(r ApiSubaccountEnableLeverageTokenRequest) (InlineResponse20067, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20067
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountEnableLeverageToken")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/blvt/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.enableBlvt == nil {
		return localVarReturnValue, nil, reportError("enableBlvt is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("enableBlvt", parameterToString(*r.enableBlvt, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountEnableMarginRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountEnableMarginRequest) Email(email string) ApiSubaccountEnableMarginRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountEnableMarginRequest) Timestamp(timestamp int64) ApiSubaccountEnableMarginRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountEnableMarginRequest) Signature(signature string) ApiSubaccountEnableMarginRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountEnableMarginRequest) RecvWindow(recvWindow int64) ApiSubaccountEnableMarginRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountEnableMarginRequest) Execute() (InlineResponse20056, *_nethttp.Response, error) {
	return r.ApiService.SubaccountEnableMarginExecute(r)
}

/*
SubaccountEnableMargin Enable Margin for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountEnableMarginRequest
*/
func (a *SubAccountApiService) SubaccountEnableMargin(ctx _context.Context) ApiSubaccountEnableMarginRequest {
	return ApiSubaccountEnableMarginRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20056
func (a *SubAccountApiService) SubaccountEnableMarginExecute(r ApiSubaccountEnableMarginRequest) (InlineResponse20056, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20056
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountEnableMargin")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountFuturesInternalTransferRequest struct {
	ctx         _context.Context
	ApiService  *SubAccountApiService
	fromEmail   *string
	toEmail     *string
	futuresType *int32
	asset       *string
	amount      *float64
	timestamp   *int64
	signature   *string
	recvWindow  *int64
}

// Sender email
func (r ApiSubaccountFuturesInternalTransferRequest) FromEmail(fromEmail string) ApiSubaccountFuturesInternalTransferRequest {
	r.fromEmail = &fromEmail
	return r
}

// Recipient email
func (r ApiSubaccountFuturesInternalTransferRequest) ToEmail(toEmail string) ApiSubaccountFuturesInternalTransferRequest {
	r.toEmail = &toEmail
	return r
}

// 1:USDT-margined Futures,2: Coin-margined Futures
func (r ApiSubaccountFuturesInternalTransferRequest) FuturesType(futuresType int32) ApiSubaccountFuturesInternalTransferRequest {
	r.futuresType = &futuresType
	return r
}
func (r ApiSubaccountFuturesInternalTransferRequest) Asset(asset string) ApiSubaccountFuturesInternalTransferRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountFuturesInternalTransferRequest) Amount(amount float64) ApiSubaccountFuturesInternalTransferRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountFuturesInternalTransferRequest) Timestamp(timestamp int64) ApiSubaccountFuturesInternalTransferRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountFuturesInternalTransferRequest) Signature(signature string) ApiSubaccountFuturesInternalTransferRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountFuturesInternalTransferRequest) RecvWindow(recvWindow int64) ApiSubaccountFuturesInternalTransferRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountFuturesInternalTransferRequest) Execute() (InlineResponse20050, *_nethttp.Response, error) {
	return r.ApiService.SubaccountFuturesInternalTransferExecute(r)
}

/*
SubaccountFuturesInternalTransfer Sub-account Futures Asset Transfer (For Master Account)

- Master account can transfer max 2000 times a minute

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountFuturesInternalTransferRequest
*/
func (a *SubAccountApiService) SubaccountFuturesInternalTransfer(ctx _context.Context) ApiSubaccountFuturesInternalTransferRequest {
	return ApiSubaccountFuturesInternalTransferRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20050
func (a *SubAccountApiService) SubaccountFuturesInternalTransferExecute(r ApiSubaccountFuturesInternalTransferRequest) (InlineResponse20050, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20050
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountFuturesInternalTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountFuturesTransferRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	asset      *string
	amount     *float64
	type_      *int32
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountFuturesTransferRequest) Email(email string) ApiSubaccountFuturesTransferRequest {
	r.email = &email
	return r
}
func (r ApiSubaccountFuturesTransferRequest) Asset(asset string) ApiSubaccountFuturesTransferRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountFuturesTransferRequest) Amount(amount float64) ApiSubaccountFuturesTransferRequest {
	r.amount = &amount
	return r
}

// 1: transfer from subaccount&#39;s spot account to its USDT-margined futures account  2: transfer from subaccount&#39;s USDT-margined futures account to its spot account  3: transfer from subaccount&#39;s spot account to its COIN-margined futures account  4:transfer from subaccount&#39;s COIN-margined futures account to its spot account
func (r ApiSubaccountFuturesTransferRequest) Type_(type_ int32) ApiSubaccountFuturesTransferRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountFuturesTransferRequest) Timestamp(timestamp int64) ApiSubaccountFuturesTransferRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountFuturesTransferRequest) Signature(signature string) ApiSubaccountFuturesTransferRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountFuturesTransferRequest) RecvWindow(recvWindow int64) ApiSubaccountFuturesTransferRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountFuturesTransferRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SubaccountFuturesTransferExecute(r)
}

/*
SubaccountFuturesTransfer Transfer for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountFuturesTransferRequest
*/
func (a *SubAccountApiService) SubaccountFuturesTransfer(ctx _context.Context) ApiSubaccountFuturesTransferRequest {
	return ApiSubaccountFuturesTransferRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SubaccountFuturesTransferExecute(r ApiSubaccountFuturesTransferRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountFuturesTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetAssetDetailRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetAssetDetailRequest) Email(email string) ApiSubaccountGetAssetDetailRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetAssetDetailRequest) Timestamp(timestamp int64) ApiSubaccountGetAssetDetailRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetAssetDetailRequest) Signature(signature string) ApiSubaccountGetAssetDetailRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetAssetDetailRequest) RecvWindow(recvWindow int64) ApiSubaccountGetAssetDetailRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetAssetDetailRequest) Execute() ([]InlineResponse20069, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetAssetDetailExecute(r)
}

/*
SubaccountGetAssetDetail Managed sub-account asset details（For Investor Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetAssetDetailRequest
*/
func (a *SubAccountApiService) SubaccountGetAssetDetail(ctx _context.Context) ApiSubaccountGetAssetDetailRequest {
	return ApiSubaccountGetAssetDetailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20069
func (a *SubAccountApiService) SubaccountGetAssetDetailExecute(r ApiSubaccountGetAssetDetailRequest) ([]InlineResponse20069, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20069
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetAssetDetail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetAssetsRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetAssetsRequest) Email(email string) ApiSubaccountGetAssetsRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetAssetsRequest) Timestamp(timestamp int64) ApiSubaccountGetAssetsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetAssetsRequest) Signature(signature string) ApiSubaccountGetAssetsRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetAssetsRequest) RecvWindow(recvWindow int64) ApiSubaccountGetAssetsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetAssetsRequest) Execute() (InlineResponse20051, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetAssetsExecute(r)
}

/*
SubaccountGetAssets Sub-account Assets (For Master Account)

Fetch sub-account assets

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetAssetsRequest
*/
func (a *SubAccountApiService) SubaccountGetAssets(ctx _context.Context) ApiSubaccountGetAssetsRequest {
	return ApiSubaccountGetAssetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20051
func (a *SubAccountApiService) SubaccountGetAssetsExecute(r ApiSubaccountGetAssetsRequest) (InlineResponse20051, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20051
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetAssets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetDepositAddressRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	coin       *string
	timestamp  *int64
	signature  *string
	network    *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetDepositAddressRequest) Email(email string) ApiSubaccountGetDepositAddressRequest {
	r.email = &email
	return r
}

// Coin name
func (r ApiSubaccountGetDepositAddressRequest) Coin(coin string) ApiSubaccountGetDepositAddressRequest {
	r.coin = &coin
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetDepositAddressRequest) Timestamp(timestamp int64) ApiSubaccountGetDepositAddressRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetDepositAddressRequest) Signature(signature string) ApiSubaccountGetDepositAddressRequest {
	r.signature = &signature
	return r
}
func (r ApiSubaccountGetDepositAddressRequest) Network(network string) ApiSubaccountGetDepositAddressRequest {
	r.network = &network
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetDepositAddressRequest) RecvWindow(recvWindow int64) ApiSubaccountGetDepositAddressRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetDepositAddressRequest) Execute() (InlineResponse20053, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetDepositAddressExecute(r)
}

/*
SubaccountGetDepositAddress Sub-account Spot Assets Summary (For Master Account)

Fetch sub-account deposit address

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetDepositAddressRequest
*/
func (a *SubAccountApiService) SubaccountGetDepositAddress(ctx _context.Context) ApiSubaccountGetDepositAddressRequest {
	return ApiSubaccountGetDepositAddressRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20053
func (a *SubAccountApiService) SubaccountGetDepositAddressExecute(r ApiSubaccountGetDepositAddressRequest) (InlineResponse20053, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20053
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetDepositAddress")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetDepositRecordsRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	coin       *string
	status     *int32
	startTime  *int64
	endTime    *int64
	limit      *int64
	offset     *int32
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetDepositRecordsRequest) Email(email string) ApiSubaccountGetDepositRecordsRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetDepositRecordsRequest) Timestamp(timestamp int64) ApiSubaccountGetDepositRecordsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetDepositRecordsRequest) Signature(signature string) ApiSubaccountGetDepositRecordsRequest {
	r.signature = &signature
	return r
}

// Coin name
func (r ApiSubaccountGetDepositRecordsRequest) Coin(coin string) ApiSubaccountGetDepositRecordsRequest {
	r.coin = &coin
	return r
}

// 0(0:pending,6: credited but cannot withdraw, 1:success)
func (r ApiSubaccountGetDepositRecordsRequest) Status(status int32) ApiSubaccountGetDepositRecordsRequest {
	r.status = &status
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetDepositRecordsRequest) StartTime(startTime int64) ApiSubaccountGetDepositRecordsRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetDepositRecordsRequest) EndTime(endTime int64) ApiSubaccountGetDepositRecordsRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSubaccountGetDepositRecordsRequest) Limit(limit int64) ApiSubaccountGetDepositRecordsRequest {
	r.limit = &limit
	return r
}
func (r ApiSubaccountGetDepositRecordsRequest) Offset(offset int32) ApiSubaccountGetDepositRecordsRequest {
	r.offset = &offset
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetDepositRecordsRequest) RecvWindow(recvWindow int64) ApiSubaccountGetDepositRecordsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetDepositRecordsRequest) Execute() ([]InlineResponse20054, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetDepositRecordsExecute(r)
}

/*
SubaccountGetDepositRecords Sub-account Deposit History (For Master Account)

Fetch sub-account deposit history

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetDepositRecordsRequest
*/
func (a *SubAccountApiService) SubaccountGetDepositRecords(ctx _context.Context) ApiSubaccountGetDepositRecordsRequest {
	return ApiSubaccountGetDepositRecordsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20054
func (a *SubAccountApiService) SubaccountGetDepositRecordsExecute(r ApiSubaccountGetDepositRecordsRequest) ([]InlineResponse20054, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20054
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetDepositRecords")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subHisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetDetailFuturesAccountRequest struct {
	ctx         _context.Context
	ApiService  *SubAccountApiService
	email       *string
	futuresType *int32
	timestamp   *int64
	signature   *string
	recvWindow  *int64
}

// Sub-account email
func (r ApiSubaccountGetDetailFuturesAccountRequest) Email(email string) ApiSubaccountGetDetailFuturesAccountRequest {
	r.email = &email
	return r
}

// 1:USDT Margined Futures  2:COIN Margined Futures
func (r ApiSubaccountGetDetailFuturesAccountRequest) FuturesType(futuresType int32) ApiSubaccountGetDetailFuturesAccountRequest {
	r.futuresType = &futuresType
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetDetailFuturesAccountRequest) Timestamp(timestamp int64) ApiSubaccountGetDetailFuturesAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetDetailFuturesAccountRequest) Signature(signature string) ApiSubaccountGetDetailFuturesAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetDetailFuturesAccountRequest) RecvWindow(recvWindow int64) ApiSubaccountGetDetailFuturesAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetDetailFuturesAccountRequest) Execute() (SubAccountCOINFuturesDetails, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetDetailFuturesAccountExecute(r)
}

/*
SubaccountGetDetailFuturesAccount Detail on Sub-account's Futures Account V2 (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetDetailFuturesAccountRequest
*/
func (a *SubAccountApiService) SubaccountGetDetailFuturesAccount(ctx _context.Context) ApiSubaccountGetDetailFuturesAccountRequest {
	return ApiSubaccountGetDetailFuturesAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfsubAccountUSDTFuturesDetailssubAccountCOINFuturesDetails
func (a *SubAccountApiService) SubaccountGetDetailFuturesAccountExecute(r ApiSubaccountGetDetailFuturesAccountRequest) (SubAccountCOINFuturesDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubAccountCOINFuturesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetDetailFuturesAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetFuturesAccountDetailRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetFuturesAccountDetailRequest) Email(email string) ApiSubaccountGetFuturesAccountDetailRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesAccountDetailRequest) Timestamp(timestamp int64) ApiSubaccountGetFuturesAccountDetailRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetFuturesAccountDetailRequest) Signature(signature string) ApiSubaccountGetFuturesAccountDetailRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetFuturesAccountDetailRequest) RecvWindow(recvWindow int64) ApiSubaccountGetFuturesAccountDetailRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetFuturesAccountDetailRequest) Execute() (InlineResponse20060, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetFuturesAccountDetailExecute(r)
}

/*
SubaccountGetFuturesAccountDetail Detail on Sub-account's Futures Account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetFuturesAccountDetailRequest
*/
func (a *SubAccountApiService) SubaccountGetFuturesAccountDetail(ctx _context.Context) ApiSubaccountGetFuturesAccountDetailRequest {
	return ApiSubaccountGetFuturesAccountDetailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20060
func (a *SubAccountApiService) SubaccountGetFuturesAccountDetailExecute(r ApiSubaccountGetFuturesAccountDetailRequest) (InlineResponse20060, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20060
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetFuturesAccountDetail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetFuturesAccountSummaryRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesAccountSummaryRequest) Timestamp(timestamp int64) ApiSubaccountGetFuturesAccountSummaryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetFuturesAccountSummaryRequest) Signature(signature string) ApiSubaccountGetFuturesAccountSummaryRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetFuturesAccountSummaryRequest) RecvWindow(recvWindow int64) ApiSubaccountGetFuturesAccountSummaryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetFuturesAccountSummaryRequest) Execute() (InlineResponse20061, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetFuturesAccountSummaryExecute(r)
}

/*
SubaccountGetFuturesAccountSummary Summary of Sub-account's Futures Account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetFuturesAccountSummaryRequest
*/
func (a *SubAccountApiService) SubaccountGetFuturesAccountSummary(ctx _context.Context) ApiSubaccountGetFuturesAccountSummaryRequest {
	return ApiSubaccountGetFuturesAccountSummaryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20061
func (a *SubAccountApiService) SubaccountGetFuturesAccountSummaryExecute(r ApiSubaccountGetFuturesAccountSummaryRequest) (InlineResponse20061, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20061
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetFuturesAccountSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetFuturesAccountSummaryV2Request struct {
	ctx         _context.Context
	ApiService  *SubAccountApiService
	futuresType *int32
	timestamp   *int64
	signature   *string
	page        *int32
	limit       *string
	recvWindow  *int64
}

// 1:USDT Margined Futures  2:COIN Margined Futures
func (r ApiSubaccountGetFuturesAccountSummaryV2Request) FuturesType(futuresType int32) ApiSubaccountGetFuturesAccountSummaryV2Request {
	r.futuresType = &futuresType
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesAccountSummaryV2Request) Timestamp(timestamp int64) ApiSubaccountGetFuturesAccountSummaryV2Request {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetFuturesAccountSummaryV2Request) Signature(signature string) ApiSubaccountGetFuturesAccountSummaryV2Request {
	r.signature = &signature
	return r
}

// Default 1
func (r ApiSubaccountGetFuturesAccountSummaryV2Request) Page(page int32) ApiSubaccountGetFuturesAccountSummaryV2Request {
	r.page = &page
	return r
}

// Default 10, Max 20
func (r ApiSubaccountGetFuturesAccountSummaryV2Request) Limit(limit string) ApiSubaccountGetFuturesAccountSummaryV2Request {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetFuturesAccountSummaryV2Request) RecvWindow(recvWindow int64) ApiSubaccountGetFuturesAccountSummaryV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetFuturesAccountSummaryV2Request) Execute() (SubAccountUSDTFuturesSummary, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetFuturesAccountSummaryV2Execute(r)
}

/*
SubaccountGetFuturesAccountSummaryV2 Summary of Sub-account's Futures Account V2 (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetFuturesAccountSummaryV2Request
*/
func (a *SubAccountApiService) SubaccountGetFuturesAccountSummaryV2(ctx _context.Context) ApiSubaccountGetFuturesAccountSummaryV2Request {
	return ApiSubaccountGetFuturesAccountSummaryV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfsubAccountUSDTFuturesSummarysubAccountCOINFuturesSummary
func (a *SubAccountApiService) SubaccountGetFuturesAccountSummaryV2Execute(r ApiSubaccountGetFuturesAccountSummaryV2Request) (SubAccountUSDTFuturesSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubAccountUSDTFuturesSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetFuturesAccountSummaryV2")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetFuturesPositionRiskRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetFuturesPositionRiskRequest) Email(email string) ApiSubaccountGetFuturesPositionRiskRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesPositionRiskRequest) Timestamp(timestamp int64) ApiSubaccountGetFuturesPositionRiskRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetFuturesPositionRiskRequest) Signature(signature string) ApiSubaccountGetFuturesPositionRiskRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetFuturesPositionRiskRequest) RecvWindow(recvWindow int64) ApiSubaccountGetFuturesPositionRiskRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetFuturesPositionRiskRequest) Execute() ([]InlineResponse20062, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetFuturesPositionRiskExecute(r)
}

/*
SubaccountGetFuturesPositionRisk Futures Position-Risk of Sub-account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetFuturesPositionRiskRequest
*/
func (a *SubAccountApiService) SubaccountGetFuturesPositionRisk(ctx _context.Context) ApiSubaccountGetFuturesPositionRiskRequest {
	return ApiSubaccountGetFuturesPositionRiskRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20062
func (a *SubAccountApiService) SubaccountGetFuturesPositionRiskExecute(r ApiSubaccountGetFuturesPositionRiskRequest) ([]InlineResponse20062, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20062
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetFuturesPositionRisk")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetFuturesPositionRiskV2Request struct {
	ctx         _context.Context
	ApiService  *SubAccountApiService
	email       *string
	futuresType *int32
	timestamp   *int64
	signature   *string
	recvWindow  *int64
}

// Sub-account email
func (r ApiSubaccountGetFuturesPositionRiskV2Request) Email(email string) ApiSubaccountGetFuturesPositionRiskV2Request {
	r.email = &email
	return r
}

// 1:USDT Margined Futures  2:COIN Margined Futures
func (r ApiSubaccountGetFuturesPositionRiskV2Request) FuturesType(futuresType int32) ApiSubaccountGetFuturesPositionRiskV2Request {
	r.futuresType = &futuresType
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesPositionRiskV2Request) Timestamp(timestamp int64) ApiSubaccountGetFuturesPositionRiskV2Request {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetFuturesPositionRiskV2Request) Signature(signature string) ApiSubaccountGetFuturesPositionRiskV2Request {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetFuturesPositionRiskV2Request) RecvWindow(recvWindow int64) ApiSubaccountGetFuturesPositionRiskV2Request {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetFuturesPositionRiskV2Request) Execute() (SubAccountUSDTFuturesPositionRisk, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetFuturesPositionRiskV2Execute(r)
}

/*
SubaccountGetFuturesPositionRiskV2 Futures Position-Risk of Sub-account V2 (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetFuturesPositionRiskV2Request
*/
func (a *SubAccountApiService) SubaccountGetFuturesPositionRiskV2(ctx _context.Context) ApiSubaccountGetFuturesPositionRiskV2Request {
	return ApiSubaccountGetFuturesPositionRiskV2Request{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfsubAccountUSDTFuturesPositionRisksubAccountCOINFuturesPositionRisk
func (a *SubAccountApiService) SubaccountGetFuturesPositionRiskV2Execute(r ApiSubaccountGetFuturesPositionRiskV2Request) (SubAccountUSDTFuturesPositionRisk, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SubAccountUSDTFuturesPositionRisk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetFuturesPositionRiskV2")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetFuturesTransferRecordRequest struct {
	ctx         _context.Context
	ApiService  *SubAccountApiService
	email       *string
	futuresType *int32
	timestamp   *int64
	signature   *string
	startTime   *int64
	endTime     *int64
	page        *int32
	limit       *int32
	recvWindow  *int64
}

// Sub-account email
func (r ApiSubaccountGetFuturesTransferRecordRequest) Email(email string) ApiSubaccountGetFuturesTransferRecordRequest {
	r.email = &email
	return r
}

// 1:USDT-margined Futures, 2: Coin-margined Futures
func (r ApiSubaccountGetFuturesTransferRecordRequest) FuturesType(futuresType int32) ApiSubaccountGetFuturesTransferRecordRequest {
	r.futuresType = &futuresType
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesTransferRecordRequest) Timestamp(timestamp int64) ApiSubaccountGetFuturesTransferRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetFuturesTransferRecordRequest) Signature(signature string) ApiSubaccountGetFuturesTransferRecordRequest {
	r.signature = &signature
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesTransferRecordRequest) StartTime(startTime int64) ApiSubaccountGetFuturesTransferRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetFuturesTransferRecordRequest) EndTime(endTime int64) ApiSubaccountGetFuturesTransferRecordRequest {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiSubaccountGetFuturesTransferRecordRequest) Page(page int32) ApiSubaccountGetFuturesTransferRecordRequest {
	r.page = &page
	return r
}

// Default value: 50, Max value: 500
func (r ApiSubaccountGetFuturesTransferRecordRequest) Limit(limit int32) ApiSubaccountGetFuturesTransferRecordRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetFuturesTransferRecordRequest) RecvWindow(recvWindow int64) ApiSubaccountGetFuturesTransferRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetFuturesTransferRecordRequest) Execute() (InlineResponse20049, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetFuturesTransferRecordExecute(r)
}

/*
SubaccountGetFuturesTransferRecord Sub-account Futures Asset Transfer History (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetFuturesTransferRecordRequest
*/
func (a *SubAccountApiService) SubaccountGetFuturesTransferRecord(ctx _context.Context) ApiSubaccountGetFuturesTransferRecordRequest {
	return ApiSubaccountGetFuturesTransferRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20049
func (a *SubAccountApiService) SubaccountGetFuturesTransferRecordExecute(r ApiSubaccountGetFuturesTransferRecordRequest) (InlineResponse20049, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20049
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetFuturesTransferRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetMarginAccountDetailRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetMarginAccountDetailRequest) Email(email string) ApiSubaccountGetMarginAccountDetailRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetMarginAccountDetailRequest) Timestamp(timestamp int64) ApiSubaccountGetMarginAccountDetailRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetMarginAccountDetailRequest) Signature(signature string) ApiSubaccountGetMarginAccountDetailRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetMarginAccountDetailRequest) RecvWindow(recvWindow int64) ApiSubaccountGetMarginAccountDetailRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetMarginAccountDetailRequest) Execute() (InlineResponse20057, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetMarginAccountDetailExecute(r)
}

/*
SubaccountGetMarginAccountDetail Detail on Sub-account's Margin Account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetMarginAccountDetailRequest
*/
func (a *SubAccountApiService) SubaccountGetMarginAccountDetail(ctx _context.Context) ApiSubaccountGetMarginAccountDetailRequest {
	return ApiSubaccountGetMarginAccountDetailRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20057
func (a *SubAccountApiService) SubaccountGetMarginAccountDetailExecute(r ApiSubaccountGetMarginAccountDetailRequest) (InlineResponse20057, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20057
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetMarginAccountDetail")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetMarginAccountSummaryRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountGetMarginAccountSummaryRequest) Timestamp(timestamp int64) ApiSubaccountGetMarginAccountSummaryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetMarginAccountSummaryRequest) Signature(signature string) ApiSubaccountGetMarginAccountSummaryRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetMarginAccountSummaryRequest) RecvWindow(recvWindow int64) ApiSubaccountGetMarginAccountSummaryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetMarginAccountSummaryRequest) Execute() (InlineResponse20058, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetMarginAccountSummaryExecute(r)
}

/*
SubaccountGetMarginAccountSummary Summary of Sub-account's Margin Account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetMarginAccountSummaryRequest
*/
func (a *SubAccountApiService) SubaccountGetMarginAccountSummary(ctx _context.Context) ApiSubaccountGetMarginAccountSummaryRequest {
	return ApiSubaccountGetMarginAccountSummaryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20058
func (a *SubAccountApiService) SubaccountGetMarginAccountSummaryExecute(r ApiSubaccountGetMarginAccountSummaryRequest) (InlineResponse20058, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20058
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetMarginAccountSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSpotSummaryRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	timestamp  *int64
	signature  *string
	page       *int32
	size       *int32
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountGetSpotSummaryRequest) Email(email string) ApiSubaccountGetSpotSummaryRequest {
	r.email = &email
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetSpotSummaryRequest) Timestamp(timestamp int64) ApiSubaccountGetSpotSummaryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetSpotSummaryRequest) Signature(signature string) ApiSubaccountGetSpotSummaryRequest {
	r.signature = &signature
	return r
}

// Default 1
func (r ApiSubaccountGetSpotSummaryRequest) Page(page int32) ApiSubaccountGetSpotSummaryRequest {
	r.page = &page
	return r
}

// Default:10 Max:20
func (r ApiSubaccountGetSpotSummaryRequest) Size(size int32) ApiSubaccountGetSpotSummaryRequest {
	r.size = &size
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetSpotSummaryRequest) RecvWindow(recvWindow int64) ApiSubaccountGetSpotSummaryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSpotSummaryRequest) Execute() (InlineResponse20052, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetSpotSummaryExecute(r)
}

/*
SubaccountGetSpotSummary Sub-account Spot Assets Summary (For Master Account)

Get BTC valued asset summary of subaccounts.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSpotSummaryRequest
*/
func (a *SubAccountApiService) SubaccountGetSpotSummary(ctx _context.Context) ApiSubaccountGetSpotSummaryRequest {
	return ApiSubaccountGetSpotSummaryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20052
func (a *SubAccountApiService) SubaccountGetSpotSummaryExecute(r ApiSubaccountGetSpotSummaryRequest) (InlineResponse20052, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20052
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetSpotSummary")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetSpotTransferHistoryRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	fromEmail  *string
	toEmail    *string
	startTime  *int64
	endTime    *int64
	page       *int32
	limit      *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountGetSpotTransferHistoryRequest) Timestamp(timestamp int64) ApiSubaccountGetSpotTransferHistoryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetSpotTransferHistoryRequest) Signature(signature string) ApiSubaccountGetSpotTransferHistoryRequest {
	r.signature = &signature
	return r
}

// Sub-account email
func (r ApiSubaccountGetSpotTransferHistoryRequest) FromEmail(fromEmail string) ApiSubaccountGetSpotTransferHistoryRequest {
	r.fromEmail = &fromEmail
	return r
}

// Sub-account email
func (r ApiSubaccountGetSpotTransferHistoryRequest) ToEmail(toEmail string) ApiSubaccountGetSpotTransferHistoryRequest {
	r.toEmail = &toEmail
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetSpotTransferHistoryRequest) StartTime(startTime int64) ApiSubaccountGetSpotTransferHistoryRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetSpotTransferHistoryRequest) EndTime(endTime int64) ApiSubaccountGetSpotTransferHistoryRequest {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiSubaccountGetSpotTransferHistoryRequest) Page(page int32) ApiSubaccountGetSpotTransferHistoryRequest {
	r.page = &page
	return r
}

// Default 1
func (r ApiSubaccountGetSpotTransferHistoryRequest) Limit(limit int32) ApiSubaccountGetSpotTransferHistoryRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetSpotTransferHistoryRequest) RecvWindow(recvWindow int64) ApiSubaccountGetSpotTransferHistoryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetSpotTransferHistoryRequest) Execute() ([]InlineResponse20048, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetSpotTransferHistoryExecute(r)
}

/*
SubaccountGetSpotTransferHistory Sub-account Spot Asset Transfer History (For Master Account)

- fromEmail and toEmail cannot be sent at the same time.
- Return fromEmail equal master account email by default.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetSpotTransferHistoryRequest
*/
func (a *SubAccountApiService) SubaccountGetSpotTransferHistory(ctx _context.Context) ApiSubaccountGetSpotTransferHistoryRequest {
	return ApiSubaccountGetSpotTransferHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20048
func (a *SubAccountApiService) SubaccountGetSpotTransferHistoryExecute(r ApiSubaccountGetSpotTransferHistoryRequest) ([]InlineResponse20048, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20048
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetSpotTransferHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/sub/transfer/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromEmail != nil {
		localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	}
	if r.toEmail != nil {
		localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetTransferHistoryRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	asset      *string
	type_      *int32
	startTime  *int64
	endTime    *int64
	limit      *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountGetTransferHistoryRequest) Timestamp(timestamp int64) ApiSubaccountGetTransferHistoryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetTransferHistoryRequest) Signature(signature string) ApiSubaccountGetTransferHistoryRequest {
	r.signature = &signature
	return r
}
func (r ApiSubaccountGetTransferHistoryRequest) Asset(asset string) ApiSubaccountGetTransferHistoryRequest {
	r.asset = &asset
	return r
}

// 1: transfer in  2:  transfer out
func (r ApiSubaccountGetTransferHistoryRequest) Type_(type_ int32) ApiSubaccountGetTransferHistoryRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetTransferHistoryRequest) StartTime(startTime int64) ApiSubaccountGetTransferHistoryRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetTransferHistoryRequest) EndTime(endTime int64) ApiSubaccountGetTransferHistoryRequest {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiSubaccountGetTransferHistoryRequest) Limit(limit int32) ApiSubaccountGetTransferHistoryRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetTransferHistoryRequest) RecvWindow(recvWindow int64) ApiSubaccountGetTransferHistoryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetTransferHistoryRequest) Execute() ([]InlineResponse20064, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetTransferHistoryExecute(r)
}

/*
SubaccountGetTransferHistory Sub-account Transfer History (For Sub-account)

- If `type` is not sent, the records of type 2: transfer out will be returned by default.
- If `startTime` and `endTime` are not sent, the recent 30-day data will be returned.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetTransferHistoryRequest
*/
func (a *SubAccountApiService) SubaccountGetTransferHistory(ctx _context.Context) ApiSubaccountGetTransferHistoryRequest {
	return ApiSubaccountGetTransferHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20064
func (a *SubAccountApiService) SubaccountGetTransferHistoryExecute(r ApiSubaccountGetTransferHistoryRequest) ([]InlineResponse20064, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20064
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetTransferHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountGetUniversalTransferRecordRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	fromEmail  *string
	toEmail    *string
	startTime  *int64
	endTime    *int64
	page       *int32
	limit      *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountGetUniversalTransferRecordRequest) Timestamp(timestamp int64) ApiSubaccountGetUniversalTransferRecordRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountGetUniversalTransferRecordRequest) Signature(signature string) ApiSubaccountGetUniversalTransferRecordRequest {
	r.signature = &signature
	return r
}

// Sub-account email
func (r ApiSubaccountGetUniversalTransferRecordRequest) FromEmail(fromEmail string) ApiSubaccountGetUniversalTransferRecordRequest {
	r.fromEmail = &fromEmail
	return r
}

// Sub-account email
func (r ApiSubaccountGetUniversalTransferRecordRequest) ToEmail(toEmail string) ApiSubaccountGetUniversalTransferRecordRequest {
	r.toEmail = &toEmail
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetUniversalTransferRecordRequest) StartTime(startTime int64) ApiSubaccountGetUniversalTransferRecordRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountGetUniversalTransferRecordRequest) EndTime(endTime int64) ApiSubaccountGetUniversalTransferRecordRequest {
	r.endTime = &endTime
	return r
}

// Default 1
func (r ApiSubaccountGetUniversalTransferRecordRequest) Page(page int32) ApiSubaccountGetUniversalTransferRecordRequest {
	r.page = &page
	return r
}

// Default 500, Max 500
func (r ApiSubaccountGetUniversalTransferRecordRequest) Limit(limit string) ApiSubaccountGetUniversalTransferRecordRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountGetUniversalTransferRecordRequest) RecvWindow(recvWindow int64) ApiSubaccountGetUniversalTransferRecordRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountGetUniversalTransferRecordRequest) Execute() ([]InlineResponse20065, *_nethttp.Response, error) {
	return r.ApiService.SubaccountGetUniversalTransferRecordExecute(r)
}

/*
SubaccountGetUniversalTransferRecord Universal Transfer History (For Master Account)

- fromEmail and toEmail cannot be sent at the same time.
- Return fromEmail equal master account email by default.
- Only get the latest history of past 30 days.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountGetUniversalTransferRecordRequest
*/
func (a *SubAccountApiService) SubaccountGetUniversalTransferRecord(ctx _context.Context) ApiSubaccountGetUniversalTransferRecordRequest {
	return ApiSubaccountGetUniversalTransferRecordRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20065
func (a *SubAccountApiService) SubaccountGetUniversalTransferRecordExecute(r ApiSubaccountGetUniversalTransferRecordRequest) ([]InlineResponse20065, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20065
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountGetUniversalTransferRecord")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromEmail != nil {
		localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	}
	if r.toEmail != nil {
		localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountListRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	email      *string
	isFreeze   *string
	page       *int32
	limit      *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountListRequest) Timestamp(timestamp int64) ApiSubaccountListRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountListRequest) Signature(signature string) ApiSubaccountListRequest {
	r.signature = &signature
	return r
}

// Sub-account email
func (r ApiSubaccountListRequest) Email(email string) ApiSubaccountListRequest {
	r.email = &email
	return r
}
func (r ApiSubaccountListRequest) IsFreeze(isFreeze string) ApiSubaccountListRequest {
	r.isFreeze = &isFreeze
	return r
}

// Default 1
func (r ApiSubaccountListRequest) Page(page int32) ApiSubaccountListRequest {
	r.page = &page
	return r
}

// Default 1; max 200
func (r ApiSubaccountListRequest) Limit(limit int32) ApiSubaccountListRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountListRequest) RecvWindow(recvWindow int64) ApiSubaccountListRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountListRequest) Execute() (InlineResponse20047, *_nethttp.Response, error) {
	return r.ApiService.SubaccountListExecute(r)
}

/*
SubaccountList Query Sub-account List (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountListRequest
*/
func (a *SubAccountApiService) SubaccountList(ctx _context.Context) ApiSubaccountListRequest {
	return ApiSubaccountListRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20047
func (a *SubAccountApiService) SubaccountListExecute(r ApiSubaccountListRequest) (InlineResponse20047, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20047
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountList")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.isFreeze != nil {
		localVarQueryParams.Add("isFreeze", parameterToString(*r.isFreeze, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountMarginTransferRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	email      *string
	asset      *string
	amount     *float64
	type_      *int32
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSubaccountMarginTransferRequest) Email(email string) ApiSubaccountMarginTransferRequest {
	r.email = &email
	return r
}
func (r ApiSubaccountMarginTransferRequest) Asset(asset string) ApiSubaccountMarginTransferRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountMarginTransferRequest) Amount(amount float64) ApiSubaccountMarginTransferRequest {
	r.amount = &amount
	return r
}

// 1: transfer from subaccount&#39;s spot account to margin account  2: transfer from subaccount&#39;s margin account to its spot account
func (r ApiSubaccountMarginTransferRequest) Type_(type_ int32) ApiSubaccountMarginTransferRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountMarginTransferRequest) Timestamp(timestamp int64) ApiSubaccountMarginTransferRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountMarginTransferRequest) Signature(signature string) ApiSubaccountMarginTransferRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountMarginTransferRequest) RecvWindow(recvWindow int64) ApiSubaccountMarginTransferRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountMarginTransferRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SubaccountMarginTransferExecute(r)
}

/*
SubaccountMarginTransfer Margin Transfer for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountMarginTransferRequest
*/
func (a *SubAccountApiService) SubaccountMarginTransfer(ctx _context.Context) ApiSubaccountMarginTransferRequest {
	return ApiSubaccountMarginTransferRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SubaccountMarginTransferExecute(r ApiSubaccountMarginTransferRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountMarginTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountStatusRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	timestamp  *int64
	signature  *string
	email      *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSubaccountStatusRequest) Timestamp(timestamp int64) ApiSubaccountStatusRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountStatusRequest) Signature(signature string) ApiSubaccountStatusRequest {
	r.signature = &signature
	return r
}

// Sub-account email
func (r ApiSubaccountStatusRequest) Email(email string) ApiSubaccountStatusRequest {
	r.email = &email
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountStatusRequest) RecvWindow(recvWindow int64) ApiSubaccountStatusRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountStatusRequest) Execute() ([]InlineResponse20055, *_nethttp.Response, error) {
	return r.ApiService.SubaccountStatusExecute(r)
}

/*
SubaccountStatus Sub-account's Status on Margin/Futures (For Master Account)

- If no `email` sent, all sub-accounts' information will be returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountStatusRequest
*/
func (a *SubAccountApiService) SubaccountStatus(ctx _context.Context) ApiSubaccountStatusRequest {
	return ApiSubaccountStatusRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20055
func (a *SubAccountApiService) SubaccountStatusExecute(r ApiSubaccountStatusRequest) ([]InlineResponse20055, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20055
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountStatus")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountTransferBetweenSubRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	toEmail    *string
	asset      *string
	amount     *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Recipient email
func (r ApiSubaccountTransferBetweenSubRequest) ToEmail(toEmail string) ApiSubaccountTransferBetweenSubRequest {
	r.toEmail = &toEmail
	return r
}
func (r ApiSubaccountTransferBetweenSubRequest) Asset(asset string) ApiSubaccountTransferBetweenSubRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountTransferBetweenSubRequest) Amount(amount float64) ApiSubaccountTransferBetweenSubRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountTransferBetweenSubRequest) Timestamp(timestamp int64) ApiSubaccountTransferBetweenSubRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountTransferBetweenSubRequest) Signature(signature string) ApiSubaccountTransferBetweenSubRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountTransferBetweenSubRequest) RecvWindow(recvWindow int64) ApiSubaccountTransferBetweenSubRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountTransferBetweenSubRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SubaccountTransferBetweenSubExecute(r)
}

/*
SubaccountTransferBetweenSub Transfer to Sub-account of Same Master (For Sub-account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountTransferBetweenSubRequest
*/
func (a *SubAccountApiService) SubaccountTransferBetweenSub(ctx _context.Context) ApiSubaccountTransferBetweenSubRequest {
	return ApiSubaccountTransferBetweenSubRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SubaccountTransferBetweenSubExecute(r ApiSubaccountTransferBetweenSubRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountTransferBetweenSub")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToSub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountTransferToMasterRequest struct {
	ctx        _context.Context
	ApiService *SubAccountApiService
	asset      *string
	amount     *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiSubaccountTransferToMasterRequest) Asset(asset string) ApiSubaccountTransferToMasterRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountTransferToMasterRequest) Amount(amount float64) ApiSubaccountTransferToMasterRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountTransferToMasterRequest) Timestamp(timestamp int64) ApiSubaccountTransferToMasterRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountTransferToMasterRequest) Signature(signature string) ApiSubaccountTransferToMasterRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountTransferToMasterRequest) RecvWindow(recvWindow int64) ApiSubaccountTransferToMasterRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountTransferToMasterRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SubaccountTransferToMasterExecute(r)
}

/*
SubaccountTransferToMaster Transfer to Master (For Sub-account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountTransferToMasterRequest
*/
func (a *SubAccountApiService) SubaccountTransferToMaster(ctx _context.Context) ApiSubaccountTransferToMasterRequest {
	return ApiSubaccountTransferToMasterRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SubaccountTransferToMasterExecute(r ApiSubaccountTransferToMasterRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountTransferToMaster")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToMaster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountUniversalTransferRequest struct {
	ctx             _context.Context
	ApiService      *SubAccountApiService
	fromAccountType *string
	toAccountType   *string
	asset           *string
	amount          *float64
	timestamp       *int64
	signature       *string
	fromEmail       *string
	toEmail         *string
	recvWindow      *int64
}

func (r ApiSubaccountUniversalTransferRequest) FromAccountType(fromAccountType string) ApiSubaccountUniversalTransferRequest {
	r.fromAccountType = &fromAccountType
	return r
}
func (r ApiSubaccountUniversalTransferRequest) ToAccountType(toAccountType string) ApiSubaccountUniversalTransferRequest {
	r.toAccountType = &toAccountType
	return r
}
func (r ApiSubaccountUniversalTransferRequest) Asset(asset string) ApiSubaccountUniversalTransferRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountUniversalTransferRequest) Amount(amount float64) ApiSubaccountUniversalTransferRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountUniversalTransferRequest) Timestamp(timestamp int64) ApiSubaccountUniversalTransferRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountUniversalTransferRequest) Signature(signature string) ApiSubaccountUniversalTransferRequest {
	r.signature = &signature
	return r
}

// Sub-account email
func (r ApiSubaccountUniversalTransferRequest) FromEmail(fromEmail string) ApiSubaccountUniversalTransferRequest {
	r.fromEmail = &fromEmail
	return r
}

// Sub-account email
func (r ApiSubaccountUniversalTransferRequest) ToEmail(toEmail string) ApiSubaccountUniversalTransferRequest {
	r.toEmail = &toEmail
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountUniversalTransferRequest) RecvWindow(recvWindow int64) ApiSubaccountUniversalTransferRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountUniversalTransferRequest) Execute() (InlineResponse20066, *_nethttp.Response, error) {
	return r.ApiService.SubaccountUniversalTransferExecute(r)
}

/*
SubaccountUniversalTransfer Universal Transfer (For Master Account)

- You need to enable "internal transfer" option for the api key which requests this endpoint.
- Transfer from master account by default if fromEmail is not sent.
- Transfer to master account by default if toEmail is not sent.
- Transfer between futures accounts is not supported.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountUniversalTransferRequest
*/
func (a *SubAccountApiService) SubaccountUniversalTransfer(ctx _context.Context) ApiSubaccountUniversalTransferRequest {
	return ApiSubaccountUniversalTransferRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20066
func (a *SubAccountApiService) SubaccountUniversalTransferExecute(r ApiSubaccountUniversalTransferRequest) (InlineResponse20066, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20066
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountUniversalTransfer")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromEmail != nil {
		localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	}
	if r.toEmail != nil {
		localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	}
	localVarQueryParams.Add("fromAccountType", parameterToString(*r.fromAccountType, ""))
	localVarQueryParams.Add("toAccountType", parameterToString(*r.toAccountType, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSubaccountWithdrawlAssetsRequest struct {
	ctx          _context.Context
	ApiService   *SubAccountApiService
	fromEmail    *string
	asset        *string
	amount       *float64
	timestamp    *int64
	signature    *string
	transferDate *int64
	recvWindow   *int64
}

// Sender email
func (r ApiSubaccountWithdrawlAssetsRequest) FromEmail(fromEmail string) ApiSubaccountWithdrawlAssetsRequest {
	r.fromEmail = &fromEmail
	return r
}
func (r ApiSubaccountWithdrawlAssetsRequest) Asset(asset string) ApiSubaccountWithdrawlAssetsRequest {
	r.asset = &asset
	return r
}
func (r ApiSubaccountWithdrawlAssetsRequest) Amount(amount float64) ApiSubaccountWithdrawlAssetsRequest {
	r.amount = &amount
	return r
}

// UTC timestamp in ms
func (r ApiSubaccountWithdrawlAssetsRequest) Timestamp(timestamp int64) ApiSubaccountWithdrawlAssetsRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSubaccountWithdrawlAssetsRequest) Signature(signature string) ApiSubaccountWithdrawlAssetsRequest {
	r.signature = &signature
	return r
}

// Withdrawals is automatically occur on the transfer date(UTC0). If a date is not selected, the withdrawal occurs right now
func (r ApiSubaccountWithdrawlAssetsRequest) TransferDate(transferDate int64) ApiSubaccountWithdrawlAssetsRequest {
	r.transferDate = &transferDate
	return r
}

// The value cannot be greater than 60000
func (r ApiSubaccountWithdrawlAssetsRequest) RecvWindow(recvWindow int64) ApiSubaccountWithdrawlAssetsRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSubaccountWithdrawlAssetsRequest) Execute() (InlineResponse20068, *_nethttp.Response, error) {
	return r.ApiService.SubaccountWithdrawlAssetsExecute(r)
}

/*
SubaccountWithdrawlAssets Withdrawl assets from the managed sub-account（For Investor Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSubaccountWithdrawlAssetsRequest
*/
func (a *SubAccountApiService) SubaccountWithdrawlAssets(ctx _context.Context) ApiSubaccountWithdrawlAssetsRequest {
	return ApiSubaccountWithdrawlAssetsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20068
func (a *SubAccountApiService) SubaccountWithdrawlAssetsExecute(r ApiSubaccountWithdrawlAssetsRequest) (InlineResponse20068, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20068
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SubaccountWithdrawlAssets")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/withdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.transferDate != nil {
		localVarQueryParams.Add("transferDate", parameterToString(*r.transferDate, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
