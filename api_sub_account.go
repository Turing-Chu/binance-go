/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// SubAccountApiService SubAccountApi service
type SubAccountApiService service

type ApiSapiV1CapitalDepositSubAddressGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	coin *string
	timestamp *int64
	signature *string
	network *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1CapitalDepositSubAddressGetRequest) Email(email string) ApiSapiV1CapitalDepositSubAddressGetRequest {
	r.email = &email
	return r
}
// Coin name
func (r ApiSapiV1CapitalDepositSubAddressGetRequest) Coin(coin string) ApiSapiV1CapitalDepositSubAddressGetRequest {
	r.coin = &coin
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositSubAddressGetRequest) Timestamp(timestamp int64) ApiSapiV1CapitalDepositSubAddressGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalDepositSubAddressGetRequest) Signature(signature string) ApiSapiV1CapitalDepositSubAddressGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1CapitalDepositSubAddressGetRequest) Network(network string) ApiSapiV1CapitalDepositSubAddressGetRequest {
	r.network = &network
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalDepositSubAddressGetRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalDepositSubAddressGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalDepositSubAddressGetRequest) Execute() (InlineResponse20053, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalDepositSubAddressGetExecute(r)
}

/*
SapiV1CapitalDepositSubAddressGet Sub-account Spot Assets Summary (For Master Account)

Fetch sub-account deposit address

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalDepositSubAddressGetRequest
*/
func (a *SubAccountApiService) SapiV1CapitalDepositSubAddressGet(ctx _context.Context) ApiSapiV1CapitalDepositSubAddressGetRequest {
	return ApiSapiV1CapitalDepositSubAddressGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20053
func (a *SubAccountApiService) SapiV1CapitalDepositSubAddressGetExecute(r ApiSapiV1CapitalDepositSubAddressGetRequest) (InlineResponse20053, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20053
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1CapitalDepositSubAddressGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subAddress"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalDepositSubHisrecGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	coin *string
	status *int32
	startTime *int64
	endTime *int64
	limit *int64
	offset *int32
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Email(email string) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Timestamp(timestamp int64) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Signature(signature string) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.signature = &signature
	return r
}
// Coin name
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Coin(coin string) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.coin = &coin
	return r
}
// 0(0:pending,6: credited but cannot withdraw, 1:success)
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Status(status int32) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.status = &status
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) StartTime(startTime int64) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) EndTime(endTime int64) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Limit(limit int64) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.limit = &limit
	return r
}
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Offset(offset int32) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.offset = &offset
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalDepositSubHisrecGetRequest) Execute() ([]InlineResponse20054, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalDepositSubHisrecGetExecute(r)
}

/*
SapiV1CapitalDepositSubHisrecGet Sub-account Deposit History (For Master Account)

Fetch sub-account deposit history

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalDepositSubHisrecGetRequest
*/
func (a *SubAccountApiService) SapiV1CapitalDepositSubHisrecGet(ctx _context.Context) ApiSapiV1CapitalDepositSubHisrecGetRequest {
	return ApiSapiV1CapitalDepositSubHisrecGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20054
func (a *SubAccountApiService) SapiV1CapitalDepositSubHisrecGetExecute(r ApiSapiV1CapitalDepositSubHisrecGetRequest) ([]InlineResponse20054, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20054
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1CapitalDepositSubHisrecGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/subHisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.coin != nil {
		localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1ManagedSubaccountAssetGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1ManagedSubaccountAssetGetRequest) Email(email string) ApiSapiV1ManagedSubaccountAssetGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1ManagedSubaccountAssetGetRequest) Timestamp(timestamp int64) ApiSapiV1ManagedSubaccountAssetGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1ManagedSubaccountAssetGetRequest) Signature(signature string) ApiSapiV1ManagedSubaccountAssetGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1ManagedSubaccountAssetGetRequest) RecvWindow(recvWindow int64) ApiSapiV1ManagedSubaccountAssetGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1ManagedSubaccountAssetGetRequest) Execute() ([]InlineResponse20069, *_nethttp.Response, error) {
	return r.ApiService.SapiV1ManagedSubaccountAssetGetExecute(r)
}

/*
SapiV1ManagedSubaccountAssetGet Managed sub-account asset details（For Investor Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1ManagedSubaccountAssetGetRequest
*/
func (a *SubAccountApiService) SapiV1ManagedSubaccountAssetGet(ctx _context.Context) ApiSapiV1ManagedSubaccountAssetGetRequest {
	return ApiSapiV1ManagedSubaccountAssetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20069
func (a *SubAccountApiService) SapiV1ManagedSubaccountAssetGetExecute(r ApiSapiV1ManagedSubaccountAssetGetRequest) ([]InlineResponse20069, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20069
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1ManagedSubaccountAssetGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1ManagedSubaccountDepositPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	toEmail *string
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Recipient email
func (r ApiSapiV1ManagedSubaccountDepositPostRequest) ToEmail(toEmail string) ApiSapiV1ManagedSubaccountDepositPostRequest {
	r.toEmail = &toEmail
	return r
}
func (r ApiSapiV1ManagedSubaccountDepositPostRequest) Asset(asset string) ApiSapiV1ManagedSubaccountDepositPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1ManagedSubaccountDepositPostRequest) Amount(amount float64) ApiSapiV1ManagedSubaccountDepositPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1ManagedSubaccountDepositPostRequest) Timestamp(timestamp int64) ApiSapiV1ManagedSubaccountDepositPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1ManagedSubaccountDepositPostRequest) Signature(signature string) ApiSapiV1ManagedSubaccountDepositPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1ManagedSubaccountDepositPostRequest) RecvWindow(recvWindow int64) ApiSapiV1ManagedSubaccountDepositPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1ManagedSubaccountDepositPostRequest) Execute() (InlineResponse20068, *_nethttp.Response, error) {
	return r.ApiService.SapiV1ManagedSubaccountDepositPostExecute(r)
}

/*
SapiV1ManagedSubaccountDepositPost Deposit assets into the managed sub-account（For Investor Master Account）

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1ManagedSubaccountDepositPostRequest
*/
func (a *SubAccountApiService) SapiV1ManagedSubaccountDepositPost(ctx _context.Context) ApiSapiV1ManagedSubaccountDepositPostRequest {
	return ApiSapiV1ManagedSubaccountDepositPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20068
func (a *SubAccountApiService) SapiV1ManagedSubaccountDepositPostExecute(r ApiSapiV1ManagedSubaccountDepositPostRequest) (InlineResponse20068, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20068
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1ManagedSubaccountDepositPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/deposit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1ManagedSubaccountWithdrawPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	fromEmail *string
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	transferDate *int64
	recvWindow *int64
}

// Sender email
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) FromEmail(fromEmail string) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.fromEmail = &fromEmail
	return r
}
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) Asset(asset string) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) Amount(amount float64) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) Timestamp(timestamp int64) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) Signature(signature string) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.signature = &signature
	return r
}
// Withdrawals is automatically occur on the transfer date(UTC0). If a date is not selected, the withdrawal occurs right now
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) TransferDate(transferDate int64) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.transferDate = &transferDate
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) RecvWindow(recvWindow int64) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1ManagedSubaccountWithdrawPostRequest) Execute() (InlineResponse20068, *_nethttp.Response, error) {
	return r.ApiService.SapiV1ManagedSubaccountWithdrawPostExecute(r)
}

/*
SapiV1ManagedSubaccountWithdrawPost Withdrawl assets from the managed sub-account（For Investor Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1ManagedSubaccountWithdrawPostRequest
*/
func (a *SubAccountApiService) SapiV1ManagedSubaccountWithdrawPost(ctx _context.Context) ApiSapiV1ManagedSubaccountWithdrawPostRequest {
	return ApiSapiV1ManagedSubaccountWithdrawPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20068
func (a *SubAccountApiService) SapiV1ManagedSubaccountWithdrawPostExecute(r ApiSapiV1ManagedSubaccountWithdrawPostRequest) (InlineResponse20068, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20068
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1ManagedSubaccountWithdrawPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/managed-subaccount/withdraw"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.transferDate != nil {
		localVarQueryParams.Add("transferDate", parameterToString(*r.transferDate, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountBlvtEnablePostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	enableBlvt *bool
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountBlvtEnablePostRequest) Email(email string) ApiSapiV1SubAccountBlvtEnablePostRequest {
	r.email = &email
	return r
}
// Only true for now
func (r ApiSapiV1SubAccountBlvtEnablePostRequest) EnableBlvt(enableBlvt bool) ApiSapiV1SubAccountBlvtEnablePostRequest {
	r.enableBlvt = &enableBlvt
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountBlvtEnablePostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountBlvtEnablePostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountBlvtEnablePostRequest) Signature(signature string) ApiSapiV1SubAccountBlvtEnablePostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountBlvtEnablePostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountBlvtEnablePostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountBlvtEnablePostRequest) Execute() (InlineResponse20067, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountBlvtEnablePostExecute(r)
}

/*
SapiV1SubAccountBlvtEnablePost Enable Leverage Token for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountBlvtEnablePostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountBlvtEnablePost(ctx _context.Context) ApiSapiV1SubAccountBlvtEnablePostRequest {
	return ApiSapiV1SubAccountBlvtEnablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20067
func (a *SubAccountApiService) SapiV1SubAccountBlvtEnablePostExecute(r ApiSapiV1SubAccountBlvtEnablePostRequest) (InlineResponse20067, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20067
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountBlvtEnablePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/blvt/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.enableBlvt == nil {
		return localVarReturnValue, nil, reportError("enableBlvt is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("enableBlvt", parameterToString(*r.enableBlvt, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesAccountGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountFuturesAccountGetRequest) Email(email string) ApiSapiV1SubAccountFuturesAccountGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesAccountGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesAccountGetRequest) Signature(signature string) ApiSapiV1SubAccountFuturesAccountGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesAccountGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesAccountGetRequest) Execute() (InlineResponse20060, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesAccountGetExecute(r)
}

/*
SapiV1SubAccountFuturesAccountGet Detail on Sub-account's Futures Account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesAccountGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesAccountGet(ctx _context.Context) ApiSapiV1SubAccountFuturesAccountGetRequest {
	return ApiSapiV1SubAccountFuturesAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20060
func (a *SubAccountApiService) SapiV1SubAccountFuturesAccountGetExecute(r ApiSapiV1SubAccountFuturesAccountGetRequest) (InlineResponse20060, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20060
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesAccountSummaryGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesAccountSummaryGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesAccountSummaryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesAccountSummaryGetRequest) Signature(signature string) ApiSapiV1SubAccountFuturesAccountSummaryGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesAccountSummaryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesAccountSummaryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesAccountSummaryGetRequest) Execute() (InlineResponse20061, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesAccountSummaryGetExecute(r)
}

/*
SapiV1SubAccountFuturesAccountSummaryGet Summary of Sub-account's Futures Account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesAccountSummaryGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesAccountSummaryGet(ctx _context.Context) ApiSapiV1SubAccountFuturesAccountSummaryGetRequest {
	return ApiSapiV1SubAccountFuturesAccountSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20061
func (a *SubAccountApiService) SapiV1SubAccountFuturesAccountSummaryGetExecute(r ApiSapiV1SubAccountFuturesAccountSummaryGetRequest) (InlineResponse20061, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20061
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesAccountSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesEnablePostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountFuturesEnablePostRequest) Email(email string) ApiSapiV1SubAccountFuturesEnablePostRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesEnablePostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesEnablePostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesEnablePostRequest) Signature(signature string) ApiSapiV1SubAccountFuturesEnablePostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesEnablePostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesEnablePostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesEnablePostRequest) Execute() (InlineResponse20059, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesEnablePostExecute(r)
}

/*
SapiV1SubAccountFuturesEnablePost Enable Futures for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesEnablePostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesEnablePost(ctx _context.Context) ApiSapiV1SubAccountFuturesEnablePostRequest {
	return ApiSapiV1SubAccountFuturesEnablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20059
func (a *SubAccountApiService) SapiV1SubAccountFuturesEnablePostExecute(r ApiSapiV1SubAccountFuturesEnablePostRequest) (InlineResponse20059, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20059
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesEnablePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesInternalTransferGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	futuresType *int32
	timestamp *int64
	signature *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) Email(email string) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.email = &email
	return r
}
// 1:USDT-margined Futures, 2: Coin-margined Futures
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) FuturesType(futuresType int32) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.futuresType = &futuresType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) Signature(signature string) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.signature = &signature
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) StartTime(startTime int64) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) EndTime(endTime int64) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.endTime = &endTime
	return r
}
// Default 1
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) Page(page int32) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.page = &page
	return r
}
// Default value: 50, Max value: 500
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) Limit(limit int32) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) Execute() (InlineResponse20049, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesInternalTransferGetExecute(r)
}

/*
SapiV1SubAccountFuturesInternalTransferGet Sub-account Futures Asset Transfer History (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesInternalTransferGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesInternalTransferGet(ctx _context.Context) ApiSapiV1SubAccountFuturesInternalTransferGetRequest {
	return ApiSapiV1SubAccountFuturesInternalTransferGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20049
func (a *SubAccountApiService) SapiV1SubAccountFuturesInternalTransferGetExecute(r ApiSapiV1SubAccountFuturesInternalTransferGetRequest) (InlineResponse20049, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20049
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesInternalTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesInternalTransferPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	fromEmail *string
	toEmail *string
	futuresType *int32
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sender email
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) FromEmail(fromEmail string) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.fromEmail = &fromEmail
	return r
}
// Recipient email
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) ToEmail(toEmail string) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.toEmail = &toEmail
	return r
}
// 1:USDT-margined Futures,2: Coin-margined Futures
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) FuturesType(futuresType int32) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.futuresType = &futuresType
	return r
}
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) Asset(asset string) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) Amount(amount float64) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) Signature(signature string) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) Execute() (InlineResponse20050, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesInternalTransferPostExecute(r)
}

/*
SapiV1SubAccountFuturesInternalTransferPost Sub-account Futures Asset Transfer (For Master Account)

- Master account can transfer max 2000 times a minute

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesInternalTransferPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesInternalTransferPost(ctx _context.Context) ApiSapiV1SubAccountFuturesInternalTransferPostRequest {
	return ApiSapiV1SubAccountFuturesInternalTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20050
func (a *SubAccountApiService) SapiV1SubAccountFuturesInternalTransferPostExecute(r ApiSapiV1SubAccountFuturesInternalTransferPostRequest) (InlineResponse20050, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20050
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesInternalTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/internalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fromEmail == nil {
		return localVarReturnValue, nil, reportError("fromEmail is required and must be specified")
	}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesPositionRiskGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountFuturesPositionRiskGetRequest) Email(email string) ApiSapiV1SubAccountFuturesPositionRiskGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesPositionRiskGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesPositionRiskGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesPositionRiskGetRequest) Signature(signature string) ApiSapiV1SubAccountFuturesPositionRiskGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesPositionRiskGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesPositionRiskGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesPositionRiskGetRequest) Execute() ([]InlineResponse20062, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesPositionRiskGetExecute(r)
}

/*
SapiV1SubAccountFuturesPositionRiskGet Futures Position-Risk of Sub-account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesPositionRiskGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesPositionRiskGet(ctx _context.Context) ApiSapiV1SubAccountFuturesPositionRiskGetRequest {
	return ApiSapiV1SubAccountFuturesPositionRiskGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20062
func (a *SubAccountApiService) SapiV1SubAccountFuturesPositionRiskGetExecute(r ApiSapiV1SubAccountFuturesPositionRiskGetRequest) ([]InlineResponse20062, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20062
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesPositionRiskGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountFuturesTransferPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	asset *string
	amount *float64
	type_ *int32
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Email(email string) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.email = &email
	return r
}
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Asset(asset string) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Amount(amount float64) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.amount = &amount
	return r
}
// 1: transfer from subaccount&#39;s spot account to its USDT-margined futures account  2: transfer from subaccount&#39;s USDT-margined futures account to its spot account  3: transfer from subaccount&#39;s spot account to its COIN-margined futures account  4:transfer from subaccount&#39;s COIN-margined futures account to its spot account
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Type_(type_ int32) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Signature(signature string) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountFuturesTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountFuturesTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountFuturesTransferPostRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountFuturesTransferPostExecute(r)
}

/*
SapiV1SubAccountFuturesTransferPost Transfer for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountFuturesTransferPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountFuturesTransferPost(ctx _context.Context) ApiSapiV1SubAccountFuturesTransferPostRequest {
	return ApiSapiV1SubAccountFuturesTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SapiV1SubAccountFuturesTransferPostExecute(r ApiSapiV1SubAccountFuturesTransferPostRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountFuturesTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/futures/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountListGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	email *string
	isFreeze *string
	page *int32
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountListGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountListGetRequest) Signature(signature string) ApiSapiV1SubAccountListGetRequest {
	r.signature = &signature
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountListGetRequest) Email(email string) ApiSapiV1SubAccountListGetRequest {
	r.email = &email
	return r
}
func (r ApiSapiV1SubAccountListGetRequest) IsFreeze(isFreeze string) ApiSapiV1SubAccountListGetRequest {
	r.isFreeze = &isFreeze
	return r
}
// Default 1
func (r ApiSapiV1SubAccountListGetRequest) Page(page int32) ApiSapiV1SubAccountListGetRequest {
	r.page = &page
	return r
}
// Default 1; max 200
func (r ApiSapiV1SubAccountListGetRequest) Limit(limit int32) ApiSapiV1SubAccountListGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountListGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountListGetRequest) Execute() (InlineResponse20047, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountListGetExecute(r)
}

/*
SapiV1SubAccountListGet Query Sub-account List (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountListGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountListGet(ctx _context.Context) ApiSapiV1SubAccountListGetRequest {
	return ApiSapiV1SubAccountListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20047
func (a *SubAccountApiService) SapiV1SubAccountListGetExecute(r ApiSapiV1SubAccountListGetRequest) (InlineResponse20047, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20047
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.isFreeze != nil {
		localVarQueryParams.Add("isFreeze", parameterToString(*r.isFreeze, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountMarginAccountGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountMarginAccountGetRequest) Email(email string) ApiSapiV1SubAccountMarginAccountGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountMarginAccountGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountMarginAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountMarginAccountGetRequest) Signature(signature string) ApiSapiV1SubAccountMarginAccountGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountMarginAccountGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountMarginAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountMarginAccountGetRequest) Execute() (InlineResponse20057, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountMarginAccountGetExecute(r)
}

/*
SapiV1SubAccountMarginAccountGet Detail on Sub-account's Margin Account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountMarginAccountGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountMarginAccountGet(ctx _context.Context) ApiSapiV1SubAccountMarginAccountGetRequest {
	return ApiSapiV1SubAccountMarginAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20057
func (a *SubAccountApiService) SapiV1SubAccountMarginAccountGetExecute(r ApiSapiV1SubAccountMarginAccountGetRequest) (InlineResponse20057, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20057
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountMarginAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountMarginAccountSummaryGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountMarginAccountSummaryGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountMarginAccountSummaryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountMarginAccountSummaryGetRequest) Signature(signature string) ApiSapiV1SubAccountMarginAccountSummaryGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountMarginAccountSummaryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountMarginAccountSummaryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountMarginAccountSummaryGetRequest) Execute() (InlineResponse20058, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountMarginAccountSummaryGetExecute(r)
}

/*
SapiV1SubAccountMarginAccountSummaryGet Summary of Sub-account's Margin Account (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountMarginAccountSummaryGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountMarginAccountSummaryGet(ctx _context.Context) ApiSapiV1SubAccountMarginAccountSummaryGetRequest {
	return ApiSapiV1SubAccountMarginAccountSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20058
func (a *SubAccountApiService) SapiV1SubAccountMarginAccountSummaryGetExecute(r ApiSapiV1SubAccountMarginAccountSummaryGetRequest) (InlineResponse20058, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20058
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountMarginAccountSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountMarginEnablePostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountMarginEnablePostRequest) Email(email string) ApiSapiV1SubAccountMarginEnablePostRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountMarginEnablePostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountMarginEnablePostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountMarginEnablePostRequest) Signature(signature string) ApiSapiV1SubAccountMarginEnablePostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountMarginEnablePostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountMarginEnablePostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountMarginEnablePostRequest) Execute() (InlineResponse20056, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountMarginEnablePostExecute(r)
}

/*
SapiV1SubAccountMarginEnablePost Enable Margin for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountMarginEnablePostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountMarginEnablePost(ctx _context.Context) ApiSapiV1SubAccountMarginEnablePostRequest {
	return ApiSapiV1SubAccountMarginEnablePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20056
func (a *SubAccountApiService) SapiV1SubAccountMarginEnablePostExecute(r ApiSapiV1SubAccountMarginEnablePostRequest) (InlineResponse20056, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20056
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountMarginEnablePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/enable"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountMarginTransferPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	asset *string
	amount *float64
	type_ *int32
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountMarginTransferPostRequest) Email(email string) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.email = &email
	return r
}
func (r ApiSapiV1SubAccountMarginTransferPostRequest) Asset(asset string) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1SubAccountMarginTransferPostRequest) Amount(amount float64) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.amount = &amount
	return r
}
// 1: transfer from subaccount&#39;s spot account to margin account  2: transfer from subaccount&#39;s margin account to its spot account
func (r ApiSapiV1SubAccountMarginTransferPostRequest) Type_(type_ int32) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountMarginTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountMarginTransferPostRequest) Signature(signature string) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountMarginTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountMarginTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountMarginTransferPostRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountMarginTransferPostExecute(r)
}

/*
SapiV1SubAccountMarginTransferPost Margin Transfer for Sub-account (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountMarginTransferPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountMarginTransferPost(ctx _context.Context) ApiSapiV1SubAccountMarginTransferPostRequest {
	return ApiSapiV1SubAccountMarginTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SapiV1SubAccountMarginTransferPostExecute(r ApiSapiV1SubAccountMarginTransferPostRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountMarginTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/margin/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountSpotSummaryGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	page *int32
	size *int32
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV1SubAccountSpotSummaryGetRequest) Email(email string) ApiSapiV1SubAccountSpotSummaryGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountSpotSummaryGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountSpotSummaryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountSpotSummaryGetRequest) Signature(signature string) ApiSapiV1SubAccountSpotSummaryGetRequest {
	r.signature = &signature
	return r
}
// Default 1
func (r ApiSapiV1SubAccountSpotSummaryGetRequest) Page(page int32) ApiSapiV1SubAccountSpotSummaryGetRequest {
	r.page = &page
	return r
}
// Default:10 Max:20
func (r ApiSapiV1SubAccountSpotSummaryGetRequest) Size(size int32) ApiSapiV1SubAccountSpotSummaryGetRequest {
	r.size = &size
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountSpotSummaryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountSpotSummaryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountSpotSummaryGetRequest) Execute() (InlineResponse20052, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountSpotSummaryGetExecute(r)
}

/*
SapiV1SubAccountSpotSummaryGet Sub-account Spot Assets Summary (For Master Account)

Get BTC valued asset summary of subaccounts.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountSpotSummaryGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountSpotSummaryGet(ctx _context.Context) ApiSapiV1SubAccountSpotSummaryGetRequest {
	return ApiSapiV1SubAccountSpotSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20052
func (a *SubAccountApiService) SapiV1SubAccountSpotSummaryGetExecute(r ApiSapiV1SubAccountSpotSummaryGetRequest) (InlineResponse20052, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20052
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountSpotSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/spotSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountStatusGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	email *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountStatusGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountStatusGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountStatusGetRequest) Signature(signature string) ApiSapiV1SubAccountStatusGetRequest {
	r.signature = &signature
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountStatusGetRequest) Email(email string) ApiSapiV1SubAccountStatusGetRequest {
	r.email = &email
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountStatusGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountStatusGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountStatusGetRequest) Execute() ([]InlineResponse20055, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountStatusGetExecute(r)
}

/*
SapiV1SubAccountStatusGet Sub-account's Status on Margin/Futures (For Master Account)

- If no `email` sent, all sub-accounts' information will be returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountStatusGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountStatusGet(ctx _context.Context) ApiSapiV1SubAccountStatusGetRequest {
	return ApiSapiV1SubAccountStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20055
func (a *SubAccountApiService) SapiV1SubAccountStatusGetExecute(r ApiSapiV1SubAccountStatusGetRequest) ([]InlineResponse20055, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20055
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountStatusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.email != nil {
		localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountSubTransferHistoryGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	fromEmail *string
	toEmail *string
	startTime *int64
	endTime *int64
	page *int32
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) Signature(signature string) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.signature = &signature
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) FromEmail(fromEmail string) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.fromEmail = &fromEmail
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) ToEmail(toEmail string) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.toEmail = &toEmail
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) StartTime(startTime int64) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) EndTime(endTime int64) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.endTime = &endTime
	return r
}
// Default 1
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) Page(page int32) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.page = &page
	return r
}
// Default 1
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) Limit(limit int32) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountSubTransferHistoryGetRequest) Execute() ([]InlineResponse20048, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountSubTransferHistoryGetExecute(r)
}

/*
SapiV1SubAccountSubTransferHistoryGet Sub-account Spot Asset Transfer History (For Master Account)

- fromEmail and toEmail cannot be sent at the same time.
- Return fromEmail equal master account email by default.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountSubTransferHistoryGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountSubTransferHistoryGet(ctx _context.Context) ApiSapiV1SubAccountSubTransferHistoryGetRequest {
	return ApiSapiV1SubAccountSubTransferHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20048
func (a *SubAccountApiService) SapiV1SubAccountSubTransferHistoryGetExecute(r ApiSapiV1SubAccountSubTransferHistoryGetRequest) ([]InlineResponse20048, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20048
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountSubTransferHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/sub/transfer/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromEmail != nil {
		localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	}
	if r.toEmail != nil {
		localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountTransferSubToMasterPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1SubAccountTransferSubToMasterPostRequest) Asset(asset string) ApiSapiV1SubAccountTransferSubToMasterPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1SubAccountTransferSubToMasterPostRequest) Amount(amount float64) ApiSapiV1SubAccountTransferSubToMasterPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountTransferSubToMasterPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountTransferSubToMasterPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountTransferSubToMasterPostRequest) Signature(signature string) ApiSapiV1SubAccountTransferSubToMasterPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountTransferSubToMasterPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountTransferSubToMasterPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountTransferSubToMasterPostRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountTransferSubToMasterPostExecute(r)
}

/*
SapiV1SubAccountTransferSubToMasterPost Transfer to Master (For Sub-account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountTransferSubToMasterPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountTransferSubToMasterPost(ctx _context.Context) ApiSapiV1SubAccountTransferSubToMasterPostRequest {
	return ApiSapiV1SubAccountTransferSubToMasterPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SapiV1SubAccountTransferSubToMasterPostExecute(r ApiSapiV1SubAccountTransferSubToMasterPostRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountTransferSubToMasterPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToMaster"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountTransferSubToSubPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	toEmail *string
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Recipient email
func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) ToEmail(toEmail string) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	r.toEmail = &toEmail
	return r
}
func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) Asset(asset string) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) Amount(amount float64) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) Signature(signature string) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountTransferSubToSubPostRequest) Execute() (InlineResponse20063, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountTransferSubToSubPostExecute(r)
}

/*
SapiV1SubAccountTransferSubToSubPost Transfer to Sub-account of Same Master (For Sub-account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountTransferSubToSubPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountTransferSubToSubPost(ctx _context.Context) ApiSapiV1SubAccountTransferSubToSubPostRequest {
	return ApiSapiV1SubAccountTransferSubToSubPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20063
func (a *SubAccountApiService) SapiV1SubAccountTransferSubToSubPostExecute(r ApiSapiV1SubAccountTransferSubToSubPostRequest) (InlineResponse20063, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20063
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountTransferSubToSubPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subToSub"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.toEmail == nil {
		return localVarReturnValue, nil, reportError("toEmail is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountTransferSubUserHistoryGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	asset *string
	type_ *int32
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) Signature(signature string) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) Asset(asset string) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.asset = &asset
	return r
}
// 1: transfer in  2:  transfer out
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) Type_(type_ int32) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) StartTime(startTime int64) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) EndTime(endTime int64) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.endTime = &endTime
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) Limit(limit int32) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) Execute() ([]InlineResponse20064, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountTransferSubUserHistoryGetExecute(r)
}

/*
SapiV1SubAccountTransferSubUserHistoryGet Sub-account Transfer History (For Sub-account)

- If `type` is not sent, the records of type 2: transfer out will be returned by default.
- If `startTime` and `endTime` are not sent, the recent 30-day data will be returned.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountTransferSubUserHistoryGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountTransferSubUserHistoryGet(ctx _context.Context) ApiSapiV1SubAccountTransferSubUserHistoryGetRequest {
	return ApiSapiV1SubAccountTransferSubUserHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20064
func (a *SubAccountApiService) SapiV1SubAccountTransferSubUserHistoryGetExecute(r ApiSapiV1SubAccountTransferSubUserHistoryGetRequest) ([]InlineResponse20064, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20064
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountTransferSubUserHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/transfer/subUserHistory"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.type_ != nil {
		localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountUniversalTransferGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	timestamp *int64
	signature *string
	fromEmail *string
	toEmail *string
	startTime *int64
	endTime *int64
	page *int32
	limit *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) Signature(signature string) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.signature = &signature
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) FromEmail(fromEmail string) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.fromEmail = &fromEmail
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) ToEmail(toEmail string) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.toEmail = &toEmail
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) StartTime(startTime int64) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) EndTime(endTime int64) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.endTime = &endTime
	return r
}
// Default 1
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) Page(page int32) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.page = &page
	return r
}
// Default 500, Max 500
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) Limit(limit string) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountUniversalTransferGetRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountUniversalTransferGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountUniversalTransferGetRequest) Execute() ([]InlineResponse20065, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountUniversalTransferGetExecute(r)
}

/*
SapiV1SubAccountUniversalTransferGet Universal Transfer History (For Master Account)

- fromEmail and toEmail cannot be sent at the same time.
- Return fromEmail equal master account email by default.
- Only get the latest history of past 30 days.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountUniversalTransferGetRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountUniversalTransferGet(ctx _context.Context) ApiSapiV1SubAccountUniversalTransferGetRequest {
	return ApiSapiV1SubAccountUniversalTransferGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20065
func (a *SubAccountApiService) SapiV1SubAccountUniversalTransferGetExecute(r ApiSapiV1SubAccountUniversalTransferGetRequest) ([]InlineResponse20065, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20065
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountUniversalTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromEmail != nil {
		localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	}
	if r.toEmail != nil {
		localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountUniversalTransferPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	fromAccountType *string
	toAccountType *string
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	fromEmail *string
	toEmail *string
	recvWindow *int64
}

func (r ApiSapiV1SubAccountUniversalTransferPostRequest) FromAccountType(fromAccountType string) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.fromAccountType = &fromAccountType
	return r
}
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) ToAccountType(toAccountType string) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.toAccountType = &toAccountType
	return r
}
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) Asset(asset string) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) Amount(amount float64) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) Signature(signature string) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.signature = &signature
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) FromEmail(fromEmail string) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.fromEmail = &fromEmail
	return r
}
// Sub-account email
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) ToEmail(toEmail string) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.toEmail = &toEmail
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountUniversalTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountUniversalTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountUniversalTransferPostRequest) Execute() (InlineResponse20066, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountUniversalTransferPostExecute(r)
}

/*
SapiV1SubAccountUniversalTransferPost Universal Transfer (For Master Account)

- You need to enable "internal transfer" option for the api key which requests this endpoint.
- Transfer from master account by default if fromEmail is not sent.
- Transfer to master account by default if toEmail is not sent.
- Transfer between futures accounts is not supported.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountUniversalTransferPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountUniversalTransferPost(ctx _context.Context) ApiSapiV1SubAccountUniversalTransferPostRequest {
	return ApiSapiV1SubAccountUniversalTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20066
func (a *SubAccountApiService) SapiV1SubAccountUniversalTransferPostExecute(r ApiSapiV1SubAccountUniversalTransferPostRequest) (InlineResponse20066, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20066
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountUniversalTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/universalTransfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.fromAccountType == nil {
		return localVarReturnValue, nil, reportError("fromAccountType is required and must be specified")
	}
	if r.toAccountType == nil {
		return localVarReturnValue, nil, reportError("toAccountType is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromEmail != nil {
		localVarQueryParams.Add("fromEmail", parameterToString(*r.fromEmail, ""))
	}
	if r.toEmail != nil {
		localVarQueryParams.Add("toEmail", parameterToString(*r.toEmail, ""))
	}
	localVarQueryParams.Add("fromAccountType", parameterToString(*r.fromAccountType, ""))
	localVarQueryParams.Add("toAccountType", parameterToString(*r.toAccountType, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SubAccountVirtualSubAccountPostRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	subAccountString *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Please input a string. We will create a virtual email using that string for you to register
func (r ApiSapiV1SubAccountVirtualSubAccountPostRequest) SubAccountString(subAccountString string) ApiSapiV1SubAccountVirtualSubAccountPostRequest {
	r.subAccountString = &subAccountString
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1SubAccountVirtualSubAccountPostRequest) Timestamp(timestamp int64) ApiSapiV1SubAccountVirtualSubAccountPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1SubAccountVirtualSubAccountPostRequest) Signature(signature string) ApiSapiV1SubAccountVirtualSubAccountPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1SubAccountVirtualSubAccountPostRequest) RecvWindow(recvWindow int64) ApiSapiV1SubAccountVirtualSubAccountPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1SubAccountVirtualSubAccountPostRequest) Execute() (InlineResponse20046, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SubAccountVirtualSubAccountPostExecute(r)
}

/*
SapiV1SubAccountVirtualSubAccountPost Create a Virtual Sub-account(For Master Account)

- This request will generate a virtual sub account under your master account.
- You need to enable "trade" option for the api key which requests this endpoint.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SubAccountVirtualSubAccountPostRequest
*/
func (a *SubAccountApiService) SapiV1SubAccountVirtualSubAccountPost(ctx _context.Context) ApiSapiV1SubAccountVirtualSubAccountPostRequest {
	return ApiSapiV1SubAccountVirtualSubAccountPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20046
func (a *SubAccountApiService) SapiV1SubAccountVirtualSubAccountPostExecute(r ApiSapiV1SubAccountVirtualSubAccountPostRequest) (InlineResponse20046, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20046
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV1SubAccountVirtualSubAccountPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/sub-account/virtualSubAccount"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.subAccountString == nil {
		return localVarReturnValue, nil, reportError("subAccountString is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("subAccountString", parameterToString(*r.subAccountString, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV2SubAccountFuturesAccountGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	futuresType *int32
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV2SubAccountFuturesAccountGetRequest) Email(email string) ApiSapiV2SubAccountFuturesAccountGetRequest {
	r.email = &email
	return r
}
// 1:USDT Margined Futures  2:COIN Margined Futures
func (r ApiSapiV2SubAccountFuturesAccountGetRequest) FuturesType(futuresType int32) ApiSapiV2SubAccountFuturesAccountGetRequest {
	r.futuresType = &futuresType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV2SubAccountFuturesAccountGetRequest) Timestamp(timestamp int64) ApiSapiV2SubAccountFuturesAccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV2SubAccountFuturesAccountGetRequest) Signature(signature string) ApiSapiV2SubAccountFuturesAccountGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV2SubAccountFuturesAccountGetRequest) RecvWindow(recvWindow int64) ApiSapiV2SubAccountFuturesAccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV2SubAccountFuturesAccountGetRequest) Execute() (OneOfsubAccountUSDTFuturesDetailssubAccountCOINFuturesDetails, *_nethttp.Response, error) {
	return r.ApiService.SapiV2SubAccountFuturesAccountGetExecute(r)
}

/*
SapiV2SubAccountFuturesAccountGet Detail on Sub-account's Futures Account V2 (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV2SubAccountFuturesAccountGetRequest
*/
func (a *SubAccountApiService) SapiV2SubAccountFuturesAccountGet(ctx _context.Context) ApiSapiV2SubAccountFuturesAccountGetRequest {
	return ApiSapiV2SubAccountFuturesAccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfsubAccountUSDTFuturesDetailssubAccountCOINFuturesDetails
func (a *SubAccountApiService) SapiV2SubAccountFuturesAccountGetExecute(r ApiSapiV2SubAccountFuturesAccountGetRequest) (OneOfsubAccountUSDTFuturesDetailssubAccountCOINFuturesDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfsubAccountUSDTFuturesDetailssubAccountCOINFuturesDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV2SubAccountFuturesAccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV2SubAccountFuturesAccountSummaryGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	futuresType *int32
	timestamp *int64
	signature *string
	page *int32
	limit *string
	recvWindow *int64
}

// 1:USDT Margined Futures  2:COIN Margined Futures
func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) FuturesType(futuresType int32) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	r.futuresType = &futuresType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) Timestamp(timestamp int64) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) Signature(signature string) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	r.signature = &signature
	return r
}
// Default 1
func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) Page(page int32) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	r.page = &page
	return r
}
// Default 10, Max 20
func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) Limit(limit string) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) RecvWindow(recvWindow int64) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) Execute() (OneOfsubAccountUSDTFuturesSummarysubAccountCOINFuturesSummary, *_nethttp.Response, error) {
	return r.ApiService.SapiV2SubAccountFuturesAccountSummaryGetExecute(r)
}

/*
SapiV2SubAccountFuturesAccountSummaryGet Summary of Sub-account's Futures Account V2 (For Master Account)

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV2SubAccountFuturesAccountSummaryGetRequest
*/
func (a *SubAccountApiService) SapiV2SubAccountFuturesAccountSummaryGet(ctx _context.Context) ApiSapiV2SubAccountFuturesAccountSummaryGetRequest {
	return ApiSapiV2SubAccountFuturesAccountSummaryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfsubAccountUSDTFuturesSummarysubAccountCOINFuturesSummary
func (a *SubAccountApiService) SapiV2SubAccountFuturesAccountSummaryGetExecute(r ApiSapiV2SubAccountFuturesAccountSummaryGetRequest) (OneOfsubAccountUSDTFuturesSummarysubAccountCOINFuturesSummary, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfsubAccountUSDTFuturesSummarysubAccountCOINFuturesSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV2SubAccountFuturesAccountSummaryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/accountSummary"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.page != nil {
		localVarQueryParams.Add("page", parameterToString(*r.page, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV2SubAccountFuturesPositionRiskGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	futuresType *int32
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) Email(email string) ApiSapiV2SubAccountFuturesPositionRiskGetRequest {
	r.email = &email
	return r
}
// 1:USDT Margined Futures  2:COIN Margined Futures
func (r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) FuturesType(futuresType int32) ApiSapiV2SubAccountFuturesPositionRiskGetRequest {
	r.futuresType = &futuresType
	return r
}
// UTC timestamp in ms
func (r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) Timestamp(timestamp int64) ApiSapiV2SubAccountFuturesPositionRiskGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) Signature(signature string) ApiSapiV2SubAccountFuturesPositionRiskGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) RecvWindow(recvWindow int64) ApiSapiV2SubAccountFuturesPositionRiskGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) Execute() (OneOfsubAccountUSDTFuturesPositionRisksubAccountCOINFuturesPositionRisk, *_nethttp.Response, error) {
	return r.ApiService.SapiV2SubAccountFuturesPositionRiskGetExecute(r)
}

/*
SapiV2SubAccountFuturesPositionRiskGet Futures Position-Risk of Sub-account V2 (For Master Account)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV2SubAccountFuturesPositionRiskGetRequest
*/
func (a *SubAccountApiService) SapiV2SubAccountFuturesPositionRiskGet(ctx _context.Context) ApiSapiV2SubAccountFuturesPositionRiskGetRequest {
	return ApiSapiV2SubAccountFuturesPositionRiskGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfsubAccountUSDTFuturesPositionRisksubAccountCOINFuturesPositionRisk
func (a *SubAccountApiService) SapiV2SubAccountFuturesPositionRiskGetExecute(r ApiSapiV2SubAccountFuturesPositionRiskGetRequest) (OneOfsubAccountUSDTFuturesPositionRisksubAccountCOINFuturesPositionRisk, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfsubAccountUSDTFuturesPositionRisksubAccountCOINFuturesPositionRisk
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV2SubAccountFuturesPositionRiskGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v2/sub-account/futures/positionRisk"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.futuresType == nil {
		return localVarReturnValue, nil, reportError("futuresType is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	localVarQueryParams.Add("futuresType", parameterToString(*r.futuresType, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV3SubAccountAssetsGetRequest struct {
	ctx _context.Context
	ApiService *SubAccountApiService
	email *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Sub-account email
func (r ApiSapiV3SubAccountAssetsGetRequest) Email(email string) ApiSapiV3SubAccountAssetsGetRequest {
	r.email = &email
	return r
}
// UTC timestamp in ms
func (r ApiSapiV3SubAccountAssetsGetRequest) Timestamp(timestamp int64) ApiSapiV3SubAccountAssetsGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV3SubAccountAssetsGetRequest) Signature(signature string) ApiSapiV3SubAccountAssetsGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV3SubAccountAssetsGetRequest) RecvWindow(recvWindow int64) ApiSapiV3SubAccountAssetsGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV3SubAccountAssetsGetRequest) Execute() (InlineResponse20051, *_nethttp.Response, error) {
	return r.ApiService.SapiV3SubAccountAssetsGetExecute(r)
}

/*
SapiV3SubAccountAssetsGet Sub-account Assets (For Master Account)

Fetch sub-account assets

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV3SubAccountAssetsGetRequest
*/
func (a *SubAccountApiService) SapiV3SubAccountAssetsGet(ctx _context.Context) ApiSapiV3SubAccountAssetsGetRequest {
	return ApiSapiV3SubAccountAssetsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20051
func (a *SubAccountApiService) SapiV3SubAccountAssetsGetExecute(r ApiSapiV3SubAccountAssetsGetRequest) (InlineResponse20051, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20051
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubAccountApiService.SapiV3SubAccountAssetsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v3/sub-account/assets"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.email == nil {
		return localVarReturnValue, nil, reportError("email is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("email", parameterToString(*r.email, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
