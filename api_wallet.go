/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// WalletApiService WalletApi service
type WalletApiService service

type ApiSapiV1AccountApiRestrictionsGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AccountApiRestrictionsGetRequest) Timestamp(timestamp int64) ApiSapiV1AccountApiRestrictionsGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AccountApiRestrictionsGetRequest) Signature(signature string) ApiSapiV1AccountApiRestrictionsGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AccountApiRestrictionsGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AccountApiRestrictionsGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AccountApiRestrictionsGetRequest) Execute() (InlineResponse20045, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountApiRestrictionsGetExecute(r)
}

/*
SapiV1AccountApiRestrictionsGet Get API Key Permission (USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AccountApiRestrictionsGetRequest
*/
func (a *WalletApiService) SapiV1AccountApiRestrictionsGet(ctx _context.Context) ApiSapiV1AccountApiRestrictionsGetRequest {
	return ApiSapiV1AccountApiRestrictionsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20045
func (a *WalletApiService) SapiV1AccountApiRestrictionsGetExecute(r ApiSapiV1AccountApiRestrictionsGetRequest) (InlineResponse20045, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20045
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountApiRestrictionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/apiRestrictions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AccountApiTradingStatusGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AccountApiTradingStatusGetRequest) Timestamp(timestamp int64) ApiSapiV1AccountApiTradingStatusGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AccountApiTradingStatusGetRequest) Signature(signature string) ApiSapiV1AccountApiTradingStatusGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AccountApiTradingStatusGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AccountApiTradingStatusGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AccountApiTradingStatusGetRequest) Execute() (InlineResponse20036, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountApiTradingStatusGetExecute(r)
}

/*
SapiV1AccountApiTradingStatusGet Account API Trading Status (USER_DATA)

Fetch account API trading status with details.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AccountApiTradingStatusGetRequest
*/
func (a *WalletApiService) SapiV1AccountApiTradingStatusGet(ctx _context.Context) ApiSapiV1AccountApiTradingStatusGetRequest {
	return ApiSapiV1AccountApiTradingStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20036
func (a *WalletApiService) SapiV1AccountApiTradingStatusGetExecute(r ApiSapiV1AccountApiTradingStatusGetRequest) (InlineResponse20036, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20036
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountApiTradingStatusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/apiTradingStatus"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) Timestamp(timestamp int64) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) Signature(signature string) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) RecvWindow(recvWindow int64) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountDisableFastWithdrawSwitchPostExecute(r)
}

/*
SapiV1AccountDisableFastWithdrawSwitchPost Disable Fast Withdraw Switch (USER_DATA)

- This request will disable fastwithdraw switch under your account.
- You need to enable "trade" option for the api key which requests this endpoint.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest
*/
func (a *WalletApiService) SapiV1AccountDisableFastWithdrawSwitchPost(ctx _context.Context) ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest {
	return ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *WalletApiService) SapiV1AccountDisableFastWithdrawSwitchPostExecute(r ApiSapiV1AccountDisableFastWithdrawSwitchPostRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountDisableFastWithdrawSwitchPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/disableFastWithdrawSwitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) Timestamp(timestamp int64) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) Signature(signature string) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) RecvWindow(recvWindow int64) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountEnableFastWithdrawSwitchPostExecute(r)
}

/*
SapiV1AccountEnableFastWithdrawSwitchPost Enable Fast Withdraw Switch (USER_DATA)

- This request will enable fastwithdraw switch under your account. You need to enable "trade" option for the api key which requests this endpoint.
- When Fast Withdraw Switch is on, transferring funds to a Binance account will be done instantly. There is no on-chain transaction, no transaction ID and no withdrawal fee.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest
*/
func (a *WalletApiService) SapiV1AccountEnableFastWithdrawSwitchPost(ctx _context.Context) ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest {
	return ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *WalletApiService) SapiV1AccountEnableFastWithdrawSwitchPostExecute(r ApiSapiV1AccountEnableFastWithdrawSwitchPostRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountEnableFastWithdrawSwitchPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/enableFastWithdrawSwitch"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AccountSnapshotGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	type_ *string
	timestamp *int64
	signature *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

func (r ApiSapiV1AccountSnapshotGetRequest) Type_(type_ string) ApiSapiV1AccountSnapshotGetRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AccountSnapshotGetRequest) Timestamp(timestamp int64) ApiSapiV1AccountSnapshotGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AccountSnapshotGetRequest) Signature(signature string) ApiSapiV1AccountSnapshotGetRequest {
	r.signature = &signature
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AccountSnapshotGetRequest) StartTime(startTime int64) ApiSapiV1AccountSnapshotGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AccountSnapshotGetRequest) EndTime(endTime int64) ApiSapiV1AccountSnapshotGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1AccountSnapshotGetRequest) Limit(limit int32) ApiSapiV1AccountSnapshotGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AccountSnapshotGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AccountSnapshotGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AccountSnapshotGetRequest) Execute() (OneOfsnapshotSpotsnapshotMarginsnapshotFutures, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountSnapshotGetExecute(r)
}

/*
SapiV1AccountSnapshotGet Daily Account Snapshot (USER_DATA)

Weight(IP): 2400

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AccountSnapshotGetRequest
*/
func (a *WalletApiService) SapiV1AccountSnapshotGet(ctx _context.Context) ApiSapiV1AccountSnapshotGetRequest {
	return ApiSapiV1AccountSnapshotGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfsnapshotSpotsnapshotMarginsnapshotFutures
func (a *WalletApiService) SapiV1AccountSnapshotGetExecute(r ApiSapiV1AccountSnapshotGetRequest) (OneOfsnapshotSpotsnapshotMarginsnapshotFutures, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfsnapshotSpotsnapshotMarginsnapshotFutures
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountSnapshotGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/accountSnapshot"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AccountStatusGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AccountStatusGetRequest) Timestamp(timestamp int64) ApiSapiV1AccountStatusGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AccountStatusGetRequest) Signature(signature string) ApiSapiV1AccountStatusGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AccountStatusGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AccountStatusGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AccountStatusGetRequest) Execute() (InlineResponse20035, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AccountStatusGetExecute(r)
}

/*
SapiV1AccountStatusGet Account Status (USER_DATA)

Fetch account status detail.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AccountStatusGetRequest
*/
func (a *WalletApiService) SapiV1AccountStatusGet(ctx _context.Context) ApiSapiV1AccountStatusGetRequest {
	return ApiSapiV1AccountStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20035
func (a *WalletApiService) SapiV1AccountStatusGetExecute(r ApiSapiV1AccountStatusGetRequest) (InlineResponse20035, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20035
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AccountStatusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/account/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetAssetDetailGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	asset *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AssetAssetDetailGetRequest) Timestamp(timestamp int64) ApiSapiV1AssetAssetDetailGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetAssetDetailGetRequest) Signature(signature string) ApiSapiV1AssetAssetDetailGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1AssetAssetDetailGetRequest) Asset(asset string) ApiSapiV1AssetAssetDetailGetRequest {
	r.asset = &asset
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetAssetDetailGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetAssetDetailGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetAssetDetailGetRequest) Execute() (InlineResponse20040, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetAssetDetailGetExecute(r)
}

/*
SapiV1AssetAssetDetailGet Asset Detail (USER_DATA)

Fetch details of assets supported on Binance.

- Please get network and other deposit or withdraw details from `GET /sapi/v1/capital/config/getall`.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetAssetDetailGetRequest
*/
func (a *WalletApiService) SapiV1AssetAssetDetailGet(ctx _context.Context) ApiSapiV1AssetAssetDetailGetRequest {
	return ApiSapiV1AssetAssetDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20040
func (a *WalletApiService) SapiV1AssetAssetDetailGetExecute(r ApiSapiV1AssetAssetDetailGetRequest) (InlineResponse20040, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20040
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetAssetDetailGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDetail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetAssetDividendGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	limit *string
	timestamp *int64
	signature *string
	asset *string
	startTime *int64
	endTime *int64
	recvWindow *int64
}

func (r ApiSapiV1AssetAssetDividendGetRequest) Limit(limit string) ApiSapiV1AssetAssetDividendGetRequest {
	r.limit = &limit
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetAssetDividendGetRequest) Timestamp(timestamp int64) ApiSapiV1AssetAssetDividendGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetAssetDividendGetRequest) Signature(signature string) ApiSapiV1AssetAssetDividendGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1AssetAssetDividendGetRequest) Asset(asset string) ApiSapiV1AssetAssetDividendGetRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetAssetDividendGetRequest) StartTime(startTime int64) ApiSapiV1AssetAssetDividendGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetAssetDividendGetRequest) EndTime(endTime int64) ApiSapiV1AssetAssetDividendGetRequest {
	r.endTime = &endTime
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetAssetDividendGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetAssetDividendGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetAssetDividendGetRequest) Execute() (InlineResponse20039, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetAssetDividendGetExecute(r)
}

/*
SapiV1AssetAssetDividendGet Asset Dividend Record (USER_DATA)

Query asset Dividend Record

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetAssetDividendGetRequest
*/
func (a *WalletApiService) SapiV1AssetAssetDividendGet(ctx _context.Context) ApiSapiV1AssetAssetDividendGetRequest {
	return ApiSapiV1AssetAssetDividendGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20039
func (a *WalletApiService) SapiV1AssetAssetDividendGetExecute(r ApiSapiV1AssetAssetDividendGetRequest) (InlineResponse20039, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20039
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetAssetDividendGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/assetDividend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.limit == nil {
		return localVarReturnValue, nil, reportError("limit is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetDribbletGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	startTime *int64
	endTime *int64
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AssetDribbletGetRequest) Timestamp(timestamp int64) ApiSapiV1AssetDribbletGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetDribbletGetRequest) Signature(signature string) ApiSapiV1AssetDribbletGetRequest {
	r.signature = &signature
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetDribbletGetRequest) StartTime(startTime int64) ApiSapiV1AssetDribbletGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetDribbletGetRequest) EndTime(endTime int64) ApiSapiV1AssetDribbletGetRequest {
	r.endTime = &endTime
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetDribbletGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetDribbletGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetDribbletGetRequest) Execute() (InlineResponse20037, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetDribbletGetExecute(r)
}

/*
SapiV1AssetDribbletGet DustLog(USER_DATA)

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetDribbletGetRequest
*/
func (a *WalletApiService) SapiV1AssetDribbletGet(ctx _context.Context) ApiSapiV1AssetDribbletGetRequest {
	return ApiSapiV1AssetDribbletGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20037
func (a *WalletApiService) SapiV1AssetDribbletGetExecute(r ApiSapiV1AssetDribbletGetRequest) (InlineResponse20037, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20037
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetDribbletGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dribblet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetDustPostRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	asset *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// The asset being converted. For example, asset&#x3D;BTC&amp;asset&#x3D;USDT
func (r ApiSapiV1AssetDustPostRequest) Asset(asset string) ApiSapiV1AssetDustPostRequest {
	r.asset = &asset
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetDustPostRequest) Timestamp(timestamp int64) ApiSapiV1AssetDustPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetDustPostRequest) Signature(signature string) ApiSapiV1AssetDustPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetDustPostRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetDustPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetDustPostRequest) Execute() (InlineResponse20038, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetDustPostExecute(r)
}

/*
SapiV1AssetDustPost Dust Transfer (USER_DATA)

Convert dust assets to BNB.

Weight(UID): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetDustPostRequest
*/
func (a *WalletApiService) SapiV1AssetDustPost(ctx _context.Context) ApiSapiV1AssetDustPostRequest {
	return ApiSapiV1AssetDustPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20038
func (a *WalletApiService) SapiV1AssetDustPostExecute(r ApiSapiV1AssetDustPostRequest) (InlineResponse20038, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20038
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetDustPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/dust"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetGetFundingAssetPostRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	asset *string
	needBtcValuation *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AssetGetFundingAssetPostRequest) Timestamp(timestamp int64) ApiSapiV1AssetGetFundingAssetPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetGetFundingAssetPostRequest) Signature(signature string) ApiSapiV1AssetGetFundingAssetPostRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1AssetGetFundingAssetPostRequest) Asset(asset string) ApiSapiV1AssetGetFundingAssetPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1AssetGetFundingAssetPostRequest) NeedBtcValuation(needBtcValuation string) ApiSapiV1AssetGetFundingAssetPostRequest {
	r.needBtcValuation = &needBtcValuation
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetGetFundingAssetPostRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetGetFundingAssetPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetGetFundingAssetPostRequest) Execute() ([]InlineResponse20044, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetGetFundingAssetPostExecute(r)
}

/*
SapiV1AssetGetFundingAssetPost Funding Wallet (USER_DATA)

- Currently supports querying the following business assetsBinance Pay, Binance Card, Binance Gift Card, Stock Token

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetGetFundingAssetPostRequest
*/
func (a *WalletApiService) SapiV1AssetGetFundingAssetPost(ctx _context.Context) ApiSapiV1AssetGetFundingAssetPostRequest {
	return ApiSapiV1AssetGetFundingAssetPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20044
func (a *WalletApiService) SapiV1AssetGetFundingAssetPostExecute(r ApiSapiV1AssetGetFundingAssetPostRequest) ([]InlineResponse20044, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20044
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetGetFundingAssetPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/get-funding-asset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	if r.needBtcValuation != nil {
		localVarQueryParams.Add("needBtcValuation", parameterToString(*r.needBtcValuation, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetTradeFeeGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	symbol *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1AssetTradeFeeGetRequest) Timestamp(timestamp int64) ApiSapiV1AssetTradeFeeGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetTradeFeeGetRequest) Signature(signature string) ApiSapiV1AssetTradeFeeGetRequest {
	r.signature = &signature
	return r
}
// Trading symbol, e.g. BNBUSDT
func (r ApiSapiV1AssetTradeFeeGetRequest) Symbol(symbol string) ApiSapiV1AssetTradeFeeGetRequest {
	r.symbol = &symbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetTradeFeeGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetTradeFeeGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetTradeFeeGetRequest) Execute() ([]InlineResponse20041, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetTradeFeeGetExecute(r)
}

/*
SapiV1AssetTradeFeeGet Trade Fee (USER_DATA)

Fetch trade fee

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetTradeFeeGetRequest
*/
func (a *WalletApiService) SapiV1AssetTradeFeeGet(ctx _context.Context) ApiSapiV1AssetTradeFeeGetRequest {
	return ApiSapiV1AssetTradeFeeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20041
func (a *WalletApiService) SapiV1AssetTradeFeeGetExecute(r ApiSapiV1AssetTradeFeeGetRequest) ([]InlineResponse20041, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20041
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetTradeFeeGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/tradeFee"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetTransferGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	type_ *string
	timestamp *int64
	signature *string
	startTime *int64
	endTime *int64
	current *int32
	size *int32
	fromSymbol *string
	toSymbol *string
	recvWindow *int64
}

// Universal transfer type
func (r ApiSapiV1AssetTransferGetRequest) Type_(type_ string) ApiSapiV1AssetTransferGetRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetTransferGetRequest) Timestamp(timestamp int64) ApiSapiV1AssetTransferGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetTransferGetRequest) Signature(signature string) ApiSapiV1AssetTransferGetRequest {
	r.signature = &signature
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetTransferGetRequest) StartTime(startTime int64) ApiSapiV1AssetTransferGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetTransferGetRequest) EndTime(endTime int64) ApiSapiV1AssetTransferGetRequest {
	r.endTime = &endTime
	return r
}
// Current querying page. Start from 1. Default:1
func (r ApiSapiV1AssetTransferGetRequest) Current(current int32) ApiSapiV1AssetTransferGetRequest {
	r.current = &current
	return r
}
// Default:10 Max:100
func (r ApiSapiV1AssetTransferGetRequest) Size(size int32) ApiSapiV1AssetTransferGetRequest {
	r.size = &size
	return r
}
// Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
func (r ApiSapiV1AssetTransferGetRequest) FromSymbol(fromSymbol string) ApiSapiV1AssetTransferGetRequest {
	r.fromSymbol = &fromSymbol
	return r
}
// Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
func (r ApiSapiV1AssetTransferGetRequest) ToSymbol(toSymbol string) ApiSapiV1AssetTransferGetRequest {
	r.toSymbol = &toSymbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetTransferGetRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetTransferGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetTransferGetRequest) Execute() (InlineResponse20042, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetTransferGetExecute(r)
}

/*
SapiV1AssetTransferGet Query User Universal Transfer History (USER_DATA)

- `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- Support query within the last 6 months only
- If `startTime` and `endTime` not sent, return records of the last 7 days by default

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetTransferGetRequest
*/
func (a *WalletApiService) SapiV1AssetTransferGet(ctx _context.Context) ApiSapiV1AssetTransferGetRequest {
	return ApiSapiV1AssetTransferGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20042
func (a *WalletApiService) SapiV1AssetTransferGetExecute(r ApiSapiV1AssetTransferGetRequest) (InlineResponse20042, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20042
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetTransferGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.current != nil {
		localVarQueryParams.Add("current", parameterToString(*r.current, ""))
	}
	if r.size != nil {
		localVarQueryParams.Add("size", parameterToString(*r.size, ""))
	}
	if r.fromSymbol != nil {
		localVarQueryParams.Add("fromSymbol", parameterToString(*r.fromSymbol, ""))
	}
	if r.toSymbol != nil {
		localVarQueryParams.Add("toSymbol", parameterToString(*r.toSymbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1AssetTransferPostRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	type_ *string
	asset *string
	amount *float64
	timestamp *int64
	signature *string
	fromSymbol *string
	toSymbol *string
	recvWindow *int64
}

// Universal transfer type
func (r ApiSapiV1AssetTransferPostRequest) Type_(type_ string) ApiSapiV1AssetTransferPostRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1AssetTransferPostRequest) Asset(asset string) ApiSapiV1AssetTransferPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1AssetTransferPostRequest) Amount(amount float64) ApiSapiV1AssetTransferPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1AssetTransferPostRequest) Timestamp(timestamp int64) ApiSapiV1AssetTransferPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1AssetTransferPostRequest) Signature(signature string) ApiSapiV1AssetTransferPostRequest {
	r.signature = &signature
	return r
}
// Must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
func (r ApiSapiV1AssetTransferPostRequest) FromSymbol(fromSymbol string) ApiSapiV1AssetTransferPostRequest {
	r.fromSymbol = &fromSymbol
	return r
}
// Must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
func (r ApiSapiV1AssetTransferPostRequest) ToSymbol(toSymbol string) ApiSapiV1AssetTransferPostRequest {
	r.toSymbol = &toSymbol
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1AssetTransferPostRequest) RecvWindow(recvWindow int64) ApiSapiV1AssetTransferPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1AssetTransferPostRequest) Execute() (InlineResponse20043, *_nethttp.Response, error) {
	return r.ApiService.SapiV1AssetTransferPostExecute(r)
}

/*
SapiV1AssetTransferPost User Universal Transfer (USER_DATA)

You need to enable `Permits Universal Transfer` option for the api key which requests this endpoint.

- `fromSymbol` must be sent when type are ISOLATEDMARGIN_MARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN
- `toSymbol` must be sent when type are MARGIN_ISOLATEDMARGIN and ISOLATEDMARGIN_ISOLATEDMARGIN

ENUM of transfer types:
- MAIN_UMFUTURE Spot account transfer to USD-M Futures account
- MAIN_CMFUTURE Spot account transfer to COIN-M Futures account
- MAIN_MARGIN Spot account transfer to Margincrossaccount
- MAIN_MINING Spot account transfer to Mining account
- UMFUTURE_MAIN USD-M Futures account transfer to Spot account
- UMFUTURE_MARGIN USD-M Futures account transfer to Margincrossaccount
- CMFUTURE_MAIN COIN-M Futures account transfer to Spot account
- CMFUTURE_MARGIN COIN-M Futures account transfer to Margin(cross) account
- MARGIN_MAIN Margincrossaccount transfer to Spot account
- MARGIN_UMFUTURE Margincrossaccount transfer to USD-M Futures
- MARGIN_CMFUTURE Margincrossaccount transfer to COIN-M Futures
- MARGIN_MINING Margincrossaccount transfer to Mining account
- MINING_MAIN Mining account transfer to Spot account
- MINING_UMFUTURE Mining account transfer to USD-M Futures account
- MINING_MARGIN Mining account transfer to Margin(cross) account
- ISOLATEDMARGIN_MARGIN Isolated margin account transfer to Margin(cross) account
- MARGIN_ISOLATEDMARGIN Margin(cross) account transfer to Isolated margin account
- ISOLATEDMARGIN_ISOLATEDMARGIN Isolated margin account transfer to Isolated margin account
- MAIN_FUNDING Spot account transfer to Funding account
- FUNDING_MAIN Funding account transfer to Spot account
- FUNDING_UMFUTURE Funding account transfer to UMFUTURE account
- UMFUTURE_FUNDING UMFUTURE account transfer to Funding account
- MARGIN_FUNDING MARGIN account transfer to Funding account
- FUNDING_MARGIN Funding account transfer to Margin account
- FUNDING_CMFUTURE Funding account transfer to CMFUTURE account
- CMFUTURE_FUNDING CMFUTURE account transfer to Funding account

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1AssetTransferPostRequest
*/
func (a *WalletApiService) SapiV1AssetTransferPost(ctx _context.Context) ApiSapiV1AssetTransferPostRequest {
	return ApiSapiV1AssetTransferPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20043
func (a *WalletApiService) SapiV1AssetTransferPostExecute(r ApiSapiV1AssetTransferPostRequest) (InlineResponse20043, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20043
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1AssetTransferPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/asset/transfer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.fromSymbol != nil {
		localVarQueryParams.Add("fromSymbol", parameterToString(*r.fromSymbol, ""))
	}
	if r.toSymbol != nil {
		localVarQueryParams.Add("toSymbol", parameterToString(*r.toSymbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalConfigGetallGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1CapitalConfigGetallGetRequest) Timestamp(timestamp int64) ApiSapiV1CapitalConfigGetallGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalConfigGetallGetRequest) Signature(signature string) ApiSapiV1CapitalConfigGetallGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalConfigGetallGetRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalConfigGetallGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalConfigGetallGetRequest) Execute() ([]InlineResponse20030, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalConfigGetallGetExecute(r)
}

/*
SapiV1CapitalConfigGetallGet All Coins' Information (USER_DATA)

Get information of coins (available for deposit and withdraw) for user.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalConfigGetallGetRequest
*/
func (a *WalletApiService) SapiV1CapitalConfigGetallGet(ctx _context.Context) ApiSapiV1CapitalConfigGetallGetRequest {
	return ApiSapiV1CapitalConfigGetallGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20030
func (a *WalletApiService) SapiV1CapitalConfigGetallGetExecute(r ApiSapiV1CapitalConfigGetallGetRequest) ([]InlineResponse20030, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20030
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalConfigGetallGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/config/getall"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalDepositAddressGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	coin *string
	timestamp *int64
	signature *string
	network *string
	recvWindow *int64
}

// Coin name
func (r ApiSapiV1CapitalDepositAddressGetRequest) Coin(coin string) ApiSapiV1CapitalDepositAddressGetRequest {
	r.coin = &coin
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositAddressGetRequest) Timestamp(timestamp int64) ApiSapiV1CapitalDepositAddressGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalDepositAddressGetRequest) Signature(signature string) ApiSapiV1CapitalDepositAddressGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1CapitalDepositAddressGetRequest) Network(network string) ApiSapiV1CapitalDepositAddressGetRequest {
	r.network = &network
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalDepositAddressGetRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalDepositAddressGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalDepositAddressGetRequest) Execute() (InlineResponse20034, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalDepositAddressGetExecute(r)
}

/*
SapiV1CapitalDepositAddressGet Deposit Address (supporting network) (USER_DATA)

Fetch deposit address with network.

- If network is not send, return with default network of the coin.
- You can get network and isDefault in networkList in the response of Get /sapi/v1/capital/config/getall (HMAC SHA256).

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalDepositAddressGetRequest
*/
func (a *WalletApiService) SapiV1CapitalDepositAddressGet(ctx _context.Context) ApiSapiV1CapitalDepositAddressGetRequest {
	return ApiSapiV1CapitalDepositAddressGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20034
func (a *WalletApiService) SapiV1CapitalDepositAddressGetExecute(r ApiSapiV1CapitalDepositAddressGetRequest) (InlineResponse20034, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20034
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalDepositAddressGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/address"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalDepositHisrecGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	coin *string
	timestamp *int64
	signature *string
	status *int32
	startTime *int64
	endTime *int64
	offset *int32
	limit *int32
	recvWindow *int64
}

// Coin name
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Coin(coin string) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.coin = &coin
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Timestamp(timestamp int64) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Signature(signature string) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.signature = &signature
	return r
}
// 0 -&gt; pending\\ 6 -&gt; credited but cannot withdraw\\ 1 -&gt; success
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Status(status int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.status = &status
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositHisrecGetRequest) StartTime(startTime int64) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalDepositHisrecGetRequest) EndTime(endTime int64) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Offset(offset int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.offset = &offset
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1CapitalDepositHisrecGetRequest) Limit(limit int32) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalDepositHisrecGetRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalDepositHisrecGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalDepositHisrecGetRequest) Execute() ([]InlineResponse20032, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalDepositHisrecGetExecute(r)
}

/*
SapiV1CapitalDepositHisrecGet Deposit Historysupporting network (USER_DATA)

Fetch deposit history.

- Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days.
- If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalDepositHisrecGetRequest
*/
func (a *WalletApiService) SapiV1CapitalDepositHisrecGet(ctx _context.Context) ApiSapiV1CapitalDepositHisrecGetRequest {
	return ApiSapiV1CapitalDepositHisrecGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20032
func (a *WalletApiService) SapiV1CapitalDepositHisrecGetExecute(r ApiSapiV1CapitalDepositHisrecGetRequest) ([]InlineResponse20032, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20032
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalDepositHisrecGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/deposit/hisrec"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalWithdrawApplyPostRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	coin *string
	address *string
	amount *float64
	timestamp *int64
	signature *string
	withdrawOrderId *string
	network *string
	addressTag *string
	transactionFeeFlag *bool
	name *string
	walletType *int32
	recvWindow *int64
}

// Coin name
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Coin(coin string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.coin = &coin
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Address(address string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.address = &address
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Amount(amount float64) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.amount = &amount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Timestamp(timestamp int64) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Signature(signature string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.signature = &signature
	return r
}
// Client id for withdraw
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) WithdrawOrderId(withdrawOrderId string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.withdrawOrderId = &withdrawOrderId
	return r
}
// Get the value from &#x60;GET /sapi/v1/capital/config/getall&#x60;
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Network(network string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.network = &network
	return r
}
// Secondary address identifier for coins like XRP,XMR etc.
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) AddressTag(addressTag string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.addressTag = &addressTag
	return r
}
// When making internal transfer - &#x60;true&#x60; -&gt;  returning the fee to the destination account; - &#x60;false&#x60; -&gt; returning the fee back to the departure account.
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) TransactionFeeFlag(transactionFeeFlag bool) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.transactionFeeFlag = &transactionFeeFlag
	return r
}
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Name(name string) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.name = &name
	return r
}
// The wallet type for withdraw0-Spot wallet, 1- Funding wallet. Default is Spot wallet
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) WalletType(walletType int32) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.walletType = &walletType
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalWithdrawApplyPostRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalWithdrawApplyPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalWithdrawApplyPostRequest) Execute() (InlineResponse20031, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalWithdrawApplyPostExecute(r)
}

/*
SapiV1CapitalWithdrawApplyPost Withdraw (USER_DATA)

Submit a withdraw request.

- If `network` not send, return with default network of the coin.
- You can get `network` and `isDefault` in `networkList` of a coin in the response of `Get /sapi/v1/capital/config/getall (HMAC SHA256)`.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalWithdrawApplyPostRequest
*/
func (a *WalletApiService) SapiV1CapitalWithdrawApplyPost(ctx _context.Context) ApiSapiV1CapitalWithdrawApplyPostRequest {
	return ApiSapiV1CapitalWithdrawApplyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20031
func (a *WalletApiService) SapiV1CapitalWithdrawApplyPostExecute(r ApiSapiV1CapitalWithdrawApplyPostRequest) (InlineResponse20031, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20031
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalWithdrawApplyPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/apply"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.address == nil {
		return localVarReturnValue, nil, reportError("address is required and must be specified")
	}
	if r.amount == nil {
		return localVarReturnValue, nil, reportError("amount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.withdrawOrderId != nil {
		localVarQueryParams.Add("withdrawOrderId", parameterToString(*r.withdrawOrderId, ""))
	}
	if r.network != nil {
		localVarQueryParams.Add("network", parameterToString(*r.network, ""))
	}
	localVarQueryParams.Add("address", parameterToString(*r.address, ""))
	if r.addressTag != nil {
		localVarQueryParams.Add("addressTag", parameterToString(*r.addressTag, ""))
	}
	localVarQueryParams.Add("amount", parameterToString(*r.amount, ""))
	if r.transactionFeeFlag != nil {
		localVarQueryParams.Add("transactionFeeFlag", parameterToString(*r.transactionFeeFlag, ""))
	}
	if r.name != nil {
		localVarQueryParams.Add("name", parameterToString(*r.name, ""))
	}
	if r.walletType != nil {
		localVarQueryParams.Add("walletType", parameterToString(*r.walletType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1CapitalWithdrawHistoryGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
	coin *string
	timestamp *int64
	signature *string
	withdrawOrderId *string
	status *int32
	startTime *int64
	endTime *int64
	offset *int32
	limit *int32
	recvWindow *int64
}

// Coin name
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Coin(coin string) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.coin = &coin
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Timestamp(timestamp int64) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Signature(signature string) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) WithdrawOrderId(withdrawOrderId string) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.withdrawOrderId = &withdrawOrderId
	return r
}
// 0:Email Sent 1:Cancelled 2:Awaiting Approval 3:Rejected 4:Processing 5:Failure 6:Completed
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Status(status int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.status = &status
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) StartTime(startTime int64) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) EndTime(endTime int64) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.endTime = &endTime
	return r
}
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Offset(offset int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.offset = &offset
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Limit(limit int32) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) RecvWindow(recvWindow int64) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1CapitalWithdrawHistoryGetRequest) Execute() ([]InlineResponse20033, *_nethttp.Response, error) {
	return r.ApiService.SapiV1CapitalWithdrawHistoryGetExecute(r)
}

/*
SapiV1CapitalWithdrawHistoryGet Withdraw History (supporting network) (USER_DATA)

Fetch withdraw history.

- `network` may not be in the response for old withdraw.
- Please notice the default `startTime` and `endTime` to make sure that time interval is within 0-90 days.
- If both `startTime` and `endTime` are sent, time between `startTime` and `endTime` must be less than 90 days

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1CapitalWithdrawHistoryGetRequest
*/
func (a *WalletApiService) SapiV1CapitalWithdrawHistoryGet(ctx _context.Context) ApiSapiV1CapitalWithdrawHistoryGetRequest {
	return ApiSapiV1CapitalWithdrawHistoryGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse20033
func (a *WalletApiService) SapiV1CapitalWithdrawHistoryGetExecute(r ApiSapiV1CapitalWithdrawHistoryGetRequest) ([]InlineResponse20033, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse20033
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1CapitalWithdrawHistoryGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/capital/withdraw/history"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.coin == nil {
		return localVarReturnValue, nil, reportError("coin is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("coin", parameterToString(*r.coin, ""))
	if r.withdrawOrderId != nil {
		localVarQueryParams.Add("withdrawOrderId", parameterToString(*r.withdrawOrderId, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1SystemStatusGetRequest struct {
	ctx _context.Context
	ApiService *WalletApiService
}


func (r ApiSapiV1SystemStatusGetRequest) Execute() (InlineResponse20029, *_nethttp.Response, error) {
	return r.ApiService.SapiV1SystemStatusGetExecute(r)
}

/*
SapiV1SystemStatusGet System Status (System)

Fetch system status.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1SystemStatusGetRequest
*/
func (a *WalletApiService) SapiV1SystemStatusGet(ctx _context.Context) ApiSapiV1SystemStatusGetRequest {
	return ApiSapiV1SystemStatusGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse20029
func (a *WalletApiService) SapiV1SystemStatusGetExecute(r ApiSapiV1SystemStatusGetRequest) (InlineResponse20029, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse20029
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WalletApiService.SapiV1SystemStatusGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/system/status"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
