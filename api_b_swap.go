/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package openapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// BSwapApiService BSwapApi service
type BSwapApiService service

type ApiSapiV1BswapAddLiquidityPreviewGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	poolId *int64
	type_ *string
	quoteAsset *string
	quoteQty *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) PoolId(poolId int64) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.poolId = &poolId
	return r
}
// \&quot;SINGLE\&quot; for adding a single token;\&quot;COMBINATION\&quot; for adding dual tokens
func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) Type_(type_ string) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) QuoteAsset(quoteAsset string) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) QuoteQty(quoteQty float64) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.quoteQty = &quoteQty
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) Signature(signature string) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapAddLiquidityPreviewGetRequest) Execute() (OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapAddLiquidityPreviewGetExecute(r)
}

/*
SapiV1BswapAddLiquidityPreviewGet Add Liquidity Preview (USER_DATA)

Calculate expected share amount for adding liquidity in single or dual token.

Weight(IP): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapAddLiquidityPreviewGetRequest
*/
func (a *BSwapApiService) SapiV1BswapAddLiquidityPreviewGet(ctx _context.Context) ApiSapiV1BswapAddLiquidityPreviewGetRequest {
	return ApiSapiV1BswapAddLiquidityPreviewGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle
func (a *BSwapApiService) SapiV1BswapAddLiquidityPreviewGetExecute(r ApiSapiV1BswapAddLiquidityPreviewGetRequest) (OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapAddLiquidityPreviewGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/addLiquidityPreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.quoteQty == nil {
		return localVarReturnValue, nil, reportError("quoteQty is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("quoteQty", parameterToString(*r.quoteQty, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapLiquidityAddPostRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	poolId *int64
	asset *string
	quantity *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1BswapLiquidityAddPostRequest) PoolId(poolId int64) ApiSapiV1BswapLiquidityAddPostRequest {
	r.poolId = &poolId
	return r
}
func (r ApiSapiV1BswapLiquidityAddPostRequest) Asset(asset string) ApiSapiV1BswapLiquidityAddPostRequest {
	r.asset = &asset
	return r
}
func (r ApiSapiV1BswapLiquidityAddPostRequest) Quantity(quantity float64) ApiSapiV1BswapLiquidityAddPostRequest {
	r.quantity = &quantity
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapLiquidityAddPostRequest) Timestamp(timestamp int64) ApiSapiV1BswapLiquidityAddPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapLiquidityAddPostRequest) Signature(signature string) ApiSapiV1BswapLiquidityAddPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapLiquidityAddPostRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapLiquidityAddPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapLiquidityAddPostRequest) Execute() (InlineResponse200105, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapLiquidityAddPostExecute(r)
}

/*
SapiV1BswapLiquidityAddPost Add Liquidity (TRADE)

Add liquidity to a pool.

Weight(UID): 1000 (Additional: 3 times one second)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapLiquidityAddPostRequest
*/
func (a *BSwapApiService) SapiV1BswapLiquidityAddPost(ctx _context.Context) ApiSapiV1BswapLiquidityAddPostRequest {
	return ApiSapiV1BswapLiquidityAddPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200105
func (a *BSwapApiService) SapiV1BswapLiquidityAddPostExecute(r ApiSapiV1BswapLiquidityAddPostRequest) (InlineResponse200105, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200105
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapLiquidityAddPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidityAdd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapLiquidityGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	timestamp *int64
	signature *string
	poolId *int64
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1BswapLiquidityGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapLiquidityGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapLiquidityGetRequest) Signature(signature string) ApiSapiV1BswapLiquidityGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1BswapLiquidityGetRequest) PoolId(poolId int64) ApiSapiV1BswapLiquidityGetRequest {
	r.poolId = &poolId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapLiquidityGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapLiquidityGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapLiquidityGetRequest) Execute() ([]InlineResponse200104, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapLiquidityGetExecute(r)
}

/*
SapiV1BswapLiquidityGet Liquidity information of a pool (USER_DATA)

Get liquidity information and user share of a pool.

Weight(IP):\
`1`  for one pool;\
`10` when the poolId parameter is omitted;

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapLiquidityGetRequest
*/
func (a *BSwapApiService) SapiV1BswapLiquidityGet(ctx _context.Context) ApiSapiV1BswapLiquidityGetRequest {
	return ApiSapiV1BswapLiquidityGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200104
func (a *BSwapApiService) SapiV1BswapLiquidityGetExecute(r ApiSapiV1BswapLiquidityGetRequest) ([]InlineResponse200104, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200104
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapLiquidityGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapLiquidityOpsGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	timestamp *int64
	signature *string
	operationId *int64
	poolId *int64
	operation *string
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1BswapLiquidityOpsGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapLiquidityOpsGetRequest) Signature(signature string) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1BswapLiquidityOpsGetRequest) OperationId(operationId int64) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.operationId = &operationId
	return r
}
func (r ApiSapiV1BswapLiquidityOpsGetRequest) PoolId(poolId int64) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.poolId = &poolId
	return r
}
func (r ApiSapiV1BswapLiquidityOpsGetRequest) Operation(operation string) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.operation = &operation
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapLiquidityOpsGetRequest) StartTime(startTime int64) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapLiquidityOpsGetRequest) EndTime(endTime int64) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.endTime = &endTime
	return r
}
// Default 500; max 1000.
func (r ApiSapiV1BswapLiquidityOpsGetRequest) Limit(limit int32) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapLiquidityOpsGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapLiquidityOpsGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapLiquidityOpsGetRequest) Execute() ([]InlineResponse200106, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapLiquidityOpsGetExecute(r)
}

/*
SapiV1BswapLiquidityOpsGet Liquidity Operation Record (USER_DATA)

Get liquidity operation (add/remove) records.

Weight(UID): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapLiquidityOpsGetRequest
*/
func (a *BSwapApiService) SapiV1BswapLiquidityOpsGet(ctx _context.Context) ApiSapiV1BswapLiquidityOpsGetRequest {
	return ApiSapiV1BswapLiquidityOpsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200106
func (a *BSwapApiService) SapiV1BswapLiquidityOpsGetExecute(r ApiSapiV1BswapLiquidityOpsGetRequest) ([]InlineResponse200106, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200106
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapLiquidityOpsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidityOps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.operationId != nil {
		localVarQueryParams.Add("operationId", parameterToString(*r.operationId, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapLiquidityRemovePostRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	poolId *int64
	type_ *string
	shareAmount *float64
	timestamp *int64
	signature *string
	asset *string
	recvWindow *int64
}

func (r ApiSapiV1BswapLiquidityRemovePostRequest) PoolId(poolId int64) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.poolId = &poolId
	return r
}
// Can be &#x60;SINGLE&#x60; for single asset removal, &#x60;COMBINATION&#x60; for combination of all coins removal
func (r ApiSapiV1BswapLiquidityRemovePostRequest) Type_(type_ string) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1BswapLiquidityRemovePostRequest) ShareAmount(shareAmount float64) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.shareAmount = &shareAmount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapLiquidityRemovePostRequest) Timestamp(timestamp int64) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapLiquidityRemovePostRequest) Signature(signature string) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.signature = &signature
	return r
}
// Mandatory for single asset removal
func (r ApiSapiV1BswapLiquidityRemovePostRequest) Asset(asset string) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.asset = &asset
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapLiquidityRemovePostRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapLiquidityRemovePostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapLiquidityRemovePostRequest) Execute() (InlineResponse200105, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapLiquidityRemovePostExecute(r)
}

/*
SapiV1BswapLiquidityRemovePost Remove Liquidity (TRADE)

Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal

Weight(UID): 1000 (Additional: 3 times one second)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapLiquidityRemovePostRequest
*/
func (a *BSwapApiService) SapiV1BswapLiquidityRemovePost(ctx _context.Context) ApiSapiV1BswapLiquidityRemovePostRequest {
	return ApiSapiV1BswapLiquidityRemovePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200105
func (a *BSwapApiService) SapiV1BswapLiquidityRemovePostExecute(r ApiSapiV1BswapLiquidityRemovePostRequest) (InlineResponse200105, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200105
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapLiquidityRemovePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidityRemove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.shareAmount == nil {
		return localVarReturnValue, nil, reportError("shareAmount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	localVarQueryParams.Add("shareAmount", parameterToString(*r.shareAmount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapPoolConfigureGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	timestamp *int64
	signature *string
	poolId *int64
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1BswapPoolConfigureGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapPoolConfigureGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapPoolConfigureGetRequest) Signature(signature string) ApiSapiV1BswapPoolConfigureGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1BswapPoolConfigureGetRequest) PoolId(poolId int64) ApiSapiV1BswapPoolConfigureGetRequest {
	r.poolId = &poolId
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapPoolConfigureGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapPoolConfigureGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapPoolConfigureGetRequest) Execute() ([]InlineResponse200110, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapPoolConfigureGetExecute(r)
}

/*
SapiV1BswapPoolConfigureGet Pool Configure (USER_DATA)

Weight(IP): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapPoolConfigureGetRequest
*/
func (a *BSwapApiService) SapiV1BswapPoolConfigureGet(ctx _context.Context) ApiSapiV1BswapPoolConfigureGetRequest {
	return ApiSapiV1BswapPoolConfigureGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200110
func (a *BSwapApiService) SapiV1BswapPoolConfigureGetExecute(r ApiSapiV1BswapPoolConfigureGetRequest) ([]InlineResponse200110, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200110
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapPoolConfigureGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/poolConfigure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapPoolsGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
}


func (r ApiSapiV1BswapPoolsGetRequest) Execute() ([]InlineResponse200103, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapPoolsGetExecute(r)
}

/*
SapiV1BswapPoolsGet List All Swap Pools (MARKET_DATA)

Get metadata about all swap pools.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapPoolsGetRequest
*/
func (a *BSwapApiService) SapiV1BswapPoolsGet(ctx _context.Context) ApiSapiV1BswapPoolsGetRequest {
	return ApiSapiV1BswapPoolsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200103
func (a *BSwapApiService) SapiV1BswapPoolsGetExecute(r ApiSapiV1BswapPoolsGetRequest) ([]InlineResponse200103, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200103
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapPoolsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapQuoteGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	quoteAsset *string
	baseAsset *string
	quoteQty *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1BswapQuoteGetRequest) QuoteAsset(quoteAsset string) ApiSapiV1BswapQuoteGetRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSapiV1BswapQuoteGetRequest) BaseAsset(baseAsset string) ApiSapiV1BswapQuoteGetRequest {
	r.baseAsset = &baseAsset
	return r
}
func (r ApiSapiV1BswapQuoteGetRequest) QuoteQty(quoteQty float64) ApiSapiV1BswapQuoteGetRequest {
	r.quoteQty = &quoteQty
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapQuoteGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapQuoteGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapQuoteGetRequest) Signature(signature string) ApiSapiV1BswapQuoteGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapQuoteGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapQuoteGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapQuoteGetRequest) Execute() (InlineResponse200107, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapQuoteGetExecute(r)
}

/*
SapiV1BswapQuoteGet Request Quote (USER_DATA)

Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.

quoteQty is quantity of quote asset (to sell).

Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.

Weight(UID): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapQuoteGetRequest
*/
func (a *BSwapApiService) SapiV1BswapQuoteGet(ctx _context.Context) ApiSapiV1BswapQuoteGetRequest {
	return ApiSapiV1BswapQuoteGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200107
func (a *BSwapApiService) SapiV1BswapQuoteGetExecute(r ApiSapiV1BswapQuoteGetRequest) (InlineResponse200107, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200107
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapQuoteGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/quote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.baseAsset == nil {
		return localVarReturnValue, nil, reportError("baseAsset is required and must be specified")
	}
	if r.quoteQty == nil {
		return localVarReturnValue, nil, reportError("quoteQty is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("baseAsset", parameterToString(*r.baseAsset, ""))
	localVarQueryParams.Add("quoteQty", parameterToString(*r.quoteQty, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapRemoveLiquidityPreviewGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	poolId *int64
	type_ *string
	quoteAsset *string
	shareAmount *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) PoolId(poolId int64) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.poolId = &poolId
	return r
}
// Type is \&quot;SINGLE\&quot;, remove and obtain a single token;Type is \&quot;COMBINATION\&quot;, remove and obtain dual token.
func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) Type_(type_ string) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.type_ = &type_
	return r
}
func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) QuoteAsset(quoteAsset string) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) ShareAmount(shareAmount float64) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.shareAmount = &shareAmount
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) Signature(signature string) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) Execute() (OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapRemoveLiquidityPreviewGetExecute(r)
}

/*
SapiV1BswapRemoveLiquidityPreviewGet Remove Liquidity Preview (USER_DATA)

Calculate the expected asset amount of single token redemption or dual token redemption.

Weight(IP): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapRemoveLiquidityPreviewGetRequest
*/
func (a *BSwapApiService) SapiV1BswapRemoveLiquidityPreviewGet(ctx _context.Context) ApiSapiV1BswapRemoveLiquidityPreviewGetRequest {
	return ApiSapiV1BswapRemoveLiquidityPreviewGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle
func (a *BSwapApiService) SapiV1BswapRemoveLiquidityPreviewGetExecute(r ApiSapiV1BswapRemoveLiquidityPreviewGetRequest) (OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapRemoveLiquidityPreviewGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/removeLiquidityPreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.shareAmount == nil {
		return localVarReturnValue, nil, reportError("shareAmount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("shareAmount", parameterToString(*r.shareAmount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapSwapGetRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	timestamp *int64
	signature *string
	swapId *int64
	startTime *int64
	endTime *int64
	status *int32
	quoteAsset *string
	baseAsset *string
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSapiV1BswapSwapGetRequest) Timestamp(timestamp int64) ApiSapiV1BswapSwapGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapSwapGetRequest) Signature(signature string) ApiSapiV1BswapSwapGetRequest {
	r.signature = &signature
	return r
}
func (r ApiSapiV1BswapSwapGetRequest) SwapId(swapId int64) ApiSapiV1BswapSwapGetRequest {
	r.swapId = &swapId
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapSwapGetRequest) StartTime(startTime int64) ApiSapiV1BswapSwapGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapSwapGetRequest) EndTime(endTime int64) ApiSapiV1BswapSwapGetRequest {
	r.endTime = &endTime
	return r
}
// 0: pending for swap, 1: success, 2: failed
func (r ApiSapiV1BswapSwapGetRequest) Status(status int32) ApiSapiV1BswapSwapGetRequest {
	r.status = &status
	return r
}
func (r ApiSapiV1BswapSwapGetRequest) QuoteAsset(quoteAsset string) ApiSapiV1BswapSwapGetRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSapiV1BswapSwapGetRequest) BaseAsset(baseAsset string) ApiSapiV1BswapSwapGetRequest {
	r.baseAsset = &baseAsset
	return r
}
// default 3, max 100
func (r ApiSapiV1BswapSwapGetRequest) Limit(limit int32) ApiSapiV1BswapSwapGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapSwapGetRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapSwapGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapSwapGetRequest) Execute() ([]InlineResponse200108, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapSwapGetExecute(r)
}

/*
SapiV1BswapSwapGet Swap History (USER_DATA)

Get swap history.

Weight(UID): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapSwapGetRequest
*/
func (a *BSwapApiService) SapiV1BswapSwapGet(ctx _context.Context) ApiSapiV1BswapSwapGetRequest {
	return ApiSapiV1BswapSwapGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200108
func (a *BSwapApiService) SapiV1BswapSwapGetExecute(r ApiSapiV1BswapSwapGetRequest) ([]InlineResponse200108, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200108
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapSwapGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/swap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.swapId != nil {
		localVarQueryParams.Add("swapId", parameterToString(*r.swapId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.quoteAsset != nil {
		localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	}
	if r.baseAsset != nil {
		localVarQueryParams.Add("baseAsset", parameterToString(*r.baseAsset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSapiV1BswapSwapPostRequest struct {
	ctx _context.Context
	ApiService *BSwapApiService
	quoteAsset *string
	baseAsset *string
	quoteQty *float64
	timestamp *int64
	signature *string
	recvWindow *int64
}

func (r ApiSapiV1BswapSwapPostRequest) QuoteAsset(quoteAsset string) ApiSapiV1BswapSwapPostRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSapiV1BswapSwapPostRequest) BaseAsset(baseAsset string) ApiSapiV1BswapSwapPostRequest {
	r.baseAsset = &baseAsset
	return r
}
func (r ApiSapiV1BswapSwapPostRequest) QuoteQty(quoteQty float64) ApiSapiV1BswapSwapPostRequest {
	r.quoteQty = &quoteQty
	return r
}
// UTC timestamp in ms
func (r ApiSapiV1BswapSwapPostRequest) Timestamp(timestamp int64) ApiSapiV1BswapSwapPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiSapiV1BswapSwapPostRequest) Signature(signature string) ApiSapiV1BswapSwapPostRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiSapiV1BswapSwapPostRequest) RecvWindow(recvWindow int64) ApiSapiV1BswapSwapPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSapiV1BswapSwapPostRequest) Execute() (InlineResponse200109, *_nethttp.Response, error) {
	return r.ApiService.SapiV1BswapSwapPostExecute(r)
}

/*
SapiV1BswapSwapPost Swap (TRADE)

Swap `quoteAsset` for `baseAsset`.

Weight(UID): 1000 (Additional: 3 times one second)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSapiV1BswapSwapPostRequest
*/
func (a *BSwapApiService) SapiV1BswapSwapPost(ctx _context.Context) ApiSapiV1BswapSwapPostRequest {
	return ApiSapiV1BswapSwapPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200109
func (a *BSwapApiService) SapiV1BswapSwapPostExecute(r ApiSapiV1BswapSwapPostRequest) (InlineResponse200109, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200109
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SapiV1BswapSwapPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/swap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.baseAsset == nil {
		return localVarReturnValue, nil, reportError("baseAsset is required and must be specified")
	}
	if r.quoteQty == nil {
		return localVarReturnValue, nil, reportError("quoteQty is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("baseAsset", parameterToString(*r.baseAsset, ""))
	localVarQueryParams.Add("quoteQty", parameterToString(*r.quoteQty, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
