/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API generated with [binance/binance-api-swagger/blob/master/spot_api.yaml](https://github.com/binance/binance-api-swagger/blob/master/spot_api.yaml) with commit [v1.2.0 release](https://github.com/binance/binance-api-swagger/commit/60d14be031c031600c853d5cdab86db5ab73603e)  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
Contact: qishiwenjun@163.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// BSwapApiService BSwapApi service
type BSwapApiService service

type ApiBswapAddLiquidityPreviewRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	poolId     *int64
	type_      *string
	quoteAsset *string
	quoteQty   *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiBswapAddLiquidityPreviewRequest) PoolId(poolId int64) ApiBswapAddLiquidityPreviewRequest {
	r.poolId = &poolId
	return r
}

// \&quot;SINGLE\&quot; for adding a single token;\&quot;COMBINATION\&quot; for adding dual tokens
func (r ApiBswapAddLiquidityPreviewRequest) Type_(type_ string) ApiBswapAddLiquidityPreviewRequest {
	r.type_ = &type_
	return r
}
func (r ApiBswapAddLiquidityPreviewRequest) QuoteAsset(quoteAsset string) ApiBswapAddLiquidityPreviewRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiBswapAddLiquidityPreviewRequest) QuoteQty(quoteQty float64) ApiBswapAddLiquidityPreviewRequest {
	r.quoteQty = &quoteQty
	return r
}

// UTC timestamp in ms
func (r ApiBswapAddLiquidityPreviewRequest) Timestamp(timestamp int64) ApiBswapAddLiquidityPreviewRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapAddLiquidityPreviewRequest) Signature(signature string) ApiBswapAddLiquidityPreviewRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapAddLiquidityPreviewRequest) RecvWindow(recvWindow int64) ApiBswapAddLiquidityPreviewRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapAddLiquidityPreviewRequest) Execute() (OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle, *_nethttp.Response, error) {
	return r.ApiService.BswapAddLiquidityPreviewExecute(r)
}

/*
BswapAddLiquidityPreview Add Liquidity Preview (USER_DATA)

Calculate expected share amount for adding liquidity in single or dual token.

Weight(IP): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapAddLiquidityPreviewRequest
*/
func (a *BSwapApiService) BswapAddLiquidityPreview(ctx _context.Context) ApiBswapAddLiquidityPreviewRequest {
	return ApiBswapAddLiquidityPreviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle
func (a *BSwapApiService) BswapAddLiquidityPreviewExecute(r ApiBswapAddLiquidityPreviewRequest) (OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfbswapAddLiquidityPreviewCombinationbswapAddLiquidityPreviewSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapAddLiquidityPreview")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/addLiquidityPreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.quoteQty == nil {
		return localVarReturnValue, nil, reportError("quoteQty is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("quoteQty", parameterToString(*r.quoteQty, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapAddLiquidityToPoolRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	poolId     *int64
	asset      *string
	quantity   *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiBswapAddLiquidityToPoolRequest) PoolId(poolId int64) ApiBswapAddLiquidityToPoolRequest {
	r.poolId = &poolId
	return r
}
func (r ApiBswapAddLiquidityToPoolRequest) Asset(asset string) ApiBswapAddLiquidityToPoolRequest {
	r.asset = &asset
	return r
}
func (r ApiBswapAddLiquidityToPoolRequest) Quantity(quantity float64) ApiBswapAddLiquidityToPoolRequest {
	r.quantity = &quantity
	return r
}

// UTC timestamp in ms
func (r ApiBswapAddLiquidityToPoolRequest) Timestamp(timestamp int64) ApiBswapAddLiquidityToPoolRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapAddLiquidityToPoolRequest) Signature(signature string) ApiBswapAddLiquidityToPoolRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapAddLiquidityToPoolRequest) RecvWindow(recvWindow int64) ApiBswapAddLiquidityToPoolRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapAddLiquidityToPoolRequest) Execute() (InlineResponse200105, *_nethttp.Response, error) {
	return r.ApiService.BswapAddLiquidityToPoolExecute(r)
}

/*
BswapAddLiquidityToPool Add Liquidity (TRADE)

Add liquidity to a pool.

Weight(UID): 1000 (Additional: 3 times one second)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapAddLiquidityToPoolRequest
*/
func (a *BSwapApiService) BswapAddLiquidityToPool(ctx _context.Context) ApiBswapAddLiquidityToPoolRequest {
	return ApiBswapAddLiquidityToPoolRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200105
func (a *BSwapApiService) BswapAddLiquidityToPoolExecute(r ApiBswapAddLiquidityToPoolRequest) (InlineResponse200105, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200105
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapAddLiquidityToPool")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidityAdd"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.asset == nil {
		return localVarReturnValue, nil, reportError("asset is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapGetLiquidityOperationHistoryRequest struct {
	ctx         _context.Context
	ApiService  *BSwapApiService
	timestamp   *int64
	signature   *string
	operationId *int64
	poolId      *int64
	operation   *string
	startTime   *int64
	endTime     *int64
	limit       *int32
	recvWindow  *int64
}

// UTC timestamp in ms
func (r ApiBswapGetLiquidityOperationHistoryRequest) Timestamp(timestamp int64) ApiBswapGetLiquidityOperationHistoryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapGetLiquidityOperationHistoryRequest) Signature(signature string) ApiBswapGetLiquidityOperationHistoryRequest {
	r.signature = &signature
	return r
}
func (r ApiBswapGetLiquidityOperationHistoryRequest) OperationId(operationId int64) ApiBswapGetLiquidityOperationHistoryRequest {
	r.operationId = &operationId
	return r
}
func (r ApiBswapGetLiquidityOperationHistoryRequest) PoolId(poolId int64) ApiBswapGetLiquidityOperationHistoryRequest {
	r.poolId = &poolId
	return r
}
func (r ApiBswapGetLiquidityOperationHistoryRequest) Operation(operation string) ApiBswapGetLiquidityOperationHistoryRequest {
	r.operation = &operation
	return r
}

// UTC timestamp in ms
func (r ApiBswapGetLiquidityOperationHistoryRequest) StartTime(startTime int64) ApiBswapGetLiquidityOperationHistoryRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiBswapGetLiquidityOperationHistoryRequest) EndTime(endTime int64) ApiBswapGetLiquidityOperationHistoryRequest {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiBswapGetLiquidityOperationHistoryRequest) Limit(limit int32) ApiBswapGetLiquidityOperationHistoryRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapGetLiquidityOperationHistoryRequest) RecvWindow(recvWindow int64) ApiBswapGetLiquidityOperationHistoryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapGetLiquidityOperationHistoryRequest) Execute() ([]InlineResponse200106, *_nethttp.Response, error) {
	return r.ApiService.BswapGetLiquidityOperationHistoryExecute(r)
}

/*
BswapGetLiquidityOperationHistory Liquidity Operation Record (USER_DATA)

Get liquidity operation (add/remove) records.

Weight(UID): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapGetLiquidityOperationHistoryRequest
*/
func (a *BSwapApiService) BswapGetLiquidityOperationHistory(ctx _context.Context) ApiBswapGetLiquidityOperationHistoryRequest {
	return ApiBswapGetLiquidityOperationHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200106
func (a *BSwapApiService) BswapGetLiquidityOperationHistoryExecute(r ApiBswapGetLiquidityOperationHistoryRequest) ([]InlineResponse200106, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200106
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapGetLiquidityOperationHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidityOps"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.operationId != nil {
		localVarQueryParams.Add("operationId", parameterToString(*r.operationId, ""))
	}
	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	if r.operation != nil {
		localVarQueryParams.Add("operation", parameterToString(*r.operation, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapGetPoolConfigureRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	timestamp  *int64
	signature  *string
	poolId     *int64
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiBswapGetPoolConfigureRequest) Timestamp(timestamp int64) ApiBswapGetPoolConfigureRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapGetPoolConfigureRequest) Signature(signature string) ApiBswapGetPoolConfigureRequest {
	r.signature = &signature
	return r
}
func (r ApiBswapGetPoolConfigureRequest) PoolId(poolId int64) ApiBswapGetPoolConfigureRequest {
	r.poolId = &poolId
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapGetPoolConfigureRequest) RecvWindow(recvWindow int64) ApiBswapGetPoolConfigureRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapGetPoolConfigureRequest) Execute() ([]InlineResponse200110, *_nethttp.Response, error) {
	return r.ApiService.BswapGetPoolConfigureExecute(r)
}

/*
BswapGetPoolConfigure Pool Configure (USER_DATA)

Weight(IP): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapGetPoolConfigureRequest
*/
func (a *BSwapApiService) BswapGetPoolConfigure(ctx _context.Context) ApiBswapGetPoolConfigureRequest {
	return ApiBswapGetPoolConfigureRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200110
func (a *BSwapApiService) BswapGetPoolConfigureExecute(r ApiBswapGetPoolConfigureRequest) ([]InlineResponse200110, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200110
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapGetPoolConfigure")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/poolConfigure"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapGetPoolLiquidityInfoRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	timestamp  *int64
	signature  *string
	poolId     *int64
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiBswapGetPoolLiquidityInfoRequest) Timestamp(timestamp int64) ApiBswapGetPoolLiquidityInfoRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapGetPoolLiquidityInfoRequest) Signature(signature string) ApiBswapGetPoolLiquidityInfoRequest {
	r.signature = &signature
	return r
}
func (r ApiBswapGetPoolLiquidityInfoRequest) PoolId(poolId int64) ApiBswapGetPoolLiquidityInfoRequest {
	r.poolId = &poolId
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapGetPoolLiquidityInfoRequest) RecvWindow(recvWindow int64) ApiBswapGetPoolLiquidityInfoRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapGetPoolLiquidityInfoRequest) Execute() ([]InlineResponse200104, *_nethttp.Response, error) {
	return r.ApiService.BswapGetPoolLiquidityInfoExecute(r)
}

/*
BswapGetPoolLiquidityInfo Liquidity information of a pool (USER_DATA)

Get liquidity information and user share of a pool.

Weight(IP):\
`1`  for one pool;\
`10` when the poolId parameter is omitted;

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapGetPoolLiquidityInfoRequest
*/
func (a *BSwapApiService) BswapGetPoolLiquidityInfo(ctx _context.Context) ApiBswapGetPoolLiquidityInfoRequest {
	return ApiBswapGetPoolLiquidityInfoRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200104
func (a *BSwapApiService) BswapGetPoolLiquidityInfoExecute(r ApiBswapGetPoolLiquidityInfoRequest) ([]InlineResponse200104, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200104
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapGetPoolLiquidityInfo")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidity"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.poolId != nil {
		localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapGetPoolsRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
}

func (r ApiBswapGetPoolsRequest) Execute() ([]InlineResponse200103, *_nethttp.Response, error) {
	return r.ApiService.BswapGetPoolsExecute(r)
}

/*
BswapGetPools List All Swap Pools (MARKET_DATA)

Get metadata about all swap pools.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapGetPoolsRequest
*/
func (a *BSwapApiService) BswapGetPools(ctx _context.Context) ApiBswapGetPoolsRequest {
	return ApiBswapGetPoolsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200103
func (a *BSwapApiService) BswapGetPoolsExecute(r ApiBswapGetPoolsRequest) ([]InlineResponse200103, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200103
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapGetPools")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/pools"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapGetQuoteBasePriceRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	quoteAsset *string
	baseAsset  *string
	quoteQty   *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiBswapGetQuoteBasePriceRequest) QuoteAsset(quoteAsset string) ApiBswapGetQuoteBasePriceRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiBswapGetQuoteBasePriceRequest) BaseAsset(baseAsset string) ApiBswapGetQuoteBasePriceRequest {
	r.baseAsset = &baseAsset
	return r
}
func (r ApiBswapGetQuoteBasePriceRequest) QuoteQty(quoteQty float64) ApiBswapGetQuoteBasePriceRequest {
	r.quoteQty = &quoteQty
	return r
}

// UTC timestamp in ms
func (r ApiBswapGetQuoteBasePriceRequest) Timestamp(timestamp int64) ApiBswapGetQuoteBasePriceRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapGetQuoteBasePriceRequest) Signature(signature string) ApiBswapGetQuoteBasePriceRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapGetQuoteBasePriceRequest) RecvWindow(recvWindow int64) ApiBswapGetQuoteBasePriceRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapGetQuoteBasePriceRequest) Execute() (InlineResponse200107, *_nethttp.Response, error) {
	return r.ApiService.BswapGetQuoteBasePriceExecute(r)
}

/*
BswapGetQuoteBasePrice Request Quote (USER_DATA)

Request a quote for swap quote asset (selling asset) for base asset (buying asset), essentially price/exchange rates.

quoteQty is quantity of quote asset (to sell).

Please be noted the quote is for reference only, the actual price will change as the liquidity changes, it's recommended to swap immediate after request a quote for slippage prevention.

Weight(UID): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapGetQuoteBasePriceRequest
*/
func (a *BSwapApiService) BswapGetQuoteBasePrice(ctx _context.Context) ApiBswapGetQuoteBasePriceRequest {
	return ApiBswapGetQuoteBasePriceRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200107
func (a *BSwapApiService) BswapGetQuoteBasePriceExecute(r ApiBswapGetQuoteBasePriceRequest) (InlineResponse200107, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200107
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapGetQuoteBasePrice")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/quote"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.baseAsset == nil {
		return localVarReturnValue, nil, reportError("baseAsset is required and must be specified")
	}
	if r.quoteQty == nil {
		return localVarReturnValue, nil, reportError("quoteQty is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("baseAsset", parameterToString(*r.baseAsset, ""))
	localVarQueryParams.Add("quoteQty", parameterToString(*r.quoteQty, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapRemoveLiquidityFromPoolRequest struct {
	ctx         _context.Context
	ApiService  *BSwapApiService
	poolId      *int64
	type_       *string
	shareAmount *float64
	timestamp   *int64
	signature   *string
	asset       *string
	recvWindow  *int64
}

func (r ApiBswapRemoveLiquidityFromPoolRequest) PoolId(poolId int64) ApiBswapRemoveLiquidityFromPoolRequest {
	r.poolId = &poolId
	return r
}

// Can be &#x60;SINGLE&#x60; for single asset removal, &#x60;COMBINATION&#x60; for combination of all coins removal
func (r ApiBswapRemoveLiquidityFromPoolRequest) Type_(type_ string) ApiBswapRemoveLiquidityFromPoolRequest {
	r.type_ = &type_
	return r
}
func (r ApiBswapRemoveLiquidityFromPoolRequest) ShareAmount(shareAmount float64) ApiBswapRemoveLiquidityFromPoolRequest {
	r.shareAmount = &shareAmount
	return r
}

// UTC timestamp in ms
func (r ApiBswapRemoveLiquidityFromPoolRequest) Timestamp(timestamp int64) ApiBswapRemoveLiquidityFromPoolRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapRemoveLiquidityFromPoolRequest) Signature(signature string) ApiBswapRemoveLiquidityFromPoolRequest {
	r.signature = &signature
	return r
}

// Mandatory for single asset removal
func (r ApiBswapRemoveLiquidityFromPoolRequest) Asset(asset string) ApiBswapRemoveLiquidityFromPoolRequest {
	r.asset = &asset
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapRemoveLiquidityFromPoolRequest) RecvWindow(recvWindow int64) ApiBswapRemoveLiquidityFromPoolRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapRemoveLiquidityFromPoolRequest) Execute() (InlineResponse200105, *_nethttp.Response, error) {
	return r.ApiService.BswapRemoveLiquidityFromPoolExecute(r)
}

/*
BswapRemoveLiquidityFromPool Remove Liquidity (TRADE)

Remove liquidity from a pool, `type` include `SINGLE` and `COMBINATION`, asset is mandatory for single asset removal

Weight(UID): 1000 (Additional: 3 times one second)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapRemoveLiquidityFromPoolRequest
*/
func (a *BSwapApiService) BswapRemoveLiquidityFromPool(ctx _context.Context) ApiBswapRemoveLiquidityFromPoolRequest {
	return ApiBswapRemoveLiquidityFromPoolRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200105
func (a *BSwapApiService) BswapRemoveLiquidityFromPoolExecute(r ApiBswapRemoveLiquidityFromPoolRequest) (InlineResponse200105, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200105
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapRemoveLiquidityFromPool")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/liquidityRemove"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.shareAmount == nil {
		return localVarReturnValue, nil, reportError("shareAmount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.asset != nil {
		localVarQueryParams.Add("asset", parameterToString(*r.asset, ""))
	}
	localVarQueryParams.Add("shareAmount", parameterToString(*r.shareAmount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBswapRemoveLiquidityPreviewRequest struct {
	ctx         _context.Context
	ApiService  *BSwapApiService
	poolId      *int64
	type_       *string
	quoteAsset  *string
	shareAmount *float64
	timestamp   *int64
	signature   *string
	recvWindow  *int64
}

func (r ApiBswapRemoveLiquidityPreviewRequest) PoolId(poolId int64) ApiBswapRemoveLiquidityPreviewRequest {
	r.poolId = &poolId
	return r
}

// Type is \&quot;SINGLE\&quot;, remove and obtain a single token;Type is \&quot;COMBINATION\&quot;, remove and obtain dual token.
func (r ApiBswapRemoveLiquidityPreviewRequest) Type_(type_ string) ApiBswapRemoveLiquidityPreviewRequest {
	r.type_ = &type_
	return r
}
func (r ApiBswapRemoveLiquidityPreviewRequest) QuoteAsset(quoteAsset string) ApiBswapRemoveLiquidityPreviewRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiBswapRemoveLiquidityPreviewRequest) ShareAmount(shareAmount float64) ApiBswapRemoveLiquidityPreviewRequest {
	r.shareAmount = &shareAmount
	return r
}

// UTC timestamp in ms
func (r ApiBswapRemoveLiquidityPreviewRequest) Timestamp(timestamp int64) ApiBswapRemoveLiquidityPreviewRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBswapRemoveLiquidityPreviewRequest) Signature(signature string) ApiBswapRemoveLiquidityPreviewRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiBswapRemoveLiquidityPreviewRequest) RecvWindow(recvWindow int64) ApiBswapRemoveLiquidityPreviewRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBswapRemoveLiquidityPreviewRequest) Execute() (OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle, *_nethttp.Response, error) {
	return r.ApiService.BswapRemoveLiquidityPreviewExecute(r)
}

/*
BswapRemoveLiquidityPreview Remove Liquidity Preview (USER_DATA)

Calculate the expected asset amount of single token redemption or dual token redemption.

Weight(IP): 150

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBswapRemoveLiquidityPreviewRequest
*/
func (a *BSwapApiService) BswapRemoveLiquidityPreview(ctx _context.Context) ApiBswapRemoveLiquidityPreviewRequest {
	return ApiBswapRemoveLiquidityPreviewRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle
func (a *BSwapApiService) BswapRemoveLiquidityPreviewExecute(r ApiBswapRemoveLiquidityPreviewRequest) (OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOfbswapRmvLiquidityPreviewCombinationbswapRmvLiquidityPreviewSingle
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.BswapRemoveLiquidityPreview")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/removeLiquidityPreview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.poolId == nil {
		return localVarReturnValue, nil, reportError("poolId is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.shareAmount == nil {
		return localVarReturnValue, nil, reportError("shareAmount is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("poolId", parameterToString(*r.poolId, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("shareAmount", parameterToString(*r.shareAmount, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwapGetHistoryRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	timestamp  *int64
	signature  *string
	swapId     *int64
	startTime  *int64
	endTime    *int64
	status     *int32
	quoteAsset *string
	baseAsset  *string
	limit      *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiSwapGetHistoryRequest) Timestamp(timestamp int64) ApiSwapGetHistoryRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSwapGetHistoryRequest) Signature(signature string) ApiSwapGetHistoryRequest {
	r.signature = &signature
	return r
}
func (r ApiSwapGetHistoryRequest) SwapId(swapId int64) ApiSwapGetHistoryRequest {
	r.swapId = &swapId
	return r
}

// UTC timestamp in ms
func (r ApiSwapGetHistoryRequest) StartTime(startTime int64) ApiSwapGetHistoryRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiSwapGetHistoryRequest) EndTime(endTime int64) ApiSwapGetHistoryRequest {
	r.endTime = &endTime
	return r
}

// 0: pending for swap, 1: success, 2: failed
func (r ApiSwapGetHistoryRequest) Status(status int32) ApiSwapGetHistoryRequest {
	r.status = &status
	return r
}
func (r ApiSwapGetHistoryRequest) QuoteAsset(quoteAsset string) ApiSwapGetHistoryRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSwapGetHistoryRequest) BaseAsset(baseAsset string) ApiSwapGetHistoryRequest {
	r.baseAsset = &baseAsset
	return r
}

// default 3, max 100
func (r ApiSwapGetHistoryRequest) Limit(limit int32) ApiSwapGetHistoryRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiSwapGetHistoryRequest) RecvWindow(recvWindow int64) ApiSwapGetHistoryRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSwapGetHistoryRequest) Execute() ([]InlineResponse200108, *_nethttp.Response, error) {
	return r.ApiService.SwapGetHistoryExecute(r)
}

/*
SwapGetHistory Swap History (USER_DATA)

Get swap history.

Weight(UID): 3000

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSwapGetHistoryRequest
*/
func (a *BSwapApiService) SwapGetHistory(ctx _context.Context) ApiSwapGetHistoryRequest {
	return ApiSwapGetHistoryRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse200108
func (a *BSwapApiService) SwapGetHistoryExecute(r ApiSwapGetHistoryRequest) ([]InlineResponse200108, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse200108
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SwapGetHistory")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/swap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.swapId != nil {
		localVarQueryParams.Add("swapId", parameterToString(*r.swapId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.status != nil {
		localVarQueryParams.Add("status", parameterToString(*r.status, ""))
	}
	if r.quoteAsset != nil {
		localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	}
	if r.baseAsset != nil {
		localVarQueryParams.Add("baseAsset", parameterToString(*r.baseAsset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSwapQoteAssetToBaseAssetRequest struct {
	ctx        _context.Context
	ApiService *BSwapApiService
	quoteAsset *string
	baseAsset  *string
	quoteQty   *float64
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

func (r ApiSwapQoteAssetToBaseAssetRequest) QuoteAsset(quoteAsset string) ApiSwapQoteAssetToBaseAssetRequest {
	r.quoteAsset = &quoteAsset
	return r
}
func (r ApiSwapQoteAssetToBaseAssetRequest) BaseAsset(baseAsset string) ApiSwapQoteAssetToBaseAssetRequest {
	r.baseAsset = &baseAsset
	return r
}
func (r ApiSwapQoteAssetToBaseAssetRequest) QuoteQty(quoteQty float64) ApiSwapQoteAssetToBaseAssetRequest {
	r.quoteQty = &quoteQty
	return r
}

// UTC timestamp in ms
func (r ApiSwapQoteAssetToBaseAssetRequest) Timestamp(timestamp int64) ApiSwapQoteAssetToBaseAssetRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiSwapQoteAssetToBaseAssetRequest) Signature(signature string) ApiSwapQoteAssetToBaseAssetRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiSwapQoteAssetToBaseAssetRequest) RecvWindow(recvWindow int64) ApiSwapQoteAssetToBaseAssetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiSwapQoteAssetToBaseAssetRequest) Execute() (InlineResponse200109, *_nethttp.Response, error) {
	return r.ApiService.SwapQoteAssetToBaseAssetExecute(r)
}

/*
SwapQoteAssetToBaseAsset Swap (TRADE)

Swap `quoteAsset` for `baseAsset`.

Weight(UID): 1000 (Additional: 3 times one second)

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSwapQoteAssetToBaseAssetRequest
*/
func (a *BSwapApiService) SwapQoteAssetToBaseAsset(ctx _context.Context) ApiSwapQoteAssetToBaseAssetRequest {
	return ApiSwapQoteAssetToBaseAssetRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse200109
func (a *BSwapApiService) SwapQoteAssetToBaseAssetExecute(r ApiSwapQoteAssetToBaseAssetRequest) (InlineResponse200109, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse200109
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BSwapApiService.SwapQoteAssetToBaseAsset")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/sapi/v1/bswap/swap"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.quoteAsset == nil {
		return localVarReturnValue, nil, reportError("quoteAsset is required and must be specified")
	}
	if r.baseAsset == nil {
		return localVarReturnValue, nil, reportError("baseAsset is required and must be specified")
	}
	if r.quoteQty == nil {
		return localVarReturnValue, nil, reportError("quoteQty is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("quoteAsset", parameterToString(*r.quoteAsset, ""))
	localVarQueryParams.Add("baseAsset", parameterToString(*r.baseAsset, ""))
	localVarQueryParams.Add("quoteQty", parameterToString(*r.quoteQty, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
