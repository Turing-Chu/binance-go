/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// TradeApiService TradeApi service
type TradeApiService service

type ApiApiV3AccountGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiApiV3AccountGetRequest) Timestamp(timestamp int64) ApiApiV3AccountGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3AccountGetRequest) Signature(signature string) ApiApiV3AccountGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3AccountGetRequest) RecvWindow(recvWindow int64) ApiApiV3AccountGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3AccountGetRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.ApiV3AccountGetExecute(r)
}

/*
ApiV3AccountGet Account Information (USER_DATA)

Get current account information.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3AccountGetRequest
*/
func (a *TradeApiService) ApiV3AccountGet(ctx _context.Context) ApiApiV3AccountGetRequest {
	return ApiApiV3AccountGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Account
func (a *TradeApiService) ApiV3AccountGetExecute(r ApiApiV3AccountGetRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3AccountGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3AllOrderListGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	timestamp *int64
	signature *string
	fromId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiApiV3AllOrderListGetRequest) Timestamp(timestamp int64) ApiApiV3AllOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3AllOrderListGetRequest) Signature(signature string) ApiApiV3AllOrderListGetRequest {
	r.signature = &signature
	return r
}
// Trade id to fetch from. Default gets most recent trades.
func (r ApiApiV3AllOrderListGetRequest) FromId(fromId int64) ApiApiV3AllOrderListGetRequest {
	r.fromId = &fromId
	return r
}
// UTC timestamp in ms
func (r ApiApiV3AllOrderListGetRequest) StartTime(startTime int64) ApiApiV3AllOrderListGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiApiV3AllOrderListGetRequest) EndTime(endTime int64) ApiApiV3AllOrderListGetRequest {
	r.endTime = &endTime
	return r
}
// Default 500; max 1000.
func (r ApiApiV3AllOrderListGetRequest) Limit(limit int32) ApiApiV3AllOrderListGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3AllOrderListGetRequest) RecvWindow(recvWindow int64) ApiApiV3AllOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3AllOrderListGetRequest) Execute() ([]InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.ApiV3AllOrderListGetExecute(r)
}

/*
ApiV3AllOrderListGet Query all OCO (USER_DATA)

Retrieves all OCO based on provided optional parameters

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3AllOrderListGetRequest
*/
func (a *TradeApiService) ApiV3AllOrderListGet(ctx _context.Context) ApiApiV3AllOrderListGetRequest {
	return ApiApiV3AllOrderListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2006
func (a *TradeApiService) ApiV3AllOrderListGetExecute(r ApiApiV3AllOrderListGetRequest) ([]InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3AllOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3AllOrdersGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	timestamp *int64
	signature *string
	orderId *int64
	startTime *int64
	endTime *int64
	limit *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3AllOrdersGetRequest) Symbol(symbol string) ApiApiV3AllOrdersGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiApiV3AllOrdersGetRequest) Timestamp(timestamp int64) ApiApiV3AllOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3AllOrdersGetRequest) Signature(signature string) ApiApiV3AllOrdersGetRequest {
	r.signature = &signature
	return r
}
// Order id
func (r ApiApiV3AllOrdersGetRequest) OrderId(orderId int64) ApiApiV3AllOrdersGetRequest {
	r.orderId = &orderId
	return r
}
// UTC timestamp in ms
func (r ApiApiV3AllOrdersGetRequest) StartTime(startTime int64) ApiApiV3AllOrdersGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiApiV3AllOrdersGetRequest) EndTime(endTime int64) ApiApiV3AllOrdersGetRequest {
	r.endTime = &endTime
	return r
}
// Default 500; max 1000.
func (r ApiApiV3AllOrdersGetRequest) Limit(limit int32) ApiApiV3AllOrdersGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3AllOrdersGetRequest) RecvWindow(recvWindow int64) ApiApiV3AllOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3AllOrdersGetRequest) Execute() ([]OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV3AllOrdersGetExecute(r)
}

/*
ApiV3AllOrdersGet All Orders (USER_DATA)

Get all account orders; active, canceled, or filled..

- If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.
- If `startTime` and/or `endTime` provided, `orderId` is not required

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3AllOrdersGetRequest
*/
func (a *TradeApiService) ApiV3AllOrdersGet(ctx _context.Context) ApiApiV3AllOrdersGetRequest {
	return ApiApiV3AllOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OrderDetails
func (a *TradeApiService) ApiV3AllOrdersGetExecute(r ApiApiV3AllOrdersGetRequest) ([]OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3AllOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3MyTradesGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	timestamp *int64
	signature *string
	orderId *int64
	startTime *int64
	endTime *int64
	fromId *int64
	limit *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3MyTradesGetRequest) Symbol(symbol string) ApiApiV3MyTradesGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiApiV3MyTradesGetRequest) Timestamp(timestamp int64) ApiApiV3MyTradesGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3MyTradesGetRequest) Signature(signature string) ApiApiV3MyTradesGetRequest {
	r.signature = &signature
	return r
}
// This can only be used in combination with symbol.
func (r ApiApiV3MyTradesGetRequest) OrderId(orderId int64) ApiApiV3MyTradesGetRequest {
	r.orderId = &orderId
	return r
}
// UTC timestamp in ms
func (r ApiApiV3MyTradesGetRequest) StartTime(startTime int64) ApiApiV3MyTradesGetRequest {
	r.startTime = &startTime
	return r
}
// UTC timestamp in ms
func (r ApiApiV3MyTradesGetRequest) EndTime(endTime int64) ApiApiV3MyTradesGetRequest {
	r.endTime = &endTime
	return r
}
// Trade id to fetch from. Default gets most recent trades.
func (r ApiApiV3MyTradesGetRequest) FromId(fromId int64) ApiApiV3MyTradesGetRequest {
	r.fromId = &fromId
	return r
}
// Default 500; max 1000.
func (r ApiApiV3MyTradesGetRequest) Limit(limit int32) ApiApiV3MyTradesGetRequest {
	r.limit = &limit
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3MyTradesGetRequest) RecvWindow(recvWindow int64) ApiApiV3MyTradesGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3MyTradesGetRequest) Execute() ([]MyTrade, *_nethttp.Response, error) {
	return r.ApiService.ApiV3MyTradesGetExecute(r)
}

/*
ApiV3MyTradesGet Account Trade List (USER_DATA)

Get trades for a specific account and symbol.

If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3MyTradesGetRequest
*/
func (a *TradeApiService) ApiV3MyTradesGet(ctx _context.Context) ApiApiV3MyTradesGetRequest {
	return ApiApiV3MyTradesGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []MyTrade
func (a *TradeApiService) ApiV3MyTradesGetExecute(r ApiApiV3MyTradesGetRequest) ([]MyTrade, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MyTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3MyTradesGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OpenOrderListGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiApiV3OpenOrderListGetRequest) Timestamp(timestamp int64) ApiApiV3OpenOrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OpenOrderListGetRequest) Signature(signature string) ApiApiV3OpenOrderListGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OpenOrderListGetRequest) RecvWindow(recvWindow int64) ApiApiV3OpenOrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OpenOrderListGetRequest) Execute() ([]InlineResponse2007, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OpenOrderListGetExecute(r)
}

/*
ApiV3OpenOrderListGet Query Open OCO (USER_DATA)

Weight(IP): 3

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OpenOrderListGetRequest
*/
func (a *TradeApiService) ApiV3OpenOrderListGet(ctx _context.Context) ApiApiV3OpenOrderListGetRequest {
	return ApiApiV3OpenOrderListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2007
func (a *TradeApiService) ApiV3OpenOrderListGetExecute(r ApiApiV3OpenOrderListGetRequest) ([]InlineResponse2007, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OpenOrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OpenOrdersDeleteRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	timestamp *int64
	signature *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OpenOrdersDeleteRequest) Symbol(symbol string) ApiApiV3OpenOrdersDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OpenOrdersDeleteRequest) Timestamp(timestamp int64) ApiApiV3OpenOrdersDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OpenOrdersDeleteRequest) Signature(signature string) ApiApiV3OpenOrdersDeleteRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OpenOrdersDeleteRequest) RecvWindow(recvWindow int64) ApiApiV3OpenOrdersDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OpenOrdersDeleteRequest) Execute() ([]AnyOforderocoOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OpenOrdersDeleteExecute(r)
}

/*
ApiV3OpenOrdersDelete Cancel all Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol.\
This includes OCO orders.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OpenOrdersDeleteRequest
*/
func (a *TradeApiService) ApiV3OpenOrdersDelete(ctx _context.Context) ApiApiV3OpenOrdersDeleteRequest {
	return ApiApiV3OpenOrdersDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []AnyOforderocoOrder
func (a *TradeApiService) ApiV3OpenOrdersDeleteExecute(r ApiApiV3OpenOrdersDeleteRequest) ([]AnyOforderocoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AnyOforderocoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OpenOrdersDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OpenOrdersGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	timestamp *int64
	signature *string
	symbol *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiApiV3OpenOrdersGetRequest) Timestamp(timestamp int64) ApiApiV3OpenOrdersGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OpenOrdersGetRequest) Signature(signature string) ApiApiV3OpenOrdersGetRequest {
	r.signature = &signature
	return r
}
// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OpenOrdersGetRequest) Symbol(symbol string) ApiApiV3OpenOrdersGetRequest {
	r.symbol = &symbol
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OpenOrdersGetRequest) RecvWindow(recvWindow int64) ApiApiV3OpenOrdersGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OpenOrdersGetRequest) Execute() ([]OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OpenOrdersGetExecute(r)
}

/*
ApiV3OpenOrdersGet Current Open Orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.

Weight(IP):\
`3` for a single symbol;\
`40` when the symbol parameter is omitted;

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OpenOrdersGetRequest
*/
func (a *TradeApiService) ApiV3OpenOrdersGet(ctx _context.Context) ApiApiV3OpenOrdersGetRequest {
	return ApiApiV3OpenOrdersGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []OrderDetails
func (a *TradeApiService) ApiV3OpenOrdersGetExecute(r ApiApiV3OpenOrdersGetRequest) ([]OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OpenOrdersGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderDeleteRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	timestamp *int64
	signature *string
	orderId *int64
	origClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OrderDeleteRequest) Symbol(symbol string) ApiApiV3OrderDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OrderDeleteRequest) Timestamp(timestamp int64) ApiApiV3OrderDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderDeleteRequest) Signature(signature string) ApiApiV3OrderDeleteRequest {
	r.signature = &signature
	return r
}
// Order id
func (r ApiApiV3OrderDeleteRequest) OrderId(orderId int64) ApiApiV3OrderDeleteRequest {
	r.orderId = &orderId
	return r
}
// Order id from client
func (r ApiApiV3OrderDeleteRequest) OrigClientOrderId(origClientOrderId string) ApiApiV3OrderDeleteRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiApiV3OrderDeleteRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderDeleteRequest) RecvWindow(recvWindow int64) ApiApiV3OrderDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderDeleteRequest) Execute() (Order, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderDeleteExecute(r)
}

/*
ApiV3OrderDelete Cancel Order (TRADE)

Cancel an active order.

Either `orderId` or `origClientOrderId` must be sent.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderDeleteRequest
*/
func (a *TradeApiService) ApiV3OrderDelete(ctx _context.Context) ApiApiV3OrderDeleteRequest {
	return ApiApiV3OrderDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Order
func (a *TradeApiService) ApiV3OrderDeleteExecute(r ApiApiV3OrderDeleteRequest) (Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	timestamp *int64
	signature *string
	orderId *int64
	origClientOrderId *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OrderGetRequest) Symbol(symbol string) ApiApiV3OrderGetRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OrderGetRequest) Timestamp(timestamp int64) ApiApiV3OrderGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderGetRequest) Signature(signature string) ApiApiV3OrderGetRequest {
	r.signature = &signature
	return r
}
// Order id
func (r ApiApiV3OrderGetRequest) OrderId(orderId int64) ApiApiV3OrderGetRequest {
	r.orderId = &orderId
	return r
}
// Order id from client
func (r ApiApiV3OrderGetRequest) OrigClientOrderId(origClientOrderId string) ApiApiV3OrderGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderGetRequest) RecvWindow(recvWindow int64) ApiApiV3OrderGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderGetRequest) Execute() (OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderGetExecute(r)
}

/*
ApiV3OrderGet Query Order (USER_DATA)

Check an order's status.

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 2

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderGetRequest
*/
func (a *TradeApiService) ApiV3OrderGet(ctx _context.Context) ApiApiV3OrderGetRequest {
	return ApiApiV3OrderGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderDetails
func (a *TradeApiService) ApiV3OrderGetExecute(r ApiApiV3OrderGetRequest) (OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderListDeleteRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	timestamp *int64
	signature *string
	orderListId *int64
	listClientOrderId *string
	newClientOrderId *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OrderListDeleteRequest) Symbol(symbol string) ApiApiV3OrderListDeleteRequest {
	r.symbol = &symbol
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OrderListDeleteRequest) Timestamp(timestamp int64) ApiApiV3OrderListDeleteRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderListDeleteRequest) Signature(signature string) ApiApiV3OrderListDeleteRequest {
	r.signature = &signature
	return r
}
// Order list id
func (r ApiApiV3OrderListDeleteRequest) OrderListId(orderListId int64) ApiApiV3OrderListDeleteRequest {
	r.orderListId = &orderListId
	return r
}
// A unique Id for the entire orderList
func (r ApiApiV3OrderListDeleteRequest) ListClientOrderId(listClientOrderId string) ApiApiV3OrderListDeleteRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiApiV3OrderListDeleteRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderListDeleteRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderListDeleteRequest) RecvWindow(recvWindow int64) ApiApiV3OrderListDeleteRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderListDeleteRequest) Execute() (OcoOrder, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderListDeleteExecute(r)
}

/*
ApiV3OrderListDelete Cancel OCO (TRADE)

Cancel an entire Order List

Canceling an individual leg will cancel the entire OCO

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderListDeleteRequest
*/
func (a *TradeApiService) ApiV3OrderListDelete(ctx _context.Context) ApiApiV3OrderListDeleteRequest {
	return ApiApiV3OrderListDeleteRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OcoOrder
func (a *TradeApiService) ApiV3OrderListDeleteExecute(r ApiApiV3OrderListDeleteRequest) (OcoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OcoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderListDelete")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderListGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	timestamp *int64
	signature *string
	orderListId *int64
	origClientOrderId *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiApiV3OrderListGetRequest) Timestamp(timestamp int64) ApiApiV3OrderListGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderListGetRequest) Signature(signature string) ApiApiV3OrderListGetRequest {
	r.signature = &signature
	return r
}
// Order list id
func (r ApiApiV3OrderListGetRequest) OrderListId(orderListId int64) ApiApiV3OrderListGetRequest {
	r.orderListId = &orderListId
	return r
}
// Order id from client
func (r ApiApiV3OrderListGetRequest) OrigClientOrderId(origClientOrderId string) ApiApiV3OrderListGetRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderListGetRequest) RecvWindow(recvWindow int64) ApiApiV3OrderListGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderListGetRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderListGetExecute(r)
}

/*
ApiV3OrderListGet Query OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

Weight(IP): 2

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderListGetRequest
*/
func (a *TradeApiService) ApiV3OrderListGet(ctx _context.Context) ApiApiV3OrderListGetRequest {
	return ApiApiV3OrderListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2005
func (a *TradeApiService) ApiV3OrderListGetExecute(r ApiApiV3OrderListGetRequest) (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderListGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderOcoPostRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	side *string
	quantity *float64
	price *float64
	stopPrice *float64
	timestamp *int64
	signature *string
	listClientOrderId *string
	limitClientOrderId *string
	limitIcebergQty *float64
	stopClientOrderId *string
	stopLimitPrice *float64
	stopIcebergQty *float64
	stopLimitTimeInForce *string
	newOrderRespType *string
	sideEffectType *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OrderOcoPostRequest) Symbol(symbol string) ApiApiV3OrderOcoPostRequest {
	r.symbol = &symbol
	return r
}
// SELL or BUY
func (r ApiApiV3OrderOcoPostRequest) Side(side string) ApiApiV3OrderOcoPostRequest {
	r.side = &side
	return r
}
func (r ApiApiV3OrderOcoPostRequest) Quantity(quantity float64) ApiApiV3OrderOcoPostRequest {
	r.quantity = &quantity
	return r
}
// Order price
func (r ApiApiV3OrderOcoPostRequest) Price(price float64) ApiApiV3OrderOcoPostRequest {
	r.price = &price
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopPrice(stopPrice float64) ApiApiV3OrderOcoPostRequest {
	r.stopPrice = &stopPrice
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OrderOcoPostRequest) Timestamp(timestamp int64) ApiApiV3OrderOcoPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderOcoPostRequest) Signature(signature string) ApiApiV3OrderOcoPostRequest {
	r.signature = &signature
	return r
}
// A unique Id for the entire orderList
func (r ApiApiV3OrderOcoPostRequest) ListClientOrderId(listClientOrderId string) ApiApiV3OrderOcoPostRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}
// A unique Id for the limit order
func (r ApiApiV3OrderOcoPostRequest) LimitClientOrderId(limitClientOrderId string) ApiApiV3OrderOcoPostRequest {
	r.limitClientOrderId = &limitClientOrderId
	return r
}
func (r ApiApiV3OrderOcoPostRequest) LimitIcebergQty(limitIcebergQty float64) ApiApiV3OrderOcoPostRequest {
	r.limitIcebergQty = &limitIcebergQty
	return r
}
// A unique Id for the stop loss/stop loss limit leg
func (r ApiApiV3OrderOcoPostRequest) StopClientOrderId(stopClientOrderId string) ApiApiV3OrderOcoPostRequest {
	r.stopClientOrderId = &stopClientOrderId
	return r
}
// If provided, stopLimitTimeInForce is required.
func (r ApiApiV3OrderOcoPostRequest) StopLimitPrice(stopLimitPrice float64) ApiApiV3OrderOcoPostRequest {
	r.stopLimitPrice = &stopLimitPrice
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopIcebergQty(stopIcebergQty float64) ApiApiV3OrderOcoPostRequest {
	r.stopIcebergQty = &stopIcebergQty
	return r
}
func (r ApiApiV3OrderOcoPostRequest) StopLimitTimeInForce(stopLimitTimeInForce string) ApiApiV3OrderOcoPostRequest {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}
// Set the response JSON.
func (r ApiApiV3OrderOcoPostRequest) NewOrderRespType(newOrderRespType string) ApiApiV3OrderOcoPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
// Default NO_SIDE_EFFECT
func (r ApiApiV3OrderOcoPostRequest) SideEffectType(sideEffectType string) ApiApiV3OrderOcoPostRequest {
	r.sideEffectType = &sideEffectType
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderOcoPostRequest) RecvWindow(recvWindow int64) ApiApiV3OrderOcoPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderOcoPostRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderOcoPostExecute(r)
}

/*
ApiV3OrderOcoPost New OCO (TRADE)

Send in a new OCO

- Price Restrictions:
  - `SELL`: Limit Price > Last Price > Stop Price
  - `BUY`: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
    - Both legs must have the same quantity
    - `ICEBERG` quantities however do not have to be the same
- Order Rate Limit
    - `OCO` counts as 2 orders against the order rate limit.
    
Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderOcoPostRequest
*/
func (a *TradeApiService) ApiV3OrderOcoPost(ctx _context.Context) ApiApiV3OrderOcoPostRequest {
	return ApiApiV3OrderOcoPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2004
func (a *TradeApiService) ApiV3OrderOcoPostExecute(r ApiApiV3OrderOcoPostRequest) (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderOcoPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.limitClientOrderId != nil {
		localVarQueryParams.Add("limitClientOrderId", parameterToString(*r.limitClientOrderId, ""))
	}
	localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	if r.limitIcebergQty != nil {
		localVarQueryParams.Add("limitIcebergQty", parameterToString(*r.limitIcebergQty, ""))
	}
	if r.stopClientOrderId != nil {
		localVarQueryParams.Add("stopClientOrderId", parameterToString(*r.stopClientOrderId, ""))
	}
	localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	if r.stopLimitPrice != nil {
		localVarQueryParams.Add("stopLimitPrice", parameterToString(*r.stopLimitPrice, ""))
	}
	if r.stopIcebergQty != nil {
		localVarQueryParams.Add("stopIcebergQty", parameterToString(*r.stopIcebergQty, ""))
	}
	if r.stopLimitTimeInForce != nil {
		localVarQueryParams.Add("stopLimitTimeInForce", parameterToString(*r.stopLimitTimeInForce, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderPostRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	side *string
	type_ *string
	timestamp *int64
	signature *string
	timeInForce *string
	quantity *float64
	quoteOrderQty *float64
	price *float64
	newClientOrderId *string
	stopPrice *float64
	icebergQty *float64
	newOrderRespType *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OrderPostRequest) Symbol(symbol string) ApiApiV3OrderPostRequest {
	r.symbol = &symbol
	return r
}
// SELL or BUY
func (r ApiApiV3OrderPostRequest) Side(side string) ApiApiV3OrderPostRequest {
	r.side = &side
	return r
}
// Order type
func (r ApiApiV3OrderPostRequest) Type_(type_ string) ApiApiV3OrderPostRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OrderPostRequest) Timestamp(timestamp int64) ApiApiV3OrderPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderPostRequest) Signature(signature string) ApiApiV3OrderPostRequest {
	r.signature = &signature
	return r
}
// Order time in force
func (r ApiApiV3OrderPostRequest) TimeInForce(timeInForce string) ApiApiV3OrderPostRequest {
	r.timeInForce = &timeInForce
	return r
}
// Order quantity
func (r ApiApiV3OrderPostRequest) Quantity(quantity float64) ApiApiV3OrderPostRequest {
	r.quantity = &quantity
	return r
}
// Quote quantity
func (r ApiApiV3OrderPostRequest) QuoteOrderQty(quoteOrderQty float64) ApiApiV3OrderPostRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}
// Order price
func (r ApiApiV3OrderPostRequest) Price(price float64) ApiApiV3OrderPostRequest {
	r.price = &price
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiApiV3OrderPostRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderPostRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
func (r ApiApiV3OrderPostRequest) StopPrice(stopPrice float64) ApiApiV3OrderPostRequest {
	r.stopPrice = &stopPrice
	return r
}
// Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
func (r ApiApiV3OrderPostRequest) IcebergQty(icebergQty float64) ApiApiV3OrderPostRequest {
	r.icebergQty = &icebergQty
	return r
}
// Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
func (r ApiApiV3OrderPostRequest) NewOrderRespType(newOrderRespType string) ApiApiV3OrderPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderPostRequest) RecvWindow(recvWindow int64) ApiApiV3OrderPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderPostRequest) Execute() (OneOforderResponseAckorderResponseResultorderResponseFull, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderPostExecute(r)
}

/*
ApiV3OrderPost New Order (TRADE)

Send in a new order.

- `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker.
- `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached.
- Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`.
- Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`.
- `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price.
- `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`.
- `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`.
- same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.

Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:

- Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL`
- Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`


Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderPostRequest
*/
func (a *TradeApiService) ApiV3OrderPost(ctx _context.Context) ApiApiV3OrderPostRequest {
	return ApiApiV3OrderPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OneOforderResponseAckorderResponseResultorderResponseFull
func (a *TradeApiService) ApiV3OrderPostExecute(r ApiApiV3OrderPostRequest) (OneOforderResponseAckorderResponseResultorderResponseFull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOforderResponseAckorderResponseResultorderResponseFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.quantity != nil {
		localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	}
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3OrderTestPostRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	symbol *string
	side *string
	type_ *string
	timestamp *int64
	signature *string
	timeInForce *string
	quantity *float64
	quoteOrderQty *float64
	price *float64
	newClientOrderId *string
	stopPrice *float64
	icebergQty *float64
	newOrderRespType *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiApiV3OrderTestPostRequest) Symbol(symbol string) ApiApiV3OrderTestPostRequest {
	r.symbol = &symbol
	return r
}
// SELL or BUY
func (r ApiApiV3OrderTestPostRequest) Side(side string) ApiApiV3OrderTestPostRequest {
	r.side = &side
	return r
}
// Order type
func (r ApiApiV3OrderTestPostRequest) Type_(type_ string) ApiApiV3OrderTestPostRequest {
	r.type_ = &type_
	return r
}
// UTC timestamp in ms
func (r ApiApiV3OrderTestPostRequest) Timestamp(timestamp int64) ApiApiV3OrderTestPostRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3OrderTestPostRequest) Signature(signature string) ApiApiV3OrderTestPostRequest {
	r.signature = &signature
	return r
}
// Order time in force
func (r ApiApiV3OrderTestPostRequest) TimeInForce(timeInForce string) ApiApiV3OrderTestPostRequest {
	r.timeInForce = &timeInForce
	return r
}
// Order quantity
func (r ApiApiV3OrderTestPostRequest) Quantity(quantity float64) ApiApiV3OrderTestPostRequest {
	r.quantity = &quantity
	return r
}
// Quote quantity
func (r ApiApiV3OrderTestPostRequest) QuoteOrderQty(quoteOrderQty float64) ApiApiV3OrderTestPostRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}
// Order price
func (r ApiApiV3OrderTestPostRequest) Price(price float64) ApiApiV3OrderTestPostRequest {
	r.price = &price
	return r
}
// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiApiV3OrderTestPostRequest) NewClientOrderId(newClientOrderId string) ApiApiV3OrderTestPostRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}
// Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
func (r ApiApiV3OrderTestPostRequest) StopPrice(stopPrice float64) ApiApiV3OrderTestPostRequest {
	r.stopPrice = &stopPrice
	return r
}
// Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
func (r ApiApiV3OrderTestPostRequest) IcebergQty(icebergQty float64) ApiApiV3OrderTestPostRequest {
	r.icebergQty = &icebergQty
	return r
}
// Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
func (r ApiApiV3OrderTestPostRequest) NewOrderRespType(newOrderRespType string) ApiApiV3OrderTestPostRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3OrderTestPostRequest) RecvWindow(recvWindow int64) ApiApiV3OrderTestPostRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3OrderTestPostRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.ApiV3OrderTestPostExecute(r)
}

/*
ApiV3OrderTestPost Test New Order (TRADE)

Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3OrderTestPostRequest
*/
func (a *TradeApiService) ApiV3OrderTestPost(ctx _context.Context) ApiApiV3OrderTestPostRequest {
	return ApiApiV3OrderTestPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TradeApiService) ApiV3OrderTestPostExecute(r ApiApiV3OrderTestPostRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3OrderTestPost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.quantity != nil {
		localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	}
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV3RateLimitOrderGetRequest struct {
	ctx _context.Context
	ApiService *TradeApiService
	timestamp *int64
	signature *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiApiV3RateLimitOrderGetRequest) Timestamp(timestamp int64) ApiApiV3RateLimitOrderGetRequest {
	r.timestamp = &timestamp
	return r
}
// Signature
func (r ApiApiV3RateLimitOrderGetRequest) Signature(signature string) ApiApiV3RateLimitOrderGetRequest {
	r.signature = &signature
	return r
}
// The value cannot be greater than 60000
func (r ApiApiV3RateLimitOrderGetRequest) RecvWindow(recvWindow int64) ApiApiV3RateLimitOrderGetRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiApiV3RateLimitOrderGetRequest) Execute() ([]InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.ApiV3RateLimitOrderGetExecute(r)
}

/*
ApiV3RateLimitOrderGet Query Current Order Count Usage (TRADE)

Displays the user's current order count usage for all intervals.

Weight(IP): 20

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiApiV3RateLimitOrderGetRequest
*/
func (a *TradeApiService) ApiV3RateLimitOrderGet(ctx _context.Context) ApiApiV3RateLimitOrderGetRequest {
	return ApiApiV3RateLimitOrderGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2008
func (a *TradeApiService) ApiV3RateLimitOrderGetExecute(r ApiApiV3RateLimitOrderGetRequest) ([]InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.ApiV3RateLimitOrderGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
