/*
Binance Public Spot API

OpenAPI Specifications for the Binance Public Spot API generated with [binance/binance-api-swagger/blob/master/spot_api.yaml](https://github.com/binance/binance-api-swagger/blob/master/spot_api.yaml) with commit [v1.2.0 release](https://github.com/binance/binance-api-swagger/commit/60d14be031c031600c853d5cdab86db5ab73603e)  API documents:   - [https://github.com/binance/binance-spot-api-docs](https://github.com/binance/binance-spot-api-docs)   - [https://binance-docs.github.io/apidocs/spot/en](https://binance-docs.github.io/apidocs/spot/en)

API version: 1.0
Contact: qishiwenjun@163.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package binanceapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
)

// Linger please
var (
	_ _context.Context
)

// TradeApiService TradeApi service
type TradeApiService service

type ApiBatchCancelOrdersRequest struct {
	ctx               _context.Context
	ApiService        *TradeApiService
	symbol            *string
	timestamp         *int64
	signature         *string
	orderListId       *int64
	listClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiBatchCancelOrdersRequest) Symbol(symbol string) ApiBatchCancelOrdersRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiBatchCancelOrdersRequest) Timestamp(timestamp int64) ApiBatchCancelOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiBatchCancelOrdersRequest) Signature(signature string) ApiBatchCancelOrdersRequest {
	r.signature = &signature
	return r
}

// Order list id
func (r ApiBatchCancelOrdersRequest) OrderListId(orderListId int64) ApiBatchCancelOrdersRequest {
	r.orderListId = &orderListId
	return r
}

// A unique Id for the entire orderList
func (r ApiBatchCancelOrdersRequest) ListClientOrderId(listClientOrderId string) ApiBatchCancelOrdersRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiBatchCancelOrdersRequest) NewClientOrderId(newClientOrderId string) ApiBatchCancelOrdersRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiBatchCancelOrdersRequest) RecvWindow(recvWindow int64) ApiBatchCancelOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiBatchCancelOrdersRequest) Execute() (OcoOrder, *_nethttp.Response, error) {
	return r.ApiService.BatchCancelOrdersExecute(r)
}

/*
BatchCancelOrders Cancel OCO (TRADE)

Cancel an entire Order List

Canceling an individual leg will cancel the entire OCO

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiBatchCancelOrdersRequest
*/
func (a *TradeApiService) BatchCancelOrders(ctx _context.Context) ApiBatchCancelOrdersRequest {
	return ApiBatchCancelOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OcoOrder
func (a *TradeApiService) BatchCancelOrdersExecute(r ApiBatchCancelOrdersRequest) (OcoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OcoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.BatchCancelOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelAllSymbolOrdersRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiCancelAllSymbolOrdersRequest) Symbol(symbol string) ApiCancelAllSymbolOrdersRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiCancelAllSymbolOrdersRequest) Timestamp(timestamp int64) ApiCancelAllSymbolOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiCancelAllSymbolOrdersRequest) Signature(signature string) ApiCancelAllSymbolOrdersRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiCancelAllSymbolOrdersRequest) RecvWindow(recvWindow int64) ApiCancelAllSymbolOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCancelAllSymbolOrdersRequest) Execute() ([]AnyOforderocoOrder, *_nethttp.Response, error) {
	return r.ApiService.CancelAllSymbolOrdersExecute(r)
}

/*
CancelAllSymbolOrders Cancel all Open Orders on a Symbol (TRADE)

Cancels all active orders on a symbol.\
This includes OCO orders.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelAllSymbolOrdersRequest
*/
func (a *TradeApiService) CancelAllSymbolOrders(ctx _context.Context) ApiCancelAllSymbolOrdersRequest {
	return ApiCancelAllSymbolOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []AnyOforderocoOrder
func (a *TradeApiService) CancelAllSymbolOrdersExecute(r ApiCancelAllSymbolOrdersRequest) ([]AnyOforderocoOrder, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []AnyOforderocoOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.CancelAllSymbolOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelOrderRequest struct {
	ctx               _context.Context
	ApiService        *TradeApiService
	symbol            *string
	timestamp         *int64
	signature         *string
	orderId           *int64
	origClientOrderId *string
	newClientOrderId  *string
	recvWindow        *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiCancelOrderRequest) Symbol(symbol string) ApiCancelOrderRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiCancelOrderRequest) Timestamp(timestamp int64) ApiCancelOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiCancelOrderRequest) Signature(signature string) ApiCancelOrderRequest {
	r.signature = &signature
	return r
}

// Order id
func (r ApiCancelOrderRequest) OrderId(orderId int64) ApiCancelOrderRequest {
	r.orderId = &orderId
	return r
}

// Order id from client
func (r ApiCancelOrderRequest) OrigClientOrderId(origClientOrderId string) ApiCancelOrderRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiCancelOrderRequest) NewClientOrderId(newClientOrderId string) ApiCancelOrderRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiCancelOrderRequest) RecvWindow(recvWindow int64) ApiCancelOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCancelOrderRequest) Execute() (Order, *_nethttp.Response, error) {
	return r.ApiService.CancelOrderExecute(r)
}

/*
CancelOrder Cancel Order (TRADE)

Cancel an active order.

Either `orderId` or `origClientOrderId` must be sent.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCancelOrderRequest
*/
func (a *TradeApiService) CancelOrder(ctx _context.Context) ApiCancelOrderRequest {
	return ApiCancelOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Order
func (a *TradeApiService) CancelOrderExecute(r ApiCancelOrderRequest) (Order, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Order
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.CancelOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOcoOrderRequest struct {
	ctx                  _context.Context
	ApiService           *TradeApiService
	symbol               *string
	side                 *string
	quantity             *float64
	price                *float64
	stopPrice            *float64
	timestamp            *int64
	signature            *string
	listClientOrderId    *string
	limitClientOrderId   *string
	limitIcebergQty      *float64
	stopClientOrderId    *string
	stopLimitPrice       *float64
	stopIcebergQty       *float64
	stopLimitTimeInForce *string
	newOrderRespType     *string
	sideEffectType       *string
	recvWindow           *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiCreateOcoOrderRequest) Symbol(symbol string) ApiCreateOcoOrderRequest {
	r.symbol = &symbol
	return r
}

// SELL or BUY
func (r ApiCreateOcoOrderRequest) Side(side string) ApiCreateOcoOrderRequest {
	r.side = &side
	return r
}
func (r ApiCreateOcoOrderRequest) Quantity(quantity float64) ApiCreateOcoOrderRequest {
	r.quantity = &quantity
	return r
}

// Order price
func (r ApiCreateOcoOrderRequest) Price(price float64) ApiCreateOcoOrderRequest {
	r.price = &price
	return r
}
func (r ApiCreateOcoOrderRequest) StopPrice(stopPrice float64) ApiCreateOcoOrderRequest {
	r.stopPrice = &stopPrice
	return r
}

// UTC timestamp in ms
func (r ApiCreateOcoOrderRequest) Timestamp(timestamp int64) ApiCreateOcoOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiCreateOcoOrderRequest) Signature(signature string) ApiCreateOcoOrderRequest {
	r.signature = &signature
	return r
}

// A unique Id for the entire orderList
func (r ApiCreateOcoOrderRequest) ListClientOrderId(listClientOrderId string) ApiCreateOcoOrderRequest {
	r.listClientOrderId = &listClientOrderId
	return r
}

// A unique Id for the limit order
func (r ApiCreateOcoOrderRequest) LimitClientOrderId(limitClientOrderId string) ApiCreateOcoOrderRequest {
	r.limitClientOrderId = &limitClientOrderId
	return r
}
func (r ApiCreateOcoOrderRequest) LimitIcebergQty(limitIcebergQty float64) ApiCreateOcoOrderRequest {
	r.limitIcebergQty = &limitIcebergQty
	return r
}

// A unique Id for the stop loss/stop loss limit leg
func (r ApiCreateOcoOrderRequest) StopClientOrderId(stopClientOrderId string) ApiCreateOcoOrderRequest {
	r.stopClientOrderId = &stopClientOrderId
	return r
}

// If provided, stopLimitTimeInForce is required.
func (r ApiCreateOcoOrderRequest) StopLimitPrice(stopLimitPrice float64) ApiCreateOcoOrderRequest {
	r.stopLimitPrice = &stopLimitPrice
	return r
}
func (r ApiCreateOcoOrderRequest) StopIcebergQty(stopIcebergQty float64) ApiCreateOcoOrderRequest {
	r.stopIcebergQty = &stopIcebergQty
	return r
}
func (r ApiCreateOcoOrderRequest) StopLimitTimeInForce(stopLimitTimeInForce string) ApiCreateOcoOrderRequest {
	r.stopLimitTimeInForce = &stopLimitTimeInForce
	return r
}

// Set the response JSON.
func (r ApiCreateOcoOrderRequest) NewOrderRespType(newOrderRespType string) ApiCreateOcoOrderRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}

// Default NO_SIDE_EFFECT
func (r ApiCreateOcoOrderRequest) SideEffectType(sideEffectType string) ApiCreateOcoOrderRequest {
	r.sideEffectType = &sideEffectType
	return r
}

// The value cannot be greater than 60000
func (r ApiCreateOcoOrderRequest) RecvWindow(recvWindow int64) ApiCreateOcoOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOcoOrderRequest) Execute() (InlineResponse2004, *_nethttp.Response, error) {
	return r.ApiService.CreateOcoOrderExecute(r)
}

/*
CreateOcoOrder New OCO (TRADE)

Send in a new OCO

- Price Restrictions:
  - `SELL`: Limit Price > Last Price > Stop Price
  - `BUY`: Limit Price < Last Price < Stop Price
- Quantity Restrictions:
    - Both legs must have the same quantity
    - `ICEBERG` quantities however do not have to be the same
- Order Rate Limit
    - `OCO` counts as 2 orders against the order rate limit.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOcoOrderRequest
*/
func (a *TradeApiService) CreateOcoOrder(ctx _context.Context) ApiCreateOcoOrderRequest {
	return ApiCreateOcoOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2004
func (a *TradeApiService) CreateOcoOrderExecute(r ApiCreateOcoOrderRequest) (InlineResponse2004, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2004
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.CreateOcoOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/oco"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}
	if r.stopPrice == nil {
		return localVarReturnValue, nil, reportError("stopPrice is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.listClientOrderId != nil {
		localVarQueryParams.Add("listClientOrderId", parameterToString(*r.listClientOrderId, ""))
	}
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	if r.limitClientOrderId != nil {
		localVarQueryParams.Add("limitClientOrderId", parameterToString(*r.limitClientOrderId, ""))
	}
	localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	if r.limitIcebergQty != nil {
		localVarQueryParams.Add("limitIcebergQty", parameterToString(*r.limitIcebergQty, ""))
	}
	if r.stopClientOrderId != nil {
		localVarQueryParams.Add("stopClientOrderId", parameterToString(*r.stopClientOrderId, ""))
	}
	localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	if r.stopLimitPrice != nil {
		localVarQueryParams.Add("stopLimitPrice", parameterToString(*r.stopLimitPrice, ""))
	}
	if r.stopIcebergQty != nil {
		localVarQueryParams.Add("stopIcebergQty", parameterToString(*r.stopIcebergQty, ""))
	}
	if r.stopLimitTimeInForce != nil {
		localVarQueryParams.Add("stopLimitTimeInForce", parameterToString(*r.stopLimitTimeInForce, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.sideEffectType != nil {
		localVarQueryParams.Add("sideEffectType", parameterToString(*r.sideEffectType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateOrderRequest struct {
	ctx              _context.Context
	ApiService       *TradeApiService
	symbol           *string
	side             *string
	type_            *string
	timestamp        *int64
	signature        *string
	timeInForce      *string
	quantity         *float64
	quoteOrderQty    *float64
	price            *float64
	newClientOrderId *string
	stopPrice        *float64
	icebergQty       *float64
	newOrderRespType *string
	recvWindow       *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiCreateOrderRequest) Symbol(symbol string) ApiCreateOrderRequest {
	r.symbol = &symbol
	return r
}

// SELL or BUY
func (r ApiCreateOrderRequest) Side(side string) ApiCreateOrderRequest {
	r.side = &side
	return r
}

// Order type
func (r ApiCreateOrderRequest) Type_(type_ string) ApiCreateOrderRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiCreateOrderRequest) Timestamp(timestamp int64) ApiCreateOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiCreateOrderRequest) Signature(signature string) ApiCreateOrderRequest {
	r.signature = &signature
	return r
}

// Order time in force
func (r ApiCreateOrderRequest) TimeInForce(timeInForce string) ApiCreateOrderRequest {
	r.timeInForce = &timeInForce
	return r
}

// Order quantity
func (r ApiCreateOrderRequest) Quantity(quantity float64) ApiCreateOrderRequest {
	r.quantity = &quantity
	return r
}

// Quote quantity
func (r ApiCreateOrderRequest) QuoteOrderQty(quoteOrderQty float64) ApiCreateOrderRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

// Order price
func (r ApiCreateOrderRequest) Price(price float64) ApiCreateOrderRequest {
	r.price = &price
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiCreateOrderRequest) NewClientOrderId(newClientOrderId string) ApiCreateOrderRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
func (r ApiCreateOrderRequest) StopPrice(stopPrice float64) ApiCreateOrderRequest {
	r.stopPrice = &stopPrice
	return r
}

// Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
func (r ApiCreateOrderRequest) IcebergQty(icebergQty float64) ApiCreateOrderRequest {
	r.icebergQty = &icebergQty
	return r
}

// Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
func (r ApiCreateOrderRequest) NewOrderRespType(newOrderRespType string) ApiCreateOrderRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}

// The value cannot be greater than 60000
func (r ApiCreateOrderRequest) RecvWindow(recvWindow int64) ApiCreateOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiCreateOrderRequest) Execute() (OneOforderResponseAckorderResponseResultorderResponseFull, *_nethttp.Response, error) {
	return r.ApiService.CreateOrderExecute(r)
}

/*
CreateOrder New Order (TRADE)

Send in a new order.

- `LIMIT_MAKER` are `LIMIT` orders that will be rejected if they would immediately match and trade as a taker.
- `STOP_LOSS` and `TAKE_PROFIT` will execute a `MARKET` order when the `stopPrice` is reached.
- Any `LIMIT` or `LIMIT_MAKER` type order can be made an iceberg order by sending an `icebergQty`.
- Any order with an `icebergQty` MUST have `timeInForce` set to `GTC`.
- `MARKET` orders using `quantity` specifies how much a user wants to buy or sell based on the market price.
- `MARKET` orders using `quoteOrderQty` specifies the amount the user wants to spend (when buying) or receive (when selling) of the quote asset; the correct quantity will be determined based on the market liquidity and `quoteOrderQty`.
- `MARKET` orders using `quoteOrderQty` will not break `LOT_SIZE` filter rules; the order will execute a quantity that will have the notional value as close as possible to `quoteOrderQty`.
- same `newClientOrderId` can be accepted only when the previous one is filled, otherwise the order will be rejected.

Trigger order price rules against market price for both `MARKET` and `LIMIT` versions:

- Price above market price: `STOP_LOSS` `BUY`, `TAKE_PROFIT` `SELL`
- Price below market price: `STOP_LOSS` `SELL`, `TAKE_PROFIT` `BUY`


Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateOrderRequest
*/
func (a *TradeApiService) CreateOrder(ctx _context.Context) ApiCreateOrderRequest {
	return ApiCreateOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OneOforderResponseAckorderResponseResultorderResponseFull
func (a *TradeApiService) CreateOrderExecute(r ApiCreateOrderRequest) (OneOforderResponseAckorderResponseResultorderResponseFull, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OneOforderResponseAckorderResponseResultorderResponseFull
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.CreateOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.quantity != nil {
		localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	}
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAccountRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiGetAccountRequest) Timestamp(timestamp int64) ApiGetAccountRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetAccountRequest) Signature(signature string) ApiGetAccountRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiGetAccountRequest) RecvWindow(recvWindow int64) ApiGetAccountRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAccountRequest) Execute() (Account, *_nethttp.Response, error) {
	return r.ApiService.GetAccountExecute(r)
}

/*
GetAccount Account Information (USER_DATA)

Get current account information.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAccountRequest
*/
func (a *TradeApiService) GetAccount(ctx _context.Context) ApiGetAccountRequest {
	return ApiGetAccountRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return Account
func (a *TradeApiService) GetAccountExecute(r ApiGetAccountRequest) (Account, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Account
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetAccount")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/account"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllOcoOrderRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	timestamp  *int64
	signature  *string
	fromId     *int64
	startTime  *int64
	endTime    *int64
	limit      *int32
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiGetAllOcoOrderRequest) Timestamp(timestamp int64) ApiGetAllOcoOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetAllOcoOrderRequest) Signature(signature string) ApiGetAllOcoOrderRequest {
	r.signature = &signature
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r ApiGetAllOcoOrderRequest) FromId(fromId int64) ApiGetAllOcoOrderRequest {
	r.fromId = &fromId
	return r
}

// UTC timestamp in ms
func (r ApiGetAllOcoOrderRequest) StartTime(startTime int64) ApiGetAllOcoOrderRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiGetAllOcoOrderRequest) EndTime(endTime int64) ApiGetAllOcoOrderRequest {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiGetAllOcoOrderRequest) Limit(limit int32) ApiGetAllOcoOrderRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiGetAllOcoOrderRequest) RecvWindow(recvWindow int64) ApiGetAllOcoOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAllOcoOrderRequest) Execute() ([]InlineResponse2006, *_nethttp.Response, error) {
	return r.ApiService.GetAllOcoOrderExecute(r)
}

/*
GetAllOcoOrder Query all OCO (USER_DATA)

Retrieves all OCO based on provided optional parameters

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllOcoOrderRequest
*/
func (a *TradeApiService) GetAllOcoOrder(ctx _context.Context) ApiGetAllOcoOrderRequest {
	return ApiGetAllOcoOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2006
func (a *TradeApiService) GetAllOcoOrderExecute(r ApiGetAllOcoOrderRequest) ([]InlineResponse2006, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2006
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetAllOcoOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllOrdersRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	orderId    *int64
	startTime  *int64
	endTime    *int64
	limit      *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiGetAllOrdersRequest) Symbol(symbol string) ApiGetAllOrdersRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiGetAllOrdersRequest) Timestamp(timestamp int64) ApiGetAllOrdersRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetAllOrdersRequest) Signature(signature string) ApiGetAllOrdersRequest {
	r.signature = &signature
	return r
}

// Order id
func (r ApiGetAllOrdersRequest) OrderId(orderId int64) ApiGetAllOrdersRequest {
	r.orderId = &orderId
	return r
}

// UTC timestamp in ms
func (r ApiGetAllOrdersRequest) StartTime(startTime int64) ApiGetAllOrdersRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiGetAllOrdersRequest) EndTime(endTime int64) ApiGetAllOrdersRequest {
	r.endTime = &endTime
	return r
}

// Default 500; max 1000.
func (r ApiGetAllOrdersRequest) Limit(limit int32) ApiGetAllOrdersRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiGetAllOrdersRequest) RecvWindow(recvWindow int64) ApiGetAllOrdersRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAllOrdersRequest) Execute() ([]OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.GetAllOrdersExecute(r)
}

/*
GetAllOrders All Orders (USER_DATA)

Get all account orders; active, canceled, or filled..

- If `orderId` is set, it will get orders >= that `orderId`. Otherwise most recent orders are returned.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.
- If `startTime` and/or `endTime` provided, `orderId` is not required

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllOrdersRequest
*/
func (a *TradeApiService) GetAllOrders(ctx _context.Context) ApiGetAllOrdersRequest {
	return ApiGetAllOrdersRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []OrderDetails
func (a *TradeApiService) GetAllOrdersExecute(r ApiGetAllOrdersRequest) ([]OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetAllOrders")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/allOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllSymbolOrderRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	timestamp  *int64
	signature  *string
	symbol     *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiGetAllSymbolOrderRequest) Timestamp(timestamp int64) ApiGetAllSymbolOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetAllSymbolOrderRequest) Signature(signature string) ApiGetAllSymbolOrderRequest {
	r.signature = &signature
	return r
}

// Trading symbol, e.g. BNBUSDT
func (r ApiGetAllSymbolOrderRequest) Symbol(symbol string) ApiGetAllSymbolOrderRequest {
	r.symbol = &symbol
	return r
}

// The value cannot be greater than 60000
func (r ApiGetAllSymbolOrderRequest) RecvWindow(recvWindow int64) ApiGetAllSymbolOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetAllSymbolOrderRequest) Execute() ([]OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.GetAllSymbolOrderExecute(r)
}

/*
GetAllSymbolOrder Current Open Orders (USER_DATA)

Get all open orders on a symbol. Careful when accessing this with no symbol.

Weight(IP):\
`3` for a single symbol;\
`40` when the symbol parameter is omitted;

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllSymbolOrderRequest
*/
func (a *TradeApiService) GetAllSymbolOrder(ctx _context.Context) ApiGetAllSymbolOrderRequest {
	return ApiGetAllSymbolOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []OrderDetails
func (a *TradeApiService) GetAllSymbolOrderExecute(r ApiGetAllSymbolOrderRequest) ([]OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetAllSymbolOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.symbol != nil {
		localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenedOcoOrderRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiGetOpenedOcoOrderRequest) Timestamp(timestamp int64) ApiGetOpenedOcoOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetOpenedOcoOrderRequest) Signature(signature string) ApiGetOpenedOcoOrderRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiGetOpenedOcoOrderRequest) RecvWindow(recvWindow int64) ApiGetOpenedOcoOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOpenedOcoOrderRequest) Execute() ([]InlineResponse2007, *_nethttp.Response, error) {
	return r.ApiService.GetOpenedOcoOrderExecute(r)
}

/*
GetOpenedOcoOrder Query Open OCO (USER_DATA)

Weight(IP): 3

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOpenedOcoOrderRequest
*/
func (a *TradeApiService) GetOpenedOcoOrder(ctx _context.Context) ApiGetOpenedOcoOrderRequest {
	return ApiGetOpenedOcoOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2007
func (a *TradeApiService) GetOpenedOcoOrderExecute(r ApiGetOpenedOcoOrderRequest) ([]InlineResponse2007, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2007
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetOpenedOcoOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/openOrderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderRequest struct {
	ctx               _context.Context
	ApiService        *TradeApiService
	symbol            *string
	timestamp         *int64
	signature         *string
	orderId           *int64
	origClientOrderId *string
	recvWindow        *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiGetOrderRequest) Symbol(symbol string) ApiGetOrderRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiGetOrderRequest) Timestamp(timestamp int64) ApiGetOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetOrderRequest) Signature(signature string) ApiGetOrderRequest {
	r.signature = &signature
	return r
}

// Order id
func (r ApiGetOrderRequest) OrderId(orderId int64) ApiGetOrderRequest {
	r.orderId = &orderId
	return r
}

// Order id from client
func (r ApiGetOrderRequest) OrigClientOrderId(origClientOrderId string) ApiGetOrderRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiGetOrderRequest) RecvWindow(recvWindow int64) ApiGetOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOrderRequest) Execute() (OrderDetails, *_nethttp.Response, error) {
	return r.ApiService.GetOrderExecute(r)
}

/*
GetOrder Query Order (USER_DATA)

Check an order's status.

- Either `orderId` or `origClientOrderId` must be sent.
- For some historical orders `cummulativeQuoteQty` will be < 0, meaning the data is not available at this time.

Weight(IP): 2

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderRequest
*/
func (a *TradeApiService) GetOrder(ctx _context.Context) ApiGetOrderRequest {
	return ApiGetOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return OrderDetails
func (a *TradeApiService) GetOrderExecute(r ApiGetOrderRequest) (OrderDetails, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  OrderDetails
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderRateLimitRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	timestamp  *int64
	signature  *string
	recvWindow *int64
}

// UTC timestamp in ms
func (r ApiGetOrderRateLimitRequest) Timestamp(timestamp int64) ApiGetOrderRateLimitRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetOrderRateLimitRequest) Signature(signature string) ApiGetOrderRateLimitRequest {
	r.signature = &signature
	return r
}

// The value cannot be greater than 60000
func (r ApiGetOrderRateLimitRequest) RecvWindow(recvWindow int64) ApiGetOrderRateLimitRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetOrderRateLimitRequest) Execute() ([]InlineResponse2008, *_nethttp.Response, error) {
	return r.ApiService.GetOrderRateLimitExecute(r)
}

/*
GetOrderRateLimit Query Current Order Count Usage (TRADE)

Displays the user's current order count usage for all intervals.

Weight(IP): 20

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrderRateLimitRequest
*/
func (a *TradeApiService) GetOrderRateLimit(ctx _context.Context) ApiGetOrderRateLimitRequest {
	return ApiGetOrderRateLimitRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []InlineResponse2008
func (a *TradeApiService) GetOrderRateLimitExecute(r ApiGetOrderRateLimitRequest) ([]InlineResponse2008, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []InlineResponse2008
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetOrderRateLimit")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/rateLimit/order"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSpecificOcoOrderRequest struct {
	ctx               _context.Context
	ApiService        *TradeApiService
	timestamp         *int64
	signature         *string
	orderListId       *int64
	origClientOrderId *string
	recvWindow        *int64
}

// UTC timestamp in ms
func (r ApiGetSpecificOcoOrderRequest) Timestamp(timestamp int64) ApiGetSpecificOcoOrderRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetSpecificOcoOrderRequest) Signature(signature string) ApiGetSpecificOcoOrderRequest {
	r.signature = &signature
	return r
}

// Order list id
func (r ApiGetSpecificOcoOrderRequest) OrderListId(orderListId int64) ApiGetSpecificOcoOrderRequest {
	r.orderListId = &orderListId
	return r
}

// Order id from client
func (r ApiGetSpecificOcoOrderRequest) OrigClientOrderId(origClientOrderId string) ApiGetSpecificOcoOrderRequest {
	r.origClientOrderId = &origClientOrderId
	return r
}

// The value cannot be greater than 60000
func (r ApiGetSpecificOcoOrderRequest) RecvWindow(recvWindow int64) ApiGetSpecificOcoOrderRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetSpecificOcoOrderRequest) Execute() (InlineResponse2005, *_nethttp.Response, error) {
	return r.ApiService.GetSpecificOcoOrderExecute(r)
}

/*
GetSpecificOcoOrder Query OCO (USER_DATA)

Retrieves a specific OCO based on provided optional parameters

Weight(IP): 2

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSpecificOcoOrderRequest
*/
func (a *TradeApiService) GetSpecificOcoOrder(ctx _context.Context) ApiGetSpecificOcoOrderRequest {
	return ApiGetSpecificOcoOrderRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return InlineResponse2005
func (a *TradeApiService) GetSpecificOcoOrderExecute(r ApiGetSpecificOcoOrderRequest) (InlineResponse2005, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  InlineResponse2005
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetSpecificOcoOrder")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/orderList"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	if r.orderListId != nil {
		localVarQueryParams.Add("orderListId", parameterToString(*r.orderListId, ""))
	}
	if r.origClientOrderId != nil {
		localVarQueryParams.Add("origClientOrderId", parameterToString(*r.origClientOrderId, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTradesRequest struct {
	ctx        _context.Context
	ApiService *TradeApiService
	symbol     *string
	timestamp  *int64
	signature  *string
	orderId    *int64
	startTime  *int64
	endTime    *int64
	fromId     *int64
	limit      *int32
	recvWindow *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiGetTradesRequest) Symbol(symbol string) ApiGetTradesRequest {
	r.symbol = &symbol
	return r
}

// UTC timestamp in ms
func (r ApiGetTradesRequest) Timestamp(timestamp int64) ApiGetTradesRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiGetTradesRequest) Signature(signature string) ApiGetTradesRequest {
	r.signature = &signature
	return r
}

// This can only be used in combination with symbol.
func (r ApiGetTradesRequest) OrderId(orderId int64) ApiGetTradesRequest {
	r.orderId = &orderId
	return r
}

// UTC timestamp in ms
func (r ApiGetTradesRequest) StartTime(startTime int64) ApiGetTradesRequest {
	r.startTime = &startTime
	return r
}

// UTC timestamp in ms
func (r ApiGetTradesRequest) EndTime(endTime int64) ApiGetTradesRequest {
	r.endTime = &endTime
	return r
}

// Trade id to fetch from. Default gets most recent trades.
func (r ApiGetTradesRequest) FromId(fromId int64) ApiGetTradesRequest {
	r.fromId = &fromId
	return r
}

// Default 500; max 1000.
func (r ApiGetTradesRequest) Limit(limit int32) ApiGetTradesRequest {
	r.limit = &limit
	return r
}

// The value cannot be greater than 60000
func (r ApiGetTradesRequest) RecvWindow(recvWindow int64) ApiGetTradesRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiGetTradesRequest) Execute() ([]MyTrade, *_nethttp.Response, error) {
	return r.ApiService.GetTradesExecute(r)
}

/*
GetTrades Account Trade List (USER_DATA)

Get trades for a specific account and symbol.

If `fromId` is set, it will get id >= that `fromId`. Otherwise most recent orders are returned.

Weight(IP): 10

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTradesRequest
*/
func (a *TradeApiService) GetTrades(ctx _context.Context) ApiGetTradesRequest {
	return ApiGetTradesRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return []MyTrade
func (a *TradeApiService) GetTradesExecute(r ApiGetTradesRequest) ([]MyTrade, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []MyTrade
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.GetTrades")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/myTrades"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	if r.orderId != nil {
		localVarQueryParams.Add("orderId", parameterToString(*r.orderId, ""))
	}
	if r.startTime != nil {
		localVarQueryParams.Add("startTime", parameterToString(*r.startTime, ""))
	}
	if r.endTime != nil {
		localVarQueryParams.Add("endTime", parameterToString(*r.endTime, ""))
	}
	if r.fromId != nil {
		localVarQueryParams.Add("fromId", parameterToString(*r.fromId, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiTestOrderCreationRequest struct {
	ctx              _context.Context
	ApiService       *TradeApiService
	symbol           *string
	side             *string
	type_            *string
	timestamp        *int64
	signature        *string
	timeInForce      *string
	quantity         *float64
	quoteOrderQty    *float64
	price            *float64
	newClientOrderId *string
	stopPrice        *float64
	icebergQty       *float64
	newOrderRespType *string
	recvWindow       *int64
}

// Trading symbol, e.g. BNBUSDT
func (r ApiTestOrderCreationRequest) Symbol(symbol string) ApiTestOrderCreationRequest {
	r.symbol = &symbol
	return r
}

// SELL or BUY
func (r ApiTestOrderCreationRequest) Side(side string) ApiTestOrderCreationRequest {
	r.side = &side
	return r
}

// Order type
func (r ApiTestOrderCreationRequest) Type_(type_ string) ApiTestOrderCreationRequest {
	r.type_ = &type_
	return r
}

// UTC timestamp in ms
func (r ApiTestOrderCreationRequest) Timestamp(timestamp int64) ApiTestOrderCreationRequest {
	r.timestamp = &timestamp
	return r
}

// Signature
func (r ApiTestOrderCreationRequest) Signature(signature string) ApiTestOrderCreationRequest {
	r.signature = &signature
	return r
}

// Order time in force
func (r ApiTestOrderCreationRequest) TimeInForce(timeInForce string) ApiTestOrderCreationRequest {
	r.timeInForce = &timeInForce
	return r
}

// Order quantity
func (r ApiTestOrderCreationRequest) Quantity(quantity float64) ApiTestOrderCreationRequest {
	r.quantity = &quantity
	return r
}

// Quote quantity
func (r ApiTestOrderCreationRequest) QuoteOrderQty(quoteOrderQty float64) ApiTestOrderCreationRequest {
	r.quoteOrderQty = &quoteOrderQty
	return r
}

// Order price
func (r ApiTestOrderCreationRequest) Price(price float64) ApiTestOrderCreationRequest {
	r.price = &price
	return r
}

// Used to uniquely identify this cancel. Automatically generated by default
func (r ApiTestOrderCreationRequest) NewClientOrderId(newClientOrderId string) ApiTestOrderCreationRequest {
	r.newClientOrderId = &newClientOrderId
	return r
}

// Used with STOP_LOSS, STOP_LOSS_LIMIT, TAKE_PROFIT, and TAKE_PROFIT_LIMIT orders.
func (r ApiTestOrderCreationRequest) StopPrice(stopPrice float64) ApiTestOrderCreationRequest {
	r.stopPrice = &stopPrice
	return r
}

// Used with LIMIT, STOP_LOSS_LIMIT, and TAKE_PROFIT_LIMIT to create an iceberg order.
func (r ApiTestOrderCreationRequest) IcebergQty(icebergQty float64) ApiTestOrderCreationRequest {
	r.icebergQty = &icebergQty
	return r
}

// Set the response JSON. MARKET and LIMIT order types default to FULL, all other orders default to ACK.
func (r ApiTestOrderCreationRequest) NewOrderRespType(newOrderRespType string) ApiTestOrderCreationRequest {
	r.newOrderRespType = &newOrderRespType
	return r
}

// The value cannot be greater than 60000
func (r ApiTestOrderCreationRequest) RecvWindow(recvWindow int64) ApiTestOrderCreationRequest {
	r.recvWindow = &recvWindow
	return r
}

func (r ApiTestOrderCreationRequest) Execute() (map[string]interface{}, *_nethttp.Response, error) {
	return r.ApiService.TestOrderCreationExecute(r)
}

/*
TestOrderCreation Test New Order (TRADE)

Test new order creation and signature/recvWindow long.
Creates and validates a new order but does not send it into the matching engine.

Weight(IP): 1

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiTestOrderCreationRequest
*/
func (a *TradeApiService) TestOrderCreation(ctx _context.Context) ApiTestOrderCreationRequest {
	return ApiTestOrderCreationRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *TradeApiService) TestOrderCreationExecute(r ApiTestOrderCreationRequest) (map[string]interface{}, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradeApiService.TestOrderCreation")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v3/order/test"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.symbol == nil {
		return localVarReturnValue, nil, reportError("symbol is required and must be specified")
	}
	if r.side == nil {
		return localVarReturnValue, nil, reportError("side is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}
	if r.timestamp == nil {
		return localVarReturnValue, nil, reportError("timestamp is required and must be specified")
	}
	if r.signature == nil {
		return localVarReturnValue, nil, reportError("signature is required and must be specified")
	}

	localVarQueryParams.Add("symbol", parameterToString(*r.symbol, ""))
	localVarQueryParams.Add("side", parameterToString(*r.side, ""))
	localVarQueryParams.Add("type", parameterToString(*r.type_, ""))
	if r.timeInForce != nil {
		localVarQueryParams.Add("timeInForce", parameterToString(*r.timeInForce, ""))
	}
	if r.quantity != nil {
		localVarQueryParams.Add("quantity", parameterToString(*r.quantity, ""))
	}
	if r.quoteOrderQty != nil {
		localVarQueryParams.Add("quoteOrderQty", parameterToString(*r.quoteOrderQty, ""))
	}
	if r.price != nil {
		localVarQueryParams.Add("price", parameterToString(*r.price, ""))
	}
	if r.newClientOrderId != nil {
		localVarQueryParams.Add("newClientOrderId", parameterToString(*r.newClientOrderId, ""))
	}
	if r.stopPrice != nil {
		localVarQueryParams.Add("stopPrice", parameterToString(*r.stopPrice, ""))
	}
	if r.icebergQty != nil {
		localVarQueryParams.Add("icebergQty", parameterToString(*r.icebergQty, ""))
	}
	if r.newOrderRespType != nil {
		localVarQueryParams.Add("newOrderRespType", parameterToString(*r.newOrderRespType, ""))
	}
	if r.recvWindow != nil {
		localVarQueryParams.Add("recvWindow", parameterToString(*r.recvWindow, ""))
	}
	localVarQueryParams.Add("timestamp", parameterToString(*r.timestamp, ""))
	localVarQueryParams.Add("signature", parameterToString(*r.signature, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["ApiKeyAuth"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["X-MBX-APIKEY"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ModelError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
